## Ch1 绪论
---

可计算理论、计算复杂性理论、算法设计和分析、计算机软件

---
### 算法的概念

计算定义：机械的规则和步骤
算法定义：
1. 终止性
2. 确定性
3. 可行性
4. 输入
5. 输出
问题定义：输入和输出间的 relative
问题实例就是 relative 中的一个 pair

正确性分析：
1. 必须能够终止
2. 输出必须正确

复杂性分析：
1. 时间、空间、IO

```
插入排序伪代码
```

时间复杂性，描述的是随问题规模扩大后，时间增长有多快

分析插入排序的时间

![[Pasted image 20250610163210.png]]

![[Pasted image 20250610163307.png]]

![[Pasted image 20250610163433.png]]
![[Pasted image 20250610163517.png]]

---
## Ch2 数学基础
---

![[Pasted image 20250610163642.png]]
![[Pasted image 20250610163658.png]]![[Pasted image 20250610163711.png]]![[Pasted image 20250610163721.png]]![[Pasted image 20250610163735.png]]![[Pasted image 20250610163754.png]]![[Pasted image 20250610163800.png]]![[Pasted image 20250610163814.png]]

---

![[Pasted image 20250610163826.png]]![[Pasted image 20250610163857.png]]![[Pasted image 20250610163911.png]]![[Pasted image 20250610163911.png]]![[Pasted image 20250610163930.png]]![[Pasted image 20250610163947.png]]![[Pasted image 20250610164006.png]]![[Pasted image 20250610164013.png]]

---

![[Pasted image 20250610164030.png]]![[Pasted image 20250610164044.png]]![[Pasted image 20250610164108.png]]![[Pasted image 20250610164118.png]]![[Pasted image 20250610164127.png]]![[Pasted image 20250610164139.png]]

---

![[Pasted image 20250610164257.png]]![[Pasted image 20250610164331.png]]![[Pasted image 20250610164345.png]]

---

![[Pasted image 20250610164401.png]]
![[Pasted image 20250610164416.png]]![[Pasted image 20250610164520.png]]![[Pasted image 20250610164526.png]]![[Pasted image 20250610164532.png]]![[Pasted image 20250610164540.png]]![[Pasted image 20250610164546.png]]![[Pasted image 20250610164553.png]]

---

![[Pasted image 20250610164641.png]]![[Pasted image 20250610164703.png]]

---

## Ch3 分治与递归
---
![[Pasted image 20250610164803.png]]

---

![[Pasted image 20250610164751.png]]![[Pasted image 20250610164946.png]]

---

三个阶段：
1. 划分
2. 求解
3. 合并

---
### 快速排序

1. 划分：按 `A[q]` 划分
2. 求解：分别递归 `A[p...q-1], A[q+1...r]`
3. 合并：nope
> ![[Pasted image 20250610165519.png]]
 这段划分代码，默认按 `A[r]` 分

>随机快速排序 时间复杂度计算 ![[Pasted image 20250610170414.png]]![[Pasted image 20250610170940.png]]

![[Pasted image 20250610170959.png]]
> 比较排序的最优复杂度 
> ![[Pasted image 20250610171013.png]]


---
### 线性排序方法

1. 计数排序
	- 在值域上建立计数器
	- 值域必须很小
	- 稳定
	- $O(n+k)$
2. 希尔排序
	- 按数位排，从低到高
	- 反复排序
	- $O(d(n+k))$
3. 桶排序


---
### 中位数和顺序统计量

减治算法：缩小求解空间，丢弃无用子问题
而分治是求解每个子问题

典型：寻找第 $k$ 大数
![[Pasted image 20250610172459.png]]
![[Pasted image 20250610172753.png]]![[Pasted image 20250610172816.png]]

---
### 平面最近点对

---
### 凸包算法

---
### FFT

---
### 整数乘

小数复杂度，是master法算的

---
## Ch4 动态规划

分治可能会重复计算子问题
![[Pasted image 20250611175606.png]]
![[Pasted image 20250611175620.png]]

---
### 矩阵链相乘
> 优化子结构证明
> ![[Pasted image 20250611175852.png]]
> ![[Pasted image 20250611175931.png]]

> 转移方程写法
> ![[Pasted image 20250611180042.png]]

> 伪代码写法
> ![[Pasted image 20250611180934.png]]
> ![[Pasted image 20250611181009.png]]

> 分析复杂度写法
> ![[Pasted image 20250611181034.png]]

> 记忆化递归写法
> ![[Pasted image 20250611181138.png]]
---

### 最长公共子序列

---
### 背包问题

---
### 最优 BST

---
## Ch5 贪心算法
---
### 基本原理
---
### 活动选择问题
---
### huffman编码
---
### 最小生成树

---
## Ch6 平摊分析
---
### 基本原理

面对数据结构上的一系列操作，在分析复杂度时，总是会考虑每个操作的 **最坏复杂度**

但是操作之间是相关的，一个操作多花的代价，会在另一个操作省下来，因此需要平摊分析

![[Pasted image 20250611184724.png]]

### 聚集法

计算操作序列的总复杂度 $T(n)$，然后 $\frac{T(n)}n$ 作为平摊复杂度
![[Pasted image 20250611185037.png]]
![[Pasted image 20250611185153.png]]

---
### 会计法

为每个操作分配 **平摊代价**，比实际代价高的，附加到数据对象上存为 **credit** ，低的就从现有的 **credit** 取

**预付代价**的思想

![[Pasted image 20250611185538.png]]
> 每次操作，至多将一个 bit 置 1
> ![[Pasted image 20250611185554.png]]


---
### 势能法

不再为每个数据对象单独分配 **credit**，而是记录整个数据结构的**credit总和**，通过势能函数 $\Phi(D)$ 表示
![[Pasted image 20250611190347.png]]
![[Pasted image 20250611190400.png]]

---
### 摊还分析总结

聚集法针对分析 **操作**
会计法针对分析 **对象**
势能法针对分析 **数据结构**

这三种分析本质相同，都是构造合适的分配代价形式

---
### 例：动态表分析

该数据结构支持插入和删除元素，并在空间不足时 扩张空间

#### 聚集分析：
1. 扩张是 $O(n)$ 的，但不能每个操作都视为 $O(n)$ 上界
![[Pasted image 20250611191757.png]]
2. 由于扩张大小是动态的，所以采用求和 $\Sigma$ 分析总代价

#### 会计分析：
针对元素分配 **credit**
![[Pasted image 20250611192000.png]]
只需要保证 **credit** 总和非负

注意第三个 credit 的分配，每次复制后，原有的 credit 就消耗完了，在此之后插入的每一个元素，都会恢复额外的一个 credit，由于是双倍元素才扩张，因此插入最后一个元素后，刚好所有人都有 credit
#### 势能分析：
![[Pasted image 20250611192618.png]]

---
下面添加删除操作，当元素少于一定数量时，需要释放多余空间

不能与扩张的界限相同，否则会产生在临界点反复横跳的情况，导致每个操作真的可以达到最坏复杂度
![[Pasted image 20250611193444.png]]
将界限设定在 $\frac{n}{4}$ 即可
![[Pasted image 20250611193206.png]]
如图，势能函数的设计，需要通过临界点的状态来反推
注意到图中的 $\Phi(T)$ 是一个连续、非负函数

势能函数的设计，不一定是一个单调函数，最重要的是确定增长方向与极值点

---
## Ch7 搜索
---
把问题抽象为 **决策树** 的思想

### 搜索策略的比较

#### 爬山法

为每个决策状态定义 **启发式函数**，每次递归优先选择某些节点进行 **DFS**

#### Best-First

将所有没搜完的节点，放在一个**堆**里，同样使用启发式函数
只不过是 **启发** 的范围比爬山法更大

### 剪枝法

综合以上两种做法，选择时采用 **启发式函数**
选择分支时，估计找到解需要的**步数**，限制最大深度
如果当前分支肯定找不到解，就直接终止，**剪枝**

---
### 任务分配问题

若干工人，若干任务，一一对应分配使得代价最小，每对分配的代价独立

---
### 0/1背包

按 $V/W$ 降序排列，以此确定启发函数，进行 DFS 剪枝