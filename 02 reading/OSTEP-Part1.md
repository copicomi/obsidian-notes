[[OSTEP 操作系统导论]]
#reading #操作系统 
## CPU 虚拟化 
### 1. 抽象：进程

把任务抽象为进程，通过进程**时分共享CPU**，实现虚拟化

进程的组成：
1. 内存空间
	1. 代码
	2. 堆、静态变量
	3. 栈
2. 寄存器

状态：
1. `running`
2. `blocked`
	- 被 IO 操作阻塞
	- 此时让出 CPU
3. `ready`

进程 API：`fork()`,`exec()`,`wait()`

### 2. 机制：受限执行

进程切换的实现机制

1. OS 不希望 程序 做越界的操作
	- 提供 *用户模式* 和 *内核模式*
	- 当 user 想要执行 特权操作 时
		- 调用 trap 命令，进入 kernel mode
		- 结束后返回到 user mode 
	- trap table 指示当 user 陷入 kernel 时应当执行什么代码

2. OS 希望随时都能抢占 CPU 控制权
	- 提供 *时钟中断*
	- 每隔一段时间，硬件就启用中断程序，把 CPU 让给操作系统
	- 此时 OS 决定是否切换进程

3. OS 如何进行进程切换？
	- 时钟中断，从 trap 陷入 OS
	- 保存和恢复上下文
		- OS 保存新进程的结构
		- OS 加载新进程的结构
	- 中断结束，从 trap 返回

4. OS 如何处理中断嵌套？
	- 一个简单的方法是：中断期间禁止中断
	- *在并发部分详细讨论*

### 3. 策略：进程调度

决定将 CPU 分配给哪个进程

评价标准：
1. 性能：周转时间
2. 公平：机会平等
3. 交互性：响应时间

策略：
1. FIFO 先进先出
	- 存在护航效应，性能差
2. SJF 最短任务优先
	- 性能好
	- 受到 任务到达时间 的限制
		- 必须等待**先到的长任务**
3. STCP 最短完成时间优先
	- 性能最优
4. RR 轮转
	- 交互性好，便于响应
	- 牺牲性能
	- time slice 的权衡：
		- 过长：响应不敏感
		- 过短：上下文切换过于频繁
5. MLFQ 多级反馈队列
	- 考量历史情况，为进程分配优先级
	- 规则：
		1. 高优先级，先执行
		2. 同优先级，RR 执行
		3. 初始都为最高优先级
		4. 用光本层的时间配额后，降低进程优先级
		5. 每隔一段时间，把所有人移至最高级
6. 比例份额调度
	- 采用随机数，决定调用哪个进程
	- 进程的比例分配策略不确定
	- 适用于 用户明确 如何分配固定比例 的情况
	- 未广泛使用

细节：
1. I/O操作时，必须让出 CPU



