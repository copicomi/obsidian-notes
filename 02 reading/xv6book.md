# Chapter 1 操作系统接口

syscall
1. `char *sbrk(int n)` 
	- 按 n 字节增长进程的内存，返回新内存的开始
2. `chdir()` 改变当前的工作目录
3. `mknod` 创建一个设备文件
4. `fstat` 将打开文件 fd 的信息放入 \*st
5. `stat` 将 file 的信息放入 \*st
6. `link` 为文件创建别名
7. `unlink` 删除文件
8. `dup` 为 fd 分配一个新的文件描述符
## 1.1 进程和内存

`exit()` 停止进程，并释放内存和打开的文件
`wait(*)` 检查子进程是否结束，并将其 pid 返回到指定地址

`fork()` 后，两个进程虽然内存的内容一样，其实是两个独立的内存空间，互不影响

`shell` 先读入命令，随后`fork` 执行`exec`，运行命令，父进程 `wait` 后，再读入下一条命令

## 1.2 I/O和文件描述符

文件描述符，实现了 *文件、管道、设备* 的 字节流抽象

`read`、`write`返回成功的字节数
`close` 关闭文件描述符，以便重用，一般重用序号最小的文件描述符

采用文件描述符进行读写操作时，不需要担心从什么地方读取，由此可实现重定向

`shell` 启动后，将 `0` 作为标准控制台输入
重定向时，只需
1. 先 `fork()` 
2. `close(0)` 释放 0 号
3. 随后调用`open()` 打开文件，kernel 会自动分配最小的序号 0
4. `exec` 运行命令，不会替换进程的文件表
这样，默认使用 `0` 读取标准控制台的程序，在这里就通过重新分配 `0`，实现了对给定文件的读取

`fork()`复制了文件表，但是两个进程的文件偏移状态是共享的

通过对 `0、1、2` 描述符的重定向，我们可以实现输入流、输出流、错误流的重定向

## 1.3 管道

管道通过重定向，分解进程树来实现

与临时文件相比：
1. 自动清理
2. 不占用磁盘空间
3. 允许进程树并行执行
4. 阻塞式读写语义，更高效

## 1.4 文件系统

`cd`  是内置在 `shell` 内部的，如果使用 `fork` 执行，则父进程的执行目录不会改变
# Chapter 2 操作系统架构

三个要求：多路复用、隔离、交互

## 2.1 抽象系统资源

> 为什么不把 OS 实现为一个库？缺乏隔离和安全性

把资源抽象成接口，隐藏了细节

## 2.2 用户态、核心态、系统调用

kernel mode 执行 syscall，必要时杀死进程

## 2.3 内核组织

**[[宏内核]]**  [[微内核]] 

xv6概念上属于宏内核

## 2.5 进程概述

xv6 为每个进程提供虚拟机器，单独维护一个页表

虚拟的内存空间顶部，专门留出两页 
1. `trampoline`用于  user 和 kernel mode 切换
2. `trapframe` 用于映射进程切换到 kernel

xv6 用 `proc` 结构体维护进程状态 `kernel/proc.h`

进程由线程来执行指令，切换时挂起线程
线程状态存储在 进程栈上，分为 user stack 和 kernel stack，二者独立，交替执行

进程通过 `ecall` 指令进入 kernel mode 执行 syscall
完成后，通过`sret` 回到 user mode

`p->state` 表示进程状态
`p->pagetable`  表示进程页表



## 2.6 代码（xv6启动）

1. 机器通电，运行 ROM 中的内核加载程序
2. 机器模式下，运行 `kernel/entry.S` 设置栈区，供 .c 代码运行
3. 随后运行  `kernel/start.c` ，进行一些初始配置，修改权限寄存器，配置时钟芯片中断，修改 PC 将 `kernel/main.c` 设为返回地址，切换到内核模式(kernel mode)，随后调用 `mret` 进入到 `main` 执行
4. `main`，先调用`userinit`（`kernel/proc.c`)创建第一个进程 `kernel/initcode.S`
5. 随后 `initcode` 调用 `exec` 重新进入内核， 用`user/init.c`替换内存空间，进入用户模式
6. `init` 创建 3 个文件描述符 `0,1,2`，随后启动 `shell`，系统启动

---

# Chapter 3 页表

## 3.1 分页硬件

xv6 的虚拟地址只使用低 39 位（27 + 12），页大小为 $2^{12} = 4096$ 字节

共有 $2^{27}$ 页，需要建立多级页表

xv6 采用三级页表，根页表包含 $2^9 = 512$ 页表项（PTE）

前 27 位，分别根据 三个 9 位 查找三级页表，给出虚拟地址映射

每个 PTE 的大小是 8 字节，包含物理地址和标志位

如果找不到对应的 PTE，此时让 kernel 来处理异常

每个 CPU 都有自己的 `satp` 寄存器，用于记录根页表的物理地址，并允许运行不同的进程

## 3.2 内核地址空间

xv6 为每个进程维护一个用户空间的页表

硬件设备接口的地址，安排在 `0x80000000` 之前

内核采用直接映射获取内存和设备接口

两个不是直接映射的页面：
1. `trampoline page` 位于虚拟空间顶部，为所有进程共享
2. `guard page` 用于保护内核栈，防止溢出覆盖

## 3.3 代码：创建一个地址空间

`kernel/vm.c`
采用 `pagetable_t` 存储页表
- `walk()` 寻找 PTE
- `mappages()` 装载 PTE 映射
- `kvm` 类函数操作内核页表，`uvm`类函数操作用户页表
- `copy` 类函数，接受虚拟地址，将其转换成物理地址，因此也放在 `vm.c` 中

启动：
1. `main` 调用 `kvminit`，使用`kvmmake` 创建内核页表，此时虚拟地址映射还未启动
2. `kvmmake` 先给根页表 分配 一个物理地址，随后用 `kvmmap` 装载内核的地址转换
3. `Proc_mapstacks`（`kerne/proc.c`）用于为进程分配内核堆栈
4. `kvmmap` 调用 `mappages` 将地址映射装入到页表
5. `mappages` 用 `walk` 查找 PTE 地址，随后初始化 PTE 页表项信息
6. `walk` 分解 虚拟地址，查找 PTE，若设置了 `alloc` 参数则分配新页表项
7. `main`  调用 `kvminithart` 安装内核页表，将根页表写入`satp`，随后启动地址转换功能
8. `main` 调用 `procinit`为每个进程分配内核栈，`kvmmap` 将新的映射写入内核页表


切换进程时，修改`satp` 内容，应当刷新 TLB ，用`sfence.vma`

## 3.4 物理内存分配

xv6 使用链表记录空闲页面

## 3.5 代码（物理内存分配）

`kernel/kalloc.c` 

该代码实现了空闲页面的分配器`allocator`

使用 `struct run` 存储空闲页

1. `main`调用`kinit`，初始化分配器
	1. 调用`freerange`将物理内存中的每一页加入空闲列表
	2. `freerange`对每一页都调用`kfree`
	3. `kfree` 用垃圾信息 `1` 填充页面，将页面插入到列表前面（头插法）
2. `kalloc`  删除并返回列表的第一个元素

xv6 实际上按栈来管理空闲页面

---
## 3.6 进程地址空间

每个用户的虚拟空间顶部，都是 `trampoline`  和 `trapframe` 页，用于与 kernel 交互

用户栈，同样使用`guard page`

---
## 3.7 代码：sbrk

`sbrk` 是一个用于修改进程内存的 syscall ，通过`growproc` 实现，它调用`uvmalloc`或`uvmdealloc`

释放空间时，`walk`查找PTE并调用`kfree`
申请空间时，`kalloc`分配空间，并调用`mappages`写入用户页面映射

---

## 3.8 代码：exec

exec 为指定的 ELF 文件，分配新页表，分配新用户栈，将每个 ELF 段写入到新内存，随后释放旧的程序映像

---
# Chatper 4 陷阱指令和系统调用
## 4.1  RISC-V 陷入机制

硬件 CPU 将更多的自由权交给软件，不保存寄存器内容，而只是根据 **中断向量** 设置 `sapc` 以替代 `pc` 进入中断程序

同时将陷阱原因、当前状态、中断开关是否打开 记录到多个寄存器

---
## 4.2 从用户空间陷入

从用户模式 trap，自然要比 kernel mode 要多一些工作，来保存用户进程独有的一些数据结构

此时先进入 `uservec` 再执行 `usertrap`
返回时则是先 `usertrapret` ，然后是 `userret`

而硬件不会切换页表，因此 **中断向量**`uservec` 与代码 就应当保存在 user 空间的某个地方，这个地方就是 `TRAMPOLINE` 页（就是我们在虚拟空间顶部映射的页，与内核、所有进程兄弟们共享的同一个页）

为了不影响 中断程序 的执行，这段程序应当在 `kernel` 和 `user` 模式下都映射到同一块地址，以执行模式切换

当 `uservec` 开始执行后，我们需要保存全部 32 个 register 的值

为了获取一个至少可用的寄存器，xv6使用 `sscratch` 寄存器和`a0` 的值临时交换，从而征用 `a0` 的使用权

随后将需要保存的值全部放入 `trapframe` 中，使用 `a0` 中间存储 `trapframe` 的地址

`trapframe` 保存着一切从`trap`返回所需要的信息

做好兜底工作后，`uservec` 结束，进入 `usertrap`，同时 `satp` 切换到 `kernel page table`

`usertrap` 只是简单地处理：
1. 将 `sevec` 设置为  `kernelvec`，保证允许内核中断
2. 确定中断类型，处理中断，返回，在此期间保存一下 `sepc` 防止被覆盖即可

返回时先调用 `usertrapret`：
1. 将 `stvec` 回调到 `uservec`
2. 准备好 `trapframe`，重设 `sepc`
3. call `userret`:
	1. 从 `trapframe` 中恢复数据
	2. 将 `satp` 切换回用户页表

---

## 4.3 Code: Calling system calls

---

## 4.4 Code: System call arguments


系统调用的参数，并不通过函数参数传递，而是通过 `trapframe`  中的寄存器读取

---

## 4.5 Traps from kernel space 


---

# Chapter 5 Interrupts and device drivers

驱动程序一般分两部分：
1. 接收 系统调用，传递中断给硬件提醒开始工作
2. 硬件工作完成后，发出完成信号，并返回原程序
## 5.1 Code：控制台输入

UART 硬件直接映射到对应的物理地址

`consoleinit` 配置硬件中断响应

---
## 5.2 Code：控制台输出

console 被设计为 硬件和软件 解耦，硬件负责将输入读入 buffer 缓冲区，而软件从缓存区中 read

即使软件没有read需求，硬件也可以提前读入

这样就允许程序和 IO 设备并发运行

---
## 5.3 驱动中的并发问题

---

## 5.4 时钟中断

timer interrupt 由时钟硬件触发，由于其特殊性，必须在机器模式下也能运行，因此不能将其安排在内核代码中，采用汇编代码实现

xv6采用 RR 调度，在时钟中断后调用 `yield()` 让出 CPU

---


# Chapter 7 调度

## 7.1
多路复用，为每个进程提供虚拟CPU的假象

---
## 7.2

切换进程时，首先陷入到专用调度线程

一个切换过程描述为：
1. 从旧进程陷入到内核
2. 切换到旧进程专用的调度程序
3. 调度完成，决定要执行的新进程
4. trapret到新进程，仿佛是从新进程的 trap 刚刚返回一样
---
> sched() 如何切换到调度器线程？
>通过 switch() 切换上下文，`%ra` 已经改变，再执行`ret`指令的时候，返回到的函数，不是老线程，而是`scheduler()`函数 

---
## 7.4 sleep 与 wakeup

常见的自旋锁浪费了CPU时间
而在一些真实情境中，程序需要等待某些事件的响应，并行的程序必须按照一定的顺序串行执行，因此我们引入 sleep 机制

lost wakeup问题
- 当程序在 `sleep` 之前发生中断，提早执行无效的`wakeup`时，休眠的程序就无法被唤醒，因此必须保证 `sleep` 逻辑是原子的，必须加锁
- 但在持有锁时休眠，`sleep`不会释放它的锁，导致`walkup`获取不到 lock，产生死锁
- 因此 `sleep` 必须给出锁，xv6在此引入第二个参数
- 但是又要保证 `sleep`的原进程不能被访问，因此在 `sleep()` 内部，先获取 `myproc()->lock` 占用进程锁后，再释放锁
- 通过双重锁保护 `sleep` 进程
---
## 7.7 pipe

管道是一个典型的生产-消费者模型，采用 buf 缓存区存字节，lock保护临界区

在 buf 为空时，io遭到阻塞时，执行`sleep-wakeup`策略

由于 pipe 被多个进程共享，因此会出现，某个`read`进程被唤醒，却无数据可读的情况，因此采用`while`循环执行 `sleep`，一旦遇到上述情况，程序会自行重新`sleep`

---

## 7.8

### `exit()`

当进程结束时，我们不能简单地释放所有有关的资源：
1. 可能存在与其他人共享的资源
2. 可能有些资源是代码运行所必须的
3. 该进程对应的内核进程还有工作没完成

这些资源我们选择最后释放

如果该进程是子进程，就`wakeup` 父进程
如果该进程是父进程，就把子进程的相关指针转移给 `init`进程，这样来自子进程的 `wakeup`仍在存在一个合法的对象（尽管它真正的 father 已经不在了）

交代好后事，父进程的资源还不能释放，但已经完成 事实死亡，此时转移到 `ZOMBIE` 状态，其尸体还没有被处理

随后进入 `sched()` 开始调度

至于 `ZOMBIE` 的处理，交给上层进程处理

---

## `wait()`

父进程循环查询进程表，释放其状态为 `ZOMBIE`的子进程

尸体由其管理者处理，而不是自己清理自己，很 reasonable

既然每个进程都由 `wait()`释放，那么必须有一个 **超级父进程**——`init`进程，不断循环执行`wait()`以清理垃圾

因此在`exit()`中我们把子进程的管理权移交给`init()`，父进程自身难保时，就将子进程托付给专业人士处理

一切清理完成后，从`ZOMBIE`转移到`UNUSED`，进程可以被重用

注意父子同时`exit`的情况，必须持有相关锁，实现串行死亡，防止二者都不承担善后责任

---
### `kill()`

由于安全性的问题，我们不可能直接就杀死一个进程（还有活没干完！）

因此，尽管`kill`听起来是一个很冷酷的指令，但是执行起来却很温和——只是把`p->kill`设置为 `1`，告知进程“乖宝宝，该睡觉了”

而实际的释放应该在进程运行过程中，不时检查`kill`是否被标记，然后`exit()`

检查的时机：
1. 没有工作了，可以安全退出
2. 从`sleep`醒来后，看看是不是被`kill()`唤醒的，检查`kill`变量
3. 系统调用的`trap`中，检查`kill`标记

特殊的，你不能`init`进程不能被`kill`，它是进程资源管理的底层逻辑

对于`kill()`，这里显然必须有一些关于使用权限的考虑

---

# Chapter 8 File System

机制：
1. 文件抽象硬件
2. 崩溃恢复
3. 缓存区提高性能
4. 文件数据结构

分层结构：
- 文件描述符
- inode
- inode cache
- logging
- buf cache
- disk

---
