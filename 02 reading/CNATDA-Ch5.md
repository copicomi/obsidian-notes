#reading 
#计算机网络 

# Chapter 5 网络层：控制平面

## 5.1 概述

两种控制方法:
1. 每路由器控制
	 每个路由器在本地部署转发表
2. 逻辑集中式控制
	 由控制器集中计算，通过 *控制代理（[[CA]]）* 与路由器交互，提供 [[SDN]] 服务

## 5.2 路由选择算法

抽象为最短开销路径算法

一种分类：
1. 集中式算法：控制器在拥有全局信息的情况下进行计算
2. 分散式算法：路由器以迭代、分布式的方式进行计算

第二种分类：
1. 静态算法：路由变化缓慢
2. 动态算法：路由响应网络环境的变化而变化

第三种：
1. 负载敏感算法：链路开销会动态变化，以反映拥塞程度
2. 负载迟钝算法

### 5.2.1 [[链路状态]]路由选择算法

该算法需要得知网络拓扑和链路开销，这些信息通过 *链路状态广播* 算法 完成提供

寻路时，采用 *Dijkstra 算法* 或 *Prim 算法*

> - 路由震荡问题
> 由于不同路由器间的路由信息传递存在时延，会产生误判情况，考虑下面的情景
> 多条路由器已经选定同一条路径，导致该路径负载将会大量提升
> 但是数据实际并未发出，负载信息也不会得到更新
> 这会欺骗后来的路由器，认为该路径是畅通的
> 造成错误判断，一瞬间大量数据堆积在该路径

路由震荡的解决方案：时间随机化，使得路由算法运行时刻均匀分散分布

### 5.2.2 [[距离向量]]路由选择算法（DV）

最低开销与 *[[Bellman-Frod 方程]]* 相关：
$$
d_x(y) = {min}_c \{ c(x,v) + d_v(y) \}
$$
该方程实际指出了点到点之间信息通信的方法

---

DV 算法，对于每个节点 x 维护以下信息：
1. `c(x,v)` ：x 到 邻居 v 的开销
2. `Dx[]` ：x 到 网络中 各点 的 最短开销估计，即**距离向量**
3. `{Dv[]}`：x 的每个邻居 v 的距离向量

DV 算法中，每个节点 x 定时告知邻居 v 它的距离向量

如果 v 收到一个新向量，就在根据 *bellman 方程* 本地更新它的有关信息 Dv

当信息交换次数足够多，Dv 就会收敛到实际的最短路径 dv

---
#### 链路开销改变与链路故障

当链路开销减少时，DV 算法运行的很好

当链路开销增大时，情况就不一样了

假设这样一种情况：
> Z 到 X 的最短路径为 Z ---> Y ---> X
> $c(z, y) = 1, c(z, x) = 50$  
> 起初  $c(x, y) = 4$ ，后来把 $c(x, y) = 60$

Y 检测到相邻链路变化，开始广播变化

此时 Dz 应当得到更新（Y ---> X 包含在其最短路径），但却由于分布广播的策略，被延迟更新

那么 Y 在更新其 Dy 时，应用了错误的 Dz

> Dy 用 Y ---> Z ---> Y ---> X 更新了其自身
> 这种情况称为**路由选择环路**

> 这种错误不会一直持续下去，因为链路开销总是正数，Dy 的更新总是单调增加，最终总是会迭代到正确结果

尽管正确性可以得到保证，但是长时间的无效迭代对于性能来说是不可容忍的，这种情况称为 *无穷计数* 问题

---
#### 增加毒性逆转

上述情景可以采用 *毒性逆转（poisoned reverse）* 来避免

如果出现了环路，如上 Y ---> Z ---> Y ----> X
那么 Z 会向 Y 通告，从 Z 不可能抵达 X
尽管与实际情况不符，但这个谎言成功避免 Y 用非法环路进行更新

毒性逆转只适用于两个相邻节点，面对三个及以上的节点环路则没有办法检测

---
#### LS 与 DV 路由选择算法的比较

- LS 的报文复杂性更高
- DV 的收敛速度更慢
- DV 的健壮性更差，一个错误会传递到整个系统内部

---

## 5.3 因特网中自治系统内部的路由选择：[[OSPF]]

>为什么选择 OSPF？
>- 规模过大的网络，路由复杂度过高，需要分块
>- ISP 存在自行管理内网的需求

这种情况通过把路由器组织进 *[[自治系统]]（AS）* 来解决

每个 AS 内部的路由器，信息共享，采用同样的路由选择算法，称为 *[[自治系统内部路由选择协议]]*

---
### 开放最短路优先（OSPF）

OSPF 是一种链路状态协议，使用洪泛链路状态信息和 Dijkstra 最低开销路径算法

每台路由器本地运行 Dijkstra 算法

链路开销 由 网络管理员 手工配置，具备灵活性

路由器定期向 全内网 **广播** 其 路由选择信息，增加算法健壮性

OSPF 的优点：
- 安全
- 允许使用多条相同开销的路径
- 对单播与多播路由选择的综合支持
- 支持在单个 AS 中的层次结构，分层配置路由器
---
## 5.4 ISP 之间的路由选择：[[BGP]]

AS 内部采用 OSPF
AS 系统之间则需要一个 *[[自治系统间路由选择协议]]*

因特网中，为进行通信，所有 AS 必须运行相同的 AS 间路由选择协议，称为 *[[边界网关协议]]（BGP）*

---
### 5.4.1 BGP 的作用

AS 内部，路由器直接寻址即可
而对于 AS 外部，路由器需要通过 BGP 进行连接

BGP 将分组路由到一个 [[CIDR]] 化的前缀，该前缀表示一个子网，或子网的集合

BGP 提供的功能：
1. 从邻居 AS 获取前缀的可达性信息
	- BGP 允许 AS 向整个因特网通告其存在
2. 确定到该前缀“最好的”路由

---
### 5.4.2 通告 BGP 路由信息

每个 AS 中，与外部 AS 相连的路由器称为 *网关路由器*，内部的则为 *内部路由器*

BGP 告知报文，带有寻找前缀 x 的路径信息，并迭代传递向下一个 AS

在实际运行中，并不存在 AS 到 AS 的直接连接，信息都是由路由器进行转发，将这种转发报文称为 *BGP连接*

跨 AS 的 BGP 连接称为 *外部 BGP（eBGP）*
相应的，也有*内部 BGP（iBGP）*

通过 BGP 连接，整个网络中的 每个路由器 都将得知 该 AS 的存在

不过传递的 BGP 报文，可能会包含不同的网络路径

### 5.4.3 确定最好的路由

如何确定选择哪个 BGP 路径呢，并配置转发表呢？

BGP 报文中包含一些 *BGP属性 (attribute)* ，前缀及其属性用 BGP 术语称为 *路由 (route)*

> 两个重要属性
> 1. AS-PATH ：
> 	记录已经通过的 AS 列表，检测并拒绝环路
> 2. NEXT-TOP ：
> 	 AS-PATH 的起始路由器接口的 IP 地址
> 	 用于指示下一跳的 IP
> 3. AS 的 IP 前缀

---
#### 热土豆路由选择（hot potato routing）

路由器更新转发表的工作流程：
1. 根据 AS 间协议，学习到 当前可以到达另一个子网 `x`
2. 根据 AS 内部协议，计算到达本 AS 各网关的最低开销
3. 选择 开销最低的 网关 `q`
4. 确定通往 `q` 的出口端口 `I`，将 `(x, I)` 加入转发表

这种想法，只考虑如何快速把分组传递到 AS 边缘，而不考虑全局的开销，分组被类比为烫手的热土豆

---

#### 路由器选择算法

该算法按以下规则判断：（优先级从高到低）
1. 添加 *本地偏好* 属性值，选择优先级最高的
	- 该属性可从其他路由器学习，也可由管理员手动配置，这是一种策略决定
2. 选择 AS-PATH 最短的
3. 采用热土豆选择
4. 采用 BGP 标识符来选择

一定程度上考虑了全局最优

---
### 5.4.4 IP 任播（anycast）

BGP 常用于实现 IP 任播，该服务通常用于 DNS 中

应用情景：
1. 在分散的不同位置的不同服务器上，替换相同内容
2. 让每个用户从最接近的服务器访问内容

工作过程：
1. 配置阶段：
	- 为多台服务器指派相同的 IP 地址（内容等效）
	- 同时从多个起点进行  BGP 通告
	- 遇到的 BGP 路由器会把 这些物理位置不同的服务器 等效为 同一个 IP 地址，进行路由表的维护
2. 请求阶段：
	- 直接访问路由器上存储的最短路径即可

---
### 5.4.5 路由选择策略

当某个 网络节点 X ，不愿存在通过 X 进行转发的流量（如多宿 ISP）

此时 X 可选择不向其邻居 通告 距离向量，通过人为设定 *BGP 本地偏好属性* 实现

不同的 ISP 之间，不希望来自对方的流量 能够 搭便车，因此都会通过协商来限制流量通过

---
### 5.4.6 拼装在一起：在因特网中呈现

假设你是一个 AS 所有者，想要让所有人都能访问你的 Web 网站

必要步骤：
1. 与本地 ISP 签合同，进行连接
	- 在本地部署一台网关路由器，与  ISP 相连
	- ISP 为你分配一定的 IP 地址
2. 与一个因特网注册机构签合同，申请域名
	- 提供你的 DNS 服务器地址，在 顶级域 DNS 中添加表项
3. 在本地 DNS 服务器中，部署映射表
4. 用 BGP 向 ISP 通告你的 IP 地址，进而通告全因特网的路由器
---
## 5.5 [[SDN]] 控制平面

SDN 体系结构的关键特征：
1. 基于流的转发
	- 检查三个层面的报文首部，并进行转发
	- SDN 负责维护流表项
2. 数据平面与控制平面分离
	- 前者由**交换机和流表**组成
	- 后者则是**服务器和管理流表的软件**组成
3. 网络控制功能
	- 在服务器上，集中计算、监视网络设备，并进行编程和控制
4. 可编程的网络
	- 控制平面可对软件进行编程，使用 SDN 控制器提供的 API 来控制数据平面

SDN 提供了层次的分离：
1. **硬件**：数据平面交换机
2. **系统软件**：SDN 控制器
3. **应用程序**：网络控制的应用程序

这种分离造就了丰富的生态

---
### 5.5.1 SDN 控制平面：SDN 控制器和 SDN 网络控制应用程序

SDN 控制器的功能，组织为 3 个层次：
1. 通信层：SDN 控制器与受控网络设备之间的通信
	- 称为 *南向 API*
	- 底层设备必须向 控制器 报告 本地观察到的事件
2. 网络范围状态管理层
	- 要求获得有关网络的 主机、链路、交换机、其他SDN控制设备 的 最新状态信息
3. 对于网络控制应用程序层的接口
	- 称为 *北向 API*

尽管 SDN 在逻辑上是集中式的，但实际却常采用分布式系统实现

---

### 5.5.2 OpenFlow 协议

OpenFLow 协议 属于 SDN 通信层，运行在 TCP 之上，使用 6653 的默认端口号

从控制器流向受控交换机的 重要报文：
1. 配置：修改参数
2. 修改状态：修改流表项
3. 读状态：收集统计数据和计数器
4. 发送分组：用于发送特定端口的特定报文

从受控交换机流向控制器的重要报文如下：
1. 流删除：通知已删除一个流表项 （ACK）
2. 端口状态：通知状态变化
3. 分组入：将分组发送给 SDN 控制器，进行额外处理

---
### 5.5.3 数据平面和控制平面交互的例子

当 某条链路 发生 故障时，发生下面的过程：
1. **交换机** 使用 OpenFlow 报文，向 **SDN 控制器** 通告故障状态
2. **SDN 控制器** 通告 **链路状态管理器**，更新状态
3. 实现 路由选择算法 的 **网络控制应用程序** 先前已经注册，因此也会得到 状态改变 的通告
4. **路由应用程序** 与 **状态管理器** 相互作用，根据网络环境 计算 新的路由表
5. **应用程序** 向 **流表管理器** 通告 新的最短开销路径，更新流表
6. **流表管理器** 更新后，再使用 OpenFlow 报文，更新 底层的 分组交换机状态

---
### 5.5.4 SDN 的过去与未来


---
## 5.6 [[ICMP]]：因特网控制报文协议

ICMP 用于差错报告

ping 程序就是发送一个 ICMP 的 回显请求报文

---

## * 5.7 网络管理、SNMP 和 NETCONF/YANG

> 网络管理包括了硬件、软件和人类元素的设置、综合和协调，以监视、测试、轮询、配置、分析、评价、和控制网络及网元资源，用合理的成本满足实时性、运营性能和服务质量的要求

### 5.7.1 网络管理框架
- 管理服务器
- 被管设备
- 数据
- 网络管理代理
- 网络管理协议

三种管理方式：
1. [[CLI]]：命令行接口
2. [[SNMP]] / [[MIB]]
3. [[NETCONF]] / [[YANG]]

---
### 5.7.2 简单网络管理协议和管理信息库

[[SNMP]] 是一个应用层协议，常使用请求响应模式进行服务，使用陷阱报文通知异常

MIB 对象 采用 [[SMI]] 进行描述

---

### 5.7.3 NETCONF 和 YANG

NETCONF 协议 在 管理服务器和被管理网络设备之间运行
提供报文用于：
- 在被管设备上检索、设置和修改配置数据
- 查询被管设备的运行数据和统计
- 订阅由被管设备产生的通知

YANG 是一种数据建模语言，用于 NETCONF 数据 的精确定义