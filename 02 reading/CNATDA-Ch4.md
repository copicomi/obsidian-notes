#reading 
#计算机网络 

# Chapter 4 网络层：数据平面
## 4.1 网络层概述
### Intro
**数据平面**：从输入链路向输出链路转发数据报
**控制平面**：协调转发操作，实现端到端传送

对路由器来说，不存在网络层之上的抽象层

### 4.1.1 转发和路由选择：数据平面和控制平面

- 转发：时间短，几纳秒，硬件
- 路由：时间长，几秒，软件

由转发表来索引
- 传统方法：人工配置路由表
- [[SDN]]方法：软件定义网络

### 4.1.2 网络服务模型

网络层考虑的服务：
1. 确保交付
2. 时延保证
3. 有序
4. 最小带宽保证
5. 安全性

因特网的网络层提供单一的服务，称为尽力而为服务（best-effort service)

只确保交付，其余均不保证



## 4.2 [[路由器]]工作原理

四个组件：
1. 输入端口
2. 交换结构
3. 输出端口
4. 路由选择处理器

### 4.2.1 输入端口处理和基于目的地转发

路由处理选择器计算路由表，将路由表复制到线路卡
每个输入端口，使用线路卡的影子副本，在本地做出转发决策，避免了集中式处理

转发表可对 目的地址 采用 *最长前缀匹配规则* 映射输出端口

该过程是一个“匹配加操作”抽象

### 4.2.2 交换

处理过程：
1. 线路端接
2. 数据链路处理（协议，拆封）
3. 查找，转发，排队
4. 发往交换结构

三种交换技术：
1. 内存交换
	- 早期计算机实现
	- 受容量大小限制
2. 总线交换
	- 适用于小规模局域网
	- 同一时刻只能传输一个分组
3. 互联网络交换
	- 2N 纵横布线
	- 同一时刻最多 N 个并行交换
	- 非阻塞

### 4.2.3 输出端口处理

过程：
1. 从交换结构接取
2. 排队（缓存管理）
3. 数据链路处理（协议、封装）
4. 线路端接

### 4.2.4 何时出现排队

排队取决于：
1. 流量负载
2. 交换结构的相对速率
3. 线路速率

#### 输入排队

原因：传送时延固定存在

**队列首部阻塞**（[[HOL阻塞]]，Head-Of-the-Line）


#### 输出排队

原因：多个分组要求同一个输出端口，处理时延固定存在

缓存已满时：
1. 要么丢弃新分组
2. 要么丢弃正在排队的旧分组

为避免丢包，我们可以主动释放队列空间，为发送方提供一个拥塞信号，实现拥塞控制

这样的策略称为**主动队列管理**（AQM)，典型为**随机早期检测算法**(RED)

排队时，由输出端口的 **分组调度器** 来决定传输哪个分组

#### 多少缓存才“够用”？

经验公式:
$$
B = RTT \times C 
$$

其中 B 为缓存数量，[[RTT]] 为平均往返时延，C 为链路容量

存在 N 条并行 TCP 流时，经验公式为：
$$
 B = RTT \cdot C / \sqrt{N}
$$
缓存是一把双刃剑：
- 大缓存会增强吞吐能力，但也增加了潜在的排队时延

当发送方持续发送流量时，用户感受到的时延 受到 **最小时延** 限制，这种情况称为 **缓存膨胀**

### 4.2.5 分组调度

#### 先进先出 FIFO

#### 优先权排队

#### 循环和加权公平排队

轮转和比例份额调度



## 4.3 网际协议：IPv4、寻址、IPv6及其他

### 4.3.1 [[IPv4]] 数据报格式
1. 版本号
2. 首部长度
3. 服务类型
4. 数据报总长度
5. 标识、标志、片偏移
6. 寿命 TTL
7. 协议
8. 首部检验和
9. 源和目的 IP 地址
10. 选项

### 4.3.2 IPv4 编址

每个 IP 地址与一个[[接口]]相关联

前缀若干位表示子网掩码

子网中的 IP 地址，前缀都相同

因特网分配策略称为 *无类别域间路由选择（CIDR）*
CIDR 出现前，通常规定前缀只能是 8、16、24 位，分为 A、B、C 类网络，这种策略称为 *分类编址* 

路由器在寻路时，只需考虑对应的子网前缀

子网内部 也可根据 前缀 进行 再分块

而 IP 地址中 除 子网前缀 之外的 bit，由子网管理分配

下面描述，地址是如何被分配的

####  **获取子网地址**

**子网**负责人 向其 **ISP** 管理员 联系，请求分配一块**连续的** IP 地址
而 ISP 占有的 IP 地址，由 *[[ICANN]]* 组织进行分配管理
####  **获取主机地址**：*动态主机配置协议（[[DHCP]]）*

DHCP 允许主机从连接的子网中自动获取一个地址，**或临时或固定**，同时让主机得知必要的子网环境信息

这种自动化的方式，省去了手工配置的工作，更符合有大量主机频繁加入和退出的网络环境

每个子网都应具有一台 DHCP服务器，或 [[DHCP 中继代理]]

DHCP 采用 client-server 模型

DHCP 的工作过程：
1.  DHCP 服务器发现
	 - 起初，主机 C 并不知道自己所处的网络环境，必须通过广播手段，发送 *DHCP 发现报文（discover msg）*，使用 *广播目的地址 255.255.255.255，主机源地址 0.0.0.0*
2.  DHCP 服务器提供
	 - 当 DHCP 服务器 S 收到 discover msg 时，同样开始广播 *DHCP 提供报文（offer msg）*
	 - offer msg 包含向 主机 C 提供的 地址、掩码、**IP地址租用期** 
3.  DHCP 请求
	 - 主机 C 可能收到多个 offer msg，此时择优发送 *DHCP 请求报文 （request msg）*
	 - request msg 包含回显参数
4.  DHCP ACK
	- 服务器 S 响应 ACK msg
	- 当 主机 C 收到 ACK msg，服务结束

### 4.3.3 网络地址转换

当一个 *[[SOHO]]* 安装子网时，起初会向 IXP 申请一块固定地址，若想后续再扩大网络规模，之前的固定地址就会阻碍

这种场合可以应用 *网络地址转换（[[NAT]]）* 方法管理 IP 地址

在网络内部，我们应用 *[[专用网络]]* 技术 来为主机提供本地的特有 IP（如 10.0.0.0/24）

不同的 SOHO 的主机 可以 都使用 10.0.0.0/24 作为其 IP 地址，因为此类地址 只在本地网络中 才具有意义

这些主机通过 **NAT 路由器**  和因特网连接

NAT 路由器将所有主机 映射为同一个具体 IP 地址，以此 IP 为代表，与因特网通信

>： NAT 的 IP 地址由谁分配？
>NAT 从 DHCP 处得到这样的 IP 地址

>： NAT 收到信息，怎么知道是发给哪台主机的？
>通过 *NAT 转换表*，实现 host 与 NAT 二者端口号的映射
>NAT 根据 NAT 表，向 host 转发信息

> NAT 同样存在反对者
> 1. 一般来说，端口号只能用于进程寻址，NAT 将其用于主机寻址的行为 破坏了这一原则
> 2. 认为 NAT 路由器位于网络层，将其用于转发信息，破坏了主机间之间进行 **端到端通信** 的抽象原则


### 4.3.4 [[IPV6]]

IPV6 的变化：
1. 扩大的地址容量
2. 首部舍弃了许多字段，更加简化高效
3. 流标签，用于标记特殊服务需求的数据流

字段：
1. 版本
2. 流量类型
3. 流标签
4. 有效载荷长度
5. 下一个首部（传输层相关）
6. 跳限制
7. 源地址和目的地址
8. 数据

删去的字段：
1. 分片/重新组装
2. 首部校验和
3. 选项

>如何升级到 IPv6？
>- 宣布标志日，当天全部设备升级（不可行）
>- 建隧道
>	将 IPv6 报文封装到 IPv4 报文中，利用现存的 IPv4 设备作为隧道进行传输，而 IPv4 设备本身并不知道
>网络层升级的落实相当困难

## 4.4 [[泛化转发]]和 [[SDN]]

对数据转发的操作，进行更一般的抽象，抽象为*[[匹配加操作]]* 范式

匹配加操作转发表 在 [[OpenFlow]] 中称为 *流表（flow table）* 
该表项包括：
1. 首部字段值的集合
	- 用于匹配
2. 计数器集合
	- 记录匹配的分组数量、上次更新以来的时间
3. 匹配成功后的操作集合
	- 用于操作

流表完成了对 转发行为 的抽象，要想添加一个新的转发类型，只需要在 table 中 添加新项即可，而业务实现的具体逻辑只需要少量的软件编程即可完成

### 4.4.1 匹配

OpenFlow 的匹配抽象，允许对来自三个层次（链路、网络、传输）的协议首部进行匹配

虽然违背了分层规则，但 OpenFlow 也因此获得了等效于多层设备的能力

flow table 可以安排匹配优先级

为了减少复杂度，OpenFlow 仅仅选择少量字段进行匹配

### 4.4.2 操作

转发、丢弃、修改字段

### 4.4.3 运行中的匹配加操作的 OpenFlow 例子

#### 简单转发

匹配：抓取要转发的报文
操作：发往规定路径的下一个输出端口

#### 负载均衡

#### 充当防火墙

---

可以看到 flow table 在抽象上的 巨大作用
实现了操作的**可编程性**，甚至可以加入一些高级语言的特性

---

## 4.5 [[中间盒]]

三种服务：
1. NAT 转换
2. 安全服务：防火墙
3. 性能增强：缓存

尽管破坏了分层原则，但中间盒的存在是必要的