# Lecture 1A
## Part1

三个主题：
1. 黑盒抽象
2. 接口
3. 元编程
---
## Part2

计算机语言的三个问题：
1. 基本元素是什么？**symbol，number...**
2. 如何把元素组合在一起？**combanition**
3. 如何实现抽象的方法，把功能封装成盒子？**define**

`Lambda` 用于临时描述一个过程，本身是一个 combanition

`+` 和 `lambda` 并无本质区别，只是前者早被系统封装

完成封装后，一个`define`被视作黑盒，相当于一个symbol

条件表达式，为递归提供边界

---

## Part3

LIPS 不需要显式的循环（？）

Block structure : Box in the box

> `define A (5*5)` 与 `define (D) (5*5)` 的区别？
> 	二者都是 symbol
> 	前者是一个数值，后者是一个无参数的过程`lambda`

---

# Lecture 1B
## Part1

> 构建复杂系统的关键：忽略不必要的细节

LIPS 执行的简易理解：代换模型

---
## Part2

递归过程与迭代过程

微小扰动也会影响性能

---
## Part3

指数型递归

---

# Lecture 2A

## Part 1

高阶过程

过程本身也可以作为形参

求和概念的抽象DEFINE

---
## Part 2

求不定点、平均阻尼

用含有具体语言的 DEFINE 来定义过程
并重新把小型过程，应用到复杂系统
这样会提升代码的可读性

同时，在 DEFINE 这种过程时，使用匿名$\lambda$ 会很方便

--- 

## Part 3

按愿望编程，也就是自顶向下设计你的程序，起初不关心细节

> 要想达成一切的抽象，必须把函数作为第一级元素
> 可命名、可作参数、可作返回值、可构成数据结构

---
# Lecture 2B

## Part 1

wishable thinking

有理数的封装

利用编程语言，创造系统未定义的，却存在于人脑中的概念

忽略数据的内在细节，绑定原子

让程序更符合人脑的逻辑思维

---
## Part 2

在被迫做出决定前，不要做任何决定，这能保持系统的弹性

先假设已经实现了，顶层设计完成后，再去讨论底层实现哪个更好

把数据的表示和应用分隔开，这就是数据抽象的idea

---

## Part 3

数据抽象的闭包性质

一个pair的组成，可以是另外两个嵌套的 pair

segment用一对vector组成，vector由一对有理数组成，有理数由一对整数组成

这种嵌套的多层抽象，增强了对系统的掌控能力

---

## Part 4

LIPS中，Pair 的实际实现，是一个*过程*

该过程是一个条件表达式，被define为一个对象

当访问pair的成员时，我们只是调用了这个过程（带有正确参数）而已

模糊数据和过程的界限

过程也是一种对象

事实上一切数据都可以被描述为一个过程

---

# Lecture 3A

## Part 1

List 是对多个嵌套 Pair 的封装

MAP 是一个高阶方法，对 List 的每个元素做相同操作，返回一个新表

---

## Part 2

过程和数据之间并无本质区别

封闭类型，有助于控制复杂度


---

## Part 3

分解的观点：按任务分解，还是按方法论分解

后者更加健壮，也更抽象

真正的设计过程，不是在设计程序，而是在设计语言

---

看到这里理解了，为什么要起初强调语言设计的基本元素

尽管不需要设计一门编程语言，但是在解决问题的过程中，我们不仅可以针对具体问题设计程序，而且可以设计一门语言来描述此类问题

这门语言是逻辑自洽的，是嵌入在现有的高级语言中的

不需要设计递归等高级特性，因为它已被嵌入编程语言，在设计完成的那一刻，功能就被 LIPS 所扩展了

只需要设计：
1. 基本元素
2. 元素的组合方式
3. 整体抽象的封装

---

# Lecture 3B

## Part 1

引用，避免歧义

过程和过程是可以比较的

---
## Part 2

> 引用阻止了表达式被求值，使得其语义变为“该表达式本身”
> 从这层视角来看，我们拥有了讨论和操作表达式本身的能力
> 这样的话，可以在语言层之上建立更加强大的抽象
> 我们可以在原有语言之上，描述其他语言，只需要用 LISP 解释该语言即可
> 这是一种惊人的力量

---

# Lecture 4A

## Part 1

模式匹配

与其把我们设计的语言解释成程序，再让计算机执行
不如编写一个解释器，让计算机理解我们的语言

---

## Part 2

解释器和骨架、匹配与实例化

---
## Part 3

学会“不考虑”，学会放弃

分析复杂过程时，该隐藏的细节，就要隐藏

---

# Lecture 4B

## Part 1、2、3

通用运算符

数字计算系统的构造

实现多项式运算时，归约为系数运算，重用了通用计算符 ADD

而系数又可以是多项式，我们的系统自动地扩展出复杂运算的功能

看似是无限递归的

> ：下层的数据类型，用到了上层的运算符，不会导致混乱么？
> 这是一个递归的计算过程，并不混乱
> *我想是由于，代数系统，她本身的基本元素，就是递归定义的，要想实现这种强大的效果，就不得不使用这种递归式的通用计算*

数据导向编程的思想（Data directed programming)

---

# Lecture 5A

## Part 1

引入赋值语句

之前写的函数，都是静态的数学函数

赋值则造成时间上的依赖，函数不再是静态的

宣告了代换规则的死亡

引入赋值，让我们的计算模型完全失效了

---

## Part 2

环境模型：框架的集合

约束变量和自由变量

前者代换，后者传递指针

不同的过程，可以具有不同的 frame，也可以具有相对独立的运行变量

---

## Part 3

为什么我们需要引入赋值？

在一个过程中，假设一个值 X 被改变了三次

那么我们可以调用外部的过程来给 X 赋值，只返回结果，把细节隐藏在外

但如果没有赋值，只有函数的话

我们将不得不引入三个约束变量 X1、X2、X3
因为同一个符号 X 显然只能对应一个值

此时有关变量个数的细节，就被暴露在过程中

甚至，改变值的外部过程，也不得不暴露在过程中

那么我们不就失去了过程的一般性和抽象性了吗

这种 specific 是不能容忍的

---

# Lecture 5B

## Part 1

数字电路模拟器

将现实世界中的对象与联系，映射到计算机中

---

## Part 2

模拟现实世界中的时间

建立有关时间的优先队列

List + queue 实现 Agenda

---

## Part 3

丘奇的 cons 实现，把cons定义为一个带有两个形参的过程

这样就可以对不同的 cons 生成不同的 frame，进而区分对象，进而使得对特定个体的赋值可以实现

---

# Lecture 6A

## Part 1

流处理

考虑赋值操作，考虑时序的话，我们设计程序的方式是否过于机械化

程序设计是现实世界的抽象映射

如果说我们对现实世界的认知有偏差呢？

如果现实并不是离散的，存在一种连续的视角来看待事物呢？

那种情况下，我们就不需要特意关注信息的传递，与系统内部的细节

---

## Part 2

流处理，提供了约定的统一接口

不再关注时序上的状态，而是把处理的对象看作一个集合

Map、Fliter、Accumulate

---

## Part 3

Delay与Force

> ：为什么说 stream 和 list 是两种东西？
> 前者惰性地计算其成员，利用 Delay 和 Force
> 只在需要的时候，才抓取对象
> stream，实现了 *事件发生的逻辑顺序* 和 *机器运行的实际顺序* 之间的解耦

我们放弃了让程序完全忠于现实的想法，为什么程序一定要按我们思考的顺序执行呢？

模糊程序的时序性，使得在设计时，既有流处理的逻辑，又具有传统设计的性能

逻辑是有时序的，但计算不一定要忠于时序

delay 的结果可以记忆化

---

# Lecture 6B

## Part 1、2、3

流、赋值

对应

延迟求值、对象与内部状态

二者冲突

当你选择 Delay 一个计算过程时，相应地也 Delay 了一个对象的内部状态

但现实中的对象，按直觉来说，是具备时间性的
你怎么可能 Delay 一个对象呢？

从这种角度，流处理，舍弃了一切和时间、时序有关的概念

如果给定的命令，与命令的顺序，都是固定的，那么 delay 就有其正确性
因为结果只和上下文相关

但如果同时有两个流作出请求，比如说两个人共用一个银行账户
用函数式编程就不得不考虑真实时间的因素，因为这是一个交互性程序，在用户的世界里，时间是真实存在的

函数式编程是反对时间概念的，此时又不得不引入时间

这两种设计理念，代表不同的看待世界的方法

分不出哪个更好，都有缺陷

重申我们设计模型的理念：我们想找到这样一个计算模型，
能够恰当符合我们对真实世界的看法

大一统的方法论至今仍未找到

函数式模型，避不开时间
对象式模型，避不开并发

---


## Lecture 7A

## Part 1、2、3

解释器

EVAL 与 APPLY 互相调用

不动点

用 lisp 语言写一个 lisp 解释器

Y 算子

递归的定义，在数学上是可行的

define 的存在方便递归自定义，但其实我们不需要 define

程序是对过程的抽象，解释器是对程序的抽象

把过程看作是方程，一个递归的过程，其实就是一个不定点，只不过它是一个极限