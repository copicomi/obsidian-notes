# 4.3 VMware FT 工作原理

让我来介绍一下 VMware FT 是如何工作的。

首先，VMware 是一个虚拟机公司，它们的业务主要是售卖虚拟机技术。虚拟机的意思是，你买一台计算机，通常只能在硬件上启动一个操作系统。但是如果在硬件上运行一个虚拟机监控器（VMM，Virtual Machine Monitor）或者 Hypervisor，Hypervisor 会在同一个硬件上模拟出多个虚拟的计算机。所以通过 VMM，可以在一个硬件上启动一到多个 Linux 虚机，一到多个 Windows 虚机。

![](<../assets/image (262).png>)

这台计算机上的 VMM 可以运行一系列不同的操作系统，其中每一个都有自己的操作系统内核和应用程序。

![](<../assets/image (265).png>)

这是 VMware 发家的技术，这里的硬件和操作系统之间的抽象，可以有很多很多的好处。首先是，我们只需要购买一台计算机，就可以在上面运行大量不同的操作系统，我们可以在每个操作系统里面运行一个小的服务，而不是购买大量的物理计算机，每个物理计算机只运行一个服务。所以，这是 VMware 的发家技术，并且它有大量围绕这个技术构建的复杂系统。

VMware FT 需要两个物理服务器。将 Primary 和 Backup 运行在一台服务器的两个虚拟机里面毫无意义，因为容错本来就是为了能够抵御硬件故障。所以，你至少需要两个物理服务器运行 VMM，Primary 虚机在其中一个物理服务器上，Backup 在另一个物理服务器上。在其中一个物理服务器上，我们有一个虚拟机，这个物理服务器或许运行了很多虚拟机，但是我们只关心其中一个。这个虚拟机跑了某个操作系统，和一种服务器应用程序，或许是个数据库，或许是 MapReduce master 或者其他的，我们将之指定为 Primary。在第二个物理服务器上，运行了相同的 VMM，和一个相同的虚拟机作为 Backup。它与 Primary 有着一样的操作系统。

![](<../assets/image (266).png>)

两个物理服务器上的 VMM 会为每个虚拟机分配一段内存，这两段内存的镜像需要完全一致，或者说我们的目标就是让 Primary 和 Backup 的内存镜像完全一致。所以现在，我们有两个物理服务器，它们每一个都运行了一个虚拟机，每个虚拟机里面都有我们关心的服务的一个拷贝。我们假设有一个网络连接了这两个物理服务器。

![](<../assets/image (267).png>)

除此之外，在这个局域网（LAN，Local Area Network），还有一些客户端。实际上，它们不必是客户端，可以只是一些我们的多副本服务需要与之交互的其他计算机。其中一些客户端向我们的服务发送请求。在 VMware FT 里，多副本服务没有使用本地盘，而是使用了一些 Disk Server（远程盘）。尽管从论文里很难发现，这里可以将远程盘服务器也看做是一个外部收发数据包的源，与客户端的区别不大。

![](<../assets/image (268).png>)

所以，基本的工作流程是，我们假设这两个副本，或者说这两个虚拟机：Primary 和 Backup，互为副本。某些我们服务的客户端，向 Primary 发送了一个请求，这个请求以网络数据包的形式发出。

![](<../assets/image (269).png>)

这个网络数据包产生一个中断，之后这个中断送到了 VMM。VMM 可以发现这是一个发给我们的多副本服务的一个输入，所以这里 VMM 会做两件事情：

- 在虚拟机的 guest 操作系统中，模拟网络数据包到达的中断，以将相应的数据送给应用程序的 Primary 副本。
- 除此之外，因为这是一个多副本虚拟机的输入，VMM 会将网络数据包拷贝一份，并通过网络送给 Backup 虚机所在的 VMM。

![](<../assets/image (270).png>)

Backup 虚机所在的 VMM 知道这是发送给 Backup 虚机的网络数据包，它也会在 Backup 虚机中模拟网络数据包到达的中断，以将数据发送给应用程序的 Backup。所以现在，Primary 和 Backup 都有了这个网络数据包，它们有了相同的输入，再加上许多细节，它们将会以相同的方式处理这个输入，并保持同步。

当然，虚机内的服务会回复客户端的请求。在 Primary 虚机里面，服务会生成一个回复报文，并通过 VMM 在虚机内模拟的虚拟网卡发出。之后 VMM 可以看到这个报文，它会实际的将这个报文发送给客户端。

![说实话，这里画的挺乱的](<../assets/image (271).png>)

另一方面，由于 Backup 虚机运行了相同顺序的指令，它也会生成一个回复报文给客户端，并将这个报文通过它的 VMM 模拟出来的虚拟网卡发出。但是它的 VMM 知道这是 Backup 虚机，会丢弃这里的回复报文。所以这里，Primary 和 Backup 都看见了相同的输入，但是只有 Primary 虚机实际生成了回复报文给客户端。

![](<../assets/image (272).png>)

这里有一个术语，VMware FT 论文中将 Primary 到 Backup 之间同步的数据流的通道称之为 Log Channel。虽然都运行在一个网络上，但是这些从 Primary 发往 Backup 的事件被称为 Log Channel 上的 Log Event/Entry。

![](<../assets/image (273).png>)

当 Primary 因为故障停止运行时，FT（Fault-Tolerance）就开始工作了。从 Backup 的角度来说，它将不再收到来自于 Log Channel 上的 Log 条目。实际中，Backup 每秒可以收到很多条 Log，其中一个来源就是来自于 Primary 的定时器中断。每个 Primary 的定时器中断都会生成一条 Log 条目并发送给 Backup，这些定时器中断每秒大概会有 100 次。所以，如果 Primary 虚机还在运行，Backup 必然可以期望从 Log Channel 收到很多消息。如果 Primary 虚机停止运行了，那么 Backup 的 VMM 就会说：天，我都有 1 秒没有从 Log Channel 收到任何消息了，Primary 一定是挂了或者出什么问题了。当 Backup 不再从 Primary 收到消息，VMware FT 论文的描述是，Backup 虚机会上线（Go Alive）。这意味着，Backup 不会再等待来自于 Primary 的 Log Channel 的事件，Backup 的 VMM 会让 Backup 自由执行，而不是受来自于 Primary 的事件驱动。Backup 的 VMM 会在网络中做一些处理（猜测是发 GARP），让后续的客户端请求发往 Backup 虚机，而不是 Primary 虚机。同时，Backup 的 VMM 不再会丢弃 Backup 虚机的输出。当然，它现在已经不再是 Backup，而是 Primary。所以现在，左边的虚机直接接收输入，直接产生输出。到此为止，Backup 虚机接管了服务。

类似的一个场景，虽然没那么有趣，但是也需要能正确工作。如果 Backup 虚机停止运行，Primary 也需要用一个类似的流程来抛弃 Backup，停止向它发送事件，并且表现的就像是一个单点的服务，而不是一个多副本服务一样。所以，只要有一个因为故障停止运行，并且不再产生网络流量时，Primary 和 Backup 中的另一个都可以上线继续工作。

> 学生提问：Backup 怎么让其他客户端向自己发送请求？
>
> Robert 教授：魔法。。。取决于是哪种网络技术。从论文中看，一种可能是，所有这些都运行在以太网上。每个以太网的物理计算机，或者说网卡有一个 48bit 的唯一 ID（MAC 地址）。下面这些都是我（Robert 教授）编的。每个虚拟机也有一个唯一的 MAC 地址，当 Backup 虚机接手时，它会宣称它有 Primary 的 MAC 地址，并向外通告说，我是那个 MAC 地址的主人。这样，以太网上的其他人就会向它发送网络数据包。不过这只是我（Robert 教授）的解读。
>
> 学生提问：随机数生成器这种操作怎么在 Primary 和 Backup 做同步？
>
> Robert 教授：VMware FT 的设计者认为他们找到了所有类似的操作，对于每一个操作，Primary 执行随机数生成，或者某个时间点生成的中断（依赖于执行时间点的中断）。而 Backup 虚机不会执行这些操作，Backup 的 VMM 会探测这些指令，拦截并且不执行它们。VMM 会让 Backup 虚机等待来自 Log Channel 的有关这些指令的指示，比如随机数生成器这样的指令，之后 VMM 会将 Primary 生成的随机数发送给 Backup。
>
> 论文有暗示说他们让 Intel 向处理器加了一些特性来支持这里的操作，但是论文没有具体说是什么特性。
