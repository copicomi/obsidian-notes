# 4.2 状态转移和复制状态机（State Transfer and Replicated State Machine）

在 VMware FT 论文的开始，介绍了两种复制的方法，一种是状态转移（State Transfer），另一种是复制状态机（Replicated State Machine）。这两种我们都会介绍，但是在这门课程中，我们主要还是介绍后者。

![](<../assets/image (260).png>)

如果我们有一个服务器的两个副本，我们需要让它们保持同步，在实际上互为副本，这样一旦 Primary 出现故障，因为 Backup 有所有的信息，就可以接管服务。状态转移背后的思想是，Primary 将自己完整状态，比如说内存中的内容，拷贝并发送给 Backup。Backup 会保存收到的最近一次状态，所以 Backup 会有所有的数据。当 Primary 故障了，Backup 就可以从它所保存的最新状态开始运行。所以，状态转移就是发送 Primary 的状态。虽然 VMware FT 没有采用这种复制的方法，但是假设采用了的话，那么转移的状态就是 Primary 内存里面的内容。这种情况下，每过一会，Primary 就会对自身的内存做一大份拷贝，并通过网络将其发送到 Backup。为了提升效率，你可以想到每次同步只发送上次同步之后变更了的内存。

复制状态机基于这个事实：我们想复制的大部分的服务或者计算机软件都有一些确定的内部操作，不确定的部分是外部的输入。通常情况下，如果一台计算机没有外部影响，它只是一个接一个的执行指令，每条指令执行的是计算机中内存和寄存器上确定的函数，只有当外部事件干预时，才会发生一些预期外的事。例如，某个随机时间收到了一个网络数据包，导致服务器做一些不同的事情。所以，复制状态机不会在不同的副本之间发送状态，相应的，它只会从 Primary 将这些外部事件，例如外部的输入，发送给 Backup。通常来说，如果有两台计算机，如果它们从相同的状态开始，并且它们以相同的顺序，在相同的时间，看到了相同的输入，那么它们会一直互为副本，并且一直保持一致。

所以，状态转移传输的是可能是内存，而复制状态机会将来自客户端的操作或者其他外部事件，从 Primary 传输到 Backup。

![](<../assets/image (261).png>)

人们倾向于使用复制状态机的原因是，通常来说，外部操作或者事件比服务的状态要小。如果是一个数据库的话，它的状态可能是整个数据库，可能到达 GB 这个级别，而操作只是一些客户端发起的请求，例如读 key27 的数据。所以操作通常来说比较小，而状态通常比较大。所以复制状态机通常来说更吸引人一些。复制状态机的缺点是，它会更复杂一些，并且对于计算机的运行做了更多的假设。而状态转移就比较简单粗暴，我就是将我整个状态发送给你，你不需要再考虑别的东西。

有关这些方法有什么问题吗？

> 学生提问：如果这里的方法出现了问题，导致 Primary 和 Backup 并不完全一样，会有什么问题？
>
> Robert 教授：假设我们对 GFS 的 Master 节点做了多副本，其中的 Primary 对 Chunk 服务器 1 分发了一个租约。但是因为我们这里可能会出现多副本不一致，所以 Backup 并没有向任何人发出租约，它甚至都不知道任何人请求了租约，现在 Primary 认为 Chunk 服务器 1 对于某些 Chunk 有租约，而 Backup 不这么认为。当 Primary 挂了，Backup 接手，Chunk 服务器 1 会认为它对某些 Chunk 有租约，而当前的 Primary（也就是之前的 Backup）却不这么认为。当前的 Primary 会将租约分发给其他的 Chunk 服务器。现在我们就有两个 Chunk 服务器有着相同的租约。这只是一个非常现实的例子，基于不同的副本不一致，你可以构造出任何坏的场景和任何服务器运算出错误结果的情形。我之后会介绍 VMware 的方案是如何避免这一点的。
>
> 学生提问：随机操作在复制状态机会怎么处理？
>
> Robert 教授：我待会会再说这个问题，但是这是个好问题。只有当没有外部的事件时，Primary 和 Backup 都执行相同的指令，得到相同的结果，复制状态机才有意义。对于 ADD 这样的指令来说，这是正确的。如果寄存器和内存都是相同的，那么两个副本执行一条 ADD 指令，这条指令有相同的输入，也必然会有相同的输出。但是，如你指出的一样，有一些指令，或许是获取当前的时间，因为执行时间的略微不同，会产生不同的结果。又或者是获取当前 CPU 的唯一 ID 和序列号，也会产生不同的结果。对于这一类问题的统一答案是，Primary 会执行这些指令，并将结果发送给 Backup。Backup 不会执行这些指令，而是在应该执行指令的地方，等着 Primary 告诉它，正确的答案是什么，并将监听到的答案返回给软件。

有趣的是，或许你已经注意到了，VMware FT 论文讨论的都是复制状态机，并且只涉及了单核 CPU，目前还不确定论文中的方案如何扩展到多核处理器的机器中。在多核的机器中，两个核交互处理指令的行为是不确定的，所以就算 Primary 和 Backup 执行相同的指令，在多核的机器中，它们也不一定产生相同的结果。VMware 在之后推出了一个新的可能完全不同的复制系统，并且可以在多核上工作。这个新系统从我看来使用了状态转移，而不是复制状态机。因为面对多核和并行计算，状态转移更加健壮。如果你使用了一台机器，并且将其内存发送过来了，那么那个内存镜像就是机器的状态，并且不受并行计算的影响，但是复制状态机确实会受并行计算的影响。但是另一方面，我认为这种新的多核方案代价会更高一些。

如果我们要构建一个复制状态机的方案，我们有很多问题要回答，我们需要决定要在什么级别上复制状态，我们对状态的定义是什么，我们还需要担心 Primary 和 Backup 之间同步的频率。因为很有可能 Primary 会比 Backup 的指令执行更超前一些，毕竟是 Primary 接收了外部的输入，Backup 几乎必然是要滞后的。这意味着，有可能 Primary 出现了故障，而 Backup 没有完全同步上。但是，让 Backup 与 Primary 完全同步执行又是代价很高的操作，因为这需要大量的交互。所以，很多设计中，都关注同步的频率有多高。

如果 Primary 发生了故障，必须要有一些切换的方案，并且客户端必须要知道，现在不能与服务器 1 上的旧 Primary 通信，而应该与服务器 2 上的新 Primary 通信。所有的客户端都必须以某种方式完成这里的切换。几乎不可能设计一个不出现异常现象的切换系统。在理想的环境中，如果 Primary 故障了，系统会切换到 Backup，同时没有人，没有一个客户端会注意到这里的切换。这在实际上基本不可能实现。所以，在切换过程中，必然会有异常，我们必须找到一种应对它们的方法。

如果我们的众多副本中有一个故障了，我们需要重新添加一个新的副本。如果我们只有两个副本，其中一个故障了，那我们的服务就命悬一线了，因为第二个副本随时也可能故障。所以我们绝对需要尽快将一个新的副本上线。但是这可能是一个代价很高的行为，因为副本的状态会非常大。我们喜欢复制状态机的原因是，我们认为状态转移的代价太高了。但是对于复制状态机来说，其中的两个副本仍然需要有完整的状态，我们只是有一种成本更低的方式来保持它们的同步。如果我们要创建一个新的副本，我们别无选择，只能使用状态转移，因为新的副本需要有完整状态的拷贝。所以创建一个新的副本，代价会很高。

以上就是人们主要担心的问题。我们在讨论其他复制状态机方案时，会再次看到这些问题。

让我们回到什么样的状态需要被复制这个话题。VMware FT 论文对这个问题有一个非常有趣的回答。它会复制机器的完整状态，这包括了所有的内存，所有的寄存器。这是一个非常非常详细的复制方案，Primary 和 Backup，即使在最底层也是完全一样的。对于复制方案来说，这种类型是非常少见的。总的来说，大部分复制方案都跟 GFS 更像。GFS 也有复制，但是它绝对没有在 Primary 和 Backup 之间复制内存中的每一个 bit，它复制的更多是应用程序级别的 Chunk。应用程序将数据抽象成 Chunk 和 Chunk ID，GFS 只是复制了这些，而没有复制任何其他的东西，所以也不会有复制其他东西的代价。对于应用程序来说，只要 Chunk 的副本的数据是一致的就可以了。基本上除了 VMware FT 和一些屈指可数的类似的系统，其他所有的复制方案都是采用的类似 GFS 的方案。也就是说基本上所有的方案使用的都是应用程序级别的状态复制，因为这更加高效，并且我们也不必陷入这样的困境，比如说需要确保中断在 Primary 和 Backup 的相同位置执行，GFS 就完全不需要担心这种情况。但是 VMware FT 就需要担心这种情况，因为它从最底层就开始复制。所以，大多数人构建了高效的，应用程序级别的复制系统。这样做的后果是，复制这个行为，必须构建在应用程序内部。如果你收到了一系列应用程序级别的操作，你确实需要应用程序参与到复制中来，因为一些通用的复制系统，例如 VMware FT，理解不了这些操作，以及需要复制的内容。总的来说，大部分场景都是应用程序级别的复制，就像 GFS 和其他这门课程中会学习的其他论文一样。

VMware FT 的独特之处在于，它从机器级别实现复制，因此它不关心你在机器上运行什么样的软件，它就是复制底层的寄存器和内存。你可以在 VMware FT 管理的机器上运行任何软件，只要你的软件可以运行在 VMware FT 支持的微处理器上。这里说的软件可以是任何软件。所以，它的缺点是，它没有那么的高效，优点是，你可以将任何现有的软件，甚至你不需要有这些软件的源代码，你也不需要理解这些软件是如何运行的，在某些限制条件下，你就可以将这些软件运行在 VMware FT 的这套复制方案上。VMware FT 就是那个可以让任何软件都具备容错性的魔法棒。
