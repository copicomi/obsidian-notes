# 9.6 链复制的故障恢复（Fail Recover）

在 Chain Replication 中，出现故障后，你可以看到的状态是相对有限的。因为写请求的传播模式非常有规律，我们不会陷入到类似于 Raft 论文中图 7 和图 8 描述的那种令人毛骨悚然的复杂场景中。并且在出现故障之后，也不会出现不同的副本之间各种各样不同步的场景。

在 Chain Replication 中，因为写请求总是依次在链中处理，写请求要么可以达到 TAIL 并 commit，要么只到达了链中的某一个服务器，之后这个服务器出现故障，在链中排在这个服务器后面的所有其他服务器不再能看到写请求。所以，只可能有两种情况：committed 的写请求会被所有服务器看到；而如果一个写请求没有 commit，那就意味着在导致系统出现故障之前，写请求已经执行到链中的某个服务器，所有在链里面这个服务器之前的服务器都看到了写请求，所有在这个服务器之后的服务器都没看到写请求。

总的来看，Chain Replication 的故障恢复也相对的更简单。

如果 HEAD 出现故障，作为最接近的服务器，下一个节点可以接手成为新的 HEAD，并不需要做任何其他的操作。对于还在处理中的请求，可以分为两种情况：

- 对于任何已经发送到了第二个节点的写请求，不会因为 HEAD 故障而停止转发，它会持续转发直到 commit。
- 如果写请求发送到 HEAD，在 HEAD 转发这个写请求之前 HEAD 就故障了，那么这个写请求必然没有 commit，也必然没有人知道这个写请求，我们也必然没有向发送这个写请求的客户端确认这个请求，因为写请求必然没能送到 TAIL。所以，对于只送到了 HEAD，并且在 HEAD 将其转发前 HEAD 就故障了的写请求，我们不必做任何事情。或许客户端会重发这个写请求，但是这并不是我们需要担心的问题。

如果 TAIL 出现故障，处理流程也非常相似，TAIL 的前一个节点可以接手成为新的 TAIL。所有 TAIL 知道的信息，TAIL 的前一个节点必然都知道，因为 TAIL 的所有信息都是其前一个节点告知的。

中间节点出现故障会稍微复杂一点，但是基本上来说，需要做的就是将故障节点从链中移除。或许有一些写请求被故障节点接收了，但是还没有被故障节点之后的节点接收，所以，当我们将其从链中移除时，故障节点的前一个节点或许需要重发最近的一些写请求给它的新后继节点。这是恢复中间节点流程的简单版本。

Chain Replication 与 Raft 进行对比，有以下差别：

- 从性能上看，对于 Raft，如果我们有一个 Leader 和一些 Follower。Leader 需要直接将数据发送给所有的 Follower。所以，当客户端发送了一个写请求给 Leader，Leader 需要自己将这个请求发送给所有的 Follower。然而在 Chain Replication 中，HEAD 只需要将写请求发送到一个其他节点。数据在网络中发送的代价较高，所以 Raft Leader 的负担会比 Chain Replication 中 HEAD 的负担更高。当客户端请求变多时，Raft Leader 会到达一个瓶颈，而不能在单位时间内处理更多的请求。而同等条件以下，Chain Replication 的 HEAD 可以在单位时间处理更多的请求，瓶颈会来的更晚一些。
- 另一个与 Raft 相比的有趣的差别是，Raft 中读请求同样也需要在 Raft Leader 中处理，所以 Raft Leader 可以看到所有的请求。而在 Chain Replication 中，每一个节点都可以看到写请求，但是只有 TAIL 可以看到读请求。所以负载在一定程度上，在 HEAD 和 TAIL 之间分担了，而不是集中在单个 Leader 节点。
- 前面分析的故障恢复，Chain Replication 也比 Raft 更加简单。这也是使用 Chain Replication 的一个主要动力。

> 学生提问：如果一个写请求还在传递的过程中，还没有到达 TAIL，TAIL 就故障了，会发生什么？
>
> Robert 教授：如果这个时候 TAIL 故障了，TAIL 的前一个节点最终会看到这个写请求，但是 TAIL 并没有看到。因为 TAIL 的故障，TAIL 的前一个节点会成为新的 TAIL，这个写请求实际上会完成 commit，因为写请求到达了新的 TAIL。所以新的 TAIL 可以回复给客户端，但是它极有可能不会回复，因为当它收到写请求时，它可能还不是 TAIL。这样的话，客户端或许会重发写请求，但是这就太糟糕了，因为同一个写请求会在系统中处理两遍，所以我们需要能够在 HEAD 抑制重复请求。不过基本上我们讨论的所有系统都需要能够抑制重复的请求。
>
> 学生提问：假设第二个节点不能与 HEAD 进行通信，第二个节点能不能直接接管成为新的 HEAD，并通知客户端将请求发给自己，而不是之前的 HEAD？
>
> Robert 教授：这是个非常好的问题。你认为呢？
>
> 你的方案听起来比较可行。假设 HEAD 和第二个节点之间的网络出问题了，

![](<../assets/image (308).png>)

> HEAD 还在正常运行，同时 HEAD 认为第二个节点挂了。然而第二个节点实际上还活着，它认为 HEAD 挂了。所以现在他们都会认为，另一个服务器挂了，我应该接管服务并处理写请求。因为从 HEAD 看来，其他服务器都失联了，HEAD 会认为自己现在是唯一的副本，那么它接下来既会是 HEAD，又会是 TAIL。第二个节点会有类似的判断，会认为自己是新的 HEAD。所以现在有了脑裂的两组数据，最终，这两组数据会变得完全不一样。

（下一节继续分析怎么解决这里的问题）
