# 9.5 链复制（Chain Replication）

这一部分，我们来讨论另一个论文 CRAQ（Chain Replication with Apportioned Queries）。我们选择 CRAQ 论文有两个原因：第一个是它通过复制实现了容错；第二是它通过以链复制 API 请求这种有趣的方式，提供了与 Raft 相比不一样的属性。

CRAQ 是对于一个叫链式复制（Chain Replication）的旧方案的改进。Chain Replication 实际上用的还挺多的，有许多现实世界的系统使用了它，CRAQ 是对它的改进。CRAQ 采用的方式与 Zookeeper 非常相似，它通过将读请求分发到任意副本去执行，来提升读请求的吞吐量，所以副本的数量与读请求性能成正比。CRAQ 有意思的地方在于，它在任意副本上执行读请求的前提下，还可以保证线性一致性（Linearizability）。这与 Zookeeper 不太一样，Zookeeper 为了能够从任意副本执行读请求，不得不牺牲数据的实时性，因此也就不是线性一致的。CRAQ 却可以从任意副本执行读请求，同时也保留线性一致性，这一点非常有趣。

![](<../assets/image (299).png>)

首先，我想讨论旧的 Chain Replication 系统。Chain Replication 是这样一种方案，你有多个副本，你想确保它们都看到相同顺序的写请求（这样副本的状态才能保持一致），这与 Raft 的思想是一致的，但是它却采用了与 Raft 不同的拓扑结构。

首先，在 Chain Replication 中，有一些服务器按照链排列。第一个服务器称为 HEAD，最后一个被称为 TAIL。

![](<../assets/image (300).png>)

当客户端想要发送一个写请求，写请求总是发送给 HEAD。

![](<../assets/image (301).png>)

HEAD 根据写请求更新本地数据，我们假设现在是一个支持 PUT/GET 的 key-value 数据库。所有的服务器本地数据都从 A 开始。

![](<../assets/image (302).png>)

当 HEAD 收到了写请求，将本地数据更新成了 B，之后会再将写请求通过链向下一个服务器传递。

![](<../assets/image (303).png>)

下一个服务器执行完写请求之后，再将写请求向下一个服务器传递，以此类推，所有的服务器都可以看到写请求。

![](<../assets/image (304).png>)

当写请求到达 TAIL 时，TAIL 将回复发送给客户端，表明写请求已经完成了。这是处理写请求的过程。

![](<../assets/image (305).png>)

对于读请求，如果一个客户端想要读数据，它将读请求发往 TAIL，

![](<../assets/image (306).png>)

TAIL 直接根据自己的当前状态来回复读请求。所以，如果当前状态是 B，那么 TAIL 直接返回 B。读请求处理的非常的简单。

![](<../assets/image (307).png>)

这里只是 Chain Replication，并不是 CRAQ。Chain Replication 本身是线性一致的，在没有故障时，从一致性的角度来说，整个系统就像只有 TAIL 一台服务器一样，TAIL 可以看到所有的写请求，也可以看到所有的读请求，它一次只处理一个请求，读请求可以看到最新写入的数据。如果没有出现故障的话，一致性是这么得到保证的，非常的简单。

从一个全局角度来看，除非写请求到达了 TAIL，否则一个写请求是不会 commit，也不会向客户端回复确认，也不能将数据通过读请求暴露出来。而为了让写请求到达 TAIL，它需要经过并被链上的每一个服务器处理。所以我们知道，一旦我们 commit 一个写请求，一旦向客户端回复确认，一旦将写请求的数据通过读请求暴露出来，那意味着链上的每一个服务器都知道了这个写请求。
