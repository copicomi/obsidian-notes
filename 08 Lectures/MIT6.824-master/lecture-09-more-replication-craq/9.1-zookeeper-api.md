# 9.1 Zookeeper API

Zookeeper 里面我最感兴趣的事情是它的 API 设计。Zookeeper 的 API 设计使得它可以成为一个通用的服务，从而分担一个分布式系统所需要的大量工作。那么为什么 Zookeeper 的 API 是一个好的设计？具体来看，因为它实现了一个值得去了解的概念：mini-transaction。

![](<../assets/image (286).png>)

我们回忆一下 Zookeeper 的特点：

- Zookeeper 基于（类似于）Raft 框架，所以我们可以认为它是，当然它的确是容错的，它在发生网络分区的时候，也能有正确的行为。
- 当我们在分析各种 Zookeeper 的应用时，我们也需要记住 Zookeeper 有一些性能增强，使得读请求可以在任何副本被处理，因此，可能会返回旧数据。
- 另一方面，Zookeeper 可以确保一次只处理一个写请求，并且所有的副本都能看到一致的写请求顺序。这样，所有副本的状态才能保证是一致的（写请求会改变状态，一致的写请求顺序可以保证状态一致）。
- 由一个客户端发出的所有读写请求会按照客户端发出的顺序执行。
- 一个特定客户端的连续请求，后来的请求总是能看到相比较于前一个请求相同或者更晚的状态（详见 8.5 FIFO 客户端序列）。

在我深入探讨 Zookeeper 的 API 长什么样和为什么它是有用的之前，我们可以考虑一下，Zookeeper 的目标是解决什么问题，或者期望用来解决什么问题？

- 对于我来说，使用 Zookeeper 的一个主要原因是，它可以是一个 VMware FT 所需要的 Test-and-Set 服务（详见 4.7）的实现。Test-and-Set 服务在发生主备切换时是必须存在的，但是在 VMware FT 论文中对它的描述却又像个谜一样，论文里没有介绍：这个服务究竟是什么，它是容错的吗，它能容忍网络分区吗？Zookeeper 实际的为我们提供工具来写一个容错的，完全满足 VMware FT 要求的 Test-and-Set 服务，并且可以在网络分区时，仍然有正确的行为。这是 Zookeeper 的核心功能之一。
- 使用 Zookeeper 还可以做很多其他有用的事情。其中一件是，人们可以用它来发布其他服务器使用的配置信息。例如，向某些 Worker 节点发布当前 Master 的 IP 地址。
- 另一个 Zookeeper 的经典应用是选举 Master。当一个旧的 Master 节点故障时，哪怕说出现了网络分区，我们需要让所有的节点都认可同一个新的 Master 节点。
- 如果新选举的 Master 需要将其状态保持到最新，比如说 GFS 的 Master 需要存储对于一个特定的 Chunk 的 Primary 节点在哪，现在 GFS 的 Master 节点可以将其存储在 Zookeeper 中，并且知道 Zookeeper 不会丢失这个信息。当旧的 Master 崩溃了，一个新的 Master 被选出来替代旧的 Master，这个新的 Master 可以直接从 Zookeeper 中读出旧 Master 的状态。
- 其他还有，对于一个类似于 MapReduce 的系统，Worker 节点可以通过在 Zookeeper 中创建小文件来注册自己。
- 同样还是类似于 MapReduce 这样的系统，你可以设想 Master 节点通过向 Zookeeper 写入具体的工作，之后 Worker 节点从 Zookeeper 中一个一个的取出工作，执行，完成之后再删除工作。

以上就是 Zookeeper 可以用来完成的工作。

![](<../assets/image (287).png>)

> 学生提问：Zookeeper 应该如何应用在这些场景中？
>
> Robert 教授：通常来说，如果你有一个大的数据中心，并且在数据中心内运行各种东西，比如说 Web 服务器，存储系统，MapReduce 等等。你或许会想要再运行一个包含了 5 个或者 7 个副本的 Zookeeper 集群，因为它可以用在很多场景下。之后，你可以部署各种各样的服务，并且在设计中，让这些服务存储一些关键的状态到你的全局的 Zookeeper 集群中。

Zookeeper 的 API 某种程度上来说像是一个文件系统。它有一个层级化的目录结构，有一个根目录（root），之后每个应用程序有自己的子目录。比如说应用程序 1 将自己的文件保存在 APP1 目录下，应用程序 2 将自己的文件保存在 APP2 目录下，这些目录又可以包含文件和其他的目录。

![](<../assets/image (289).png>)

这么设计的一个原因刚刚也说过，Zookeeper 被设计成要被许多可能完全不相关的服务共享使用。所以我们需要一个命名系统来区分不同服务的信息，这样这些信息才不会弄混。对于每个使用 Zookeeper 的服务，围绕着文件，有很多很方便的方法来使用 Zookeeper。我们在接下来几个小节会看几个例子。

所以，Zookeeper 的 API 看起来像是一个文件系统，但是又不是一个实际的文件系统，比如说你不能 mount 一个文件，你不能运行 ls 和 cat 这样的命令等等。这里只是在内部，以这种路径名的形式命名各种对象。假设应用程序 2 下面有 X，Y，Z 这些文件。当你通过 RPC 向 Zookeeper 请求数据时，你可以直接指定/APP2/X。这就是一种层级化的命名方式。

![](<../assets/image (290).png>)

这里的文件和目录都被称为 znodes。Zookeeper 中包含了 3 种类型的 znode，了解他们对于解决问题会有帮助。

1. 第一种 Regular znodes。这种 znode 一旦创建，就永久存在，除非你删除了它。
2. 第二种是 Ephemeral znodes。如果 Zookeeper 认为创建它的客户端挂了，它会删除这种类型的 znodes。这种类型的 znodes 与客户端会话绑定在一起，所以客户端需要时不时的发送心跳给 Zookeeper，告诉 Zookeeper 自己还活着，这样 Zookeeper 才不会删除客户端对应的 ephemeral znodes。
3. 最后一种类型是 Sequential znodes。它的意思是，当你想要以特定的名字创建一个文件，Zookeeper 实际上创建的文件名是你指定的文件名再加上一个数字。当有多个客户端同时创建 Sequential 文件时，Zookeeper 会确保这里的数字不重合，同时也会确保这里的数字总是递增的。

这些在后面的例子中都会有介绍。

![](<../assets/image (291).png>)

Zookeeper 以 RPC 的方式暴露以下 API。

- `CREATE(PATH，DATA，FLAG)`。入参分别是文件的全路径名 PATH，数据 DATA，和表明 znode 类型的 FLAG。这里有意思的是，CREATE 的语义是排他的。也就是说，如果我向 Zookeeper 请求创建一个文件，如果我得到了 yes 的返回，那么说明这个文件之前不存在，我是第一个创建这个文件的客户端；如果我得到了 no 或者一个错误的返回，那么说明这个文件之前已经存在了。所以，客户端知道文件的创建是排他的。在后面有关锁的例子中，我们会看到，如果有多个客户端同时创建同一个文件，实际成功创建文件（获得了锁）的那个客户端是可以通过 CREATE 的返回知道的。
- `DELETE(PATH，VERSION)`。入参分别是文件的全路径名 PATH，和版本号 VERSION。有一件事情我之前没有提到，每一个 znode 都有一个表示当前版本号的 version，当 znode 有更新时，version 也会随之增加。对于 delete 和一些其他的 update 操作，你可以增加一个 version 参数，表明当且仅当 znode 的当前版本号与传入的 version 相同，才执行操作。当存在多个客户端同时要做相同的操作时，这里的参数 version 会非常有帮助（并发操作不会被覆盖）。所以，对于 delete，你可以传入一个 version 表明，只有当 znode 版本匹配时才删除。
- `EXIST(PATH，WATCH)`。入参分别是文件的全路径名 PATH，和一个有趣的额外参数 WATCH。通过指定 watch，你可以监听对应文件的变化。不论文件是否存在，你都可以设置 watch 为 true，这样 Zookeeper 可以确保如果文件有任何变更，例如创建，删除，修改，都会通知到客户端。此外，判断文件是否存在和 watch 文件的变化，在 Zookeeper 内是原子操作。所以，当调用 exist 并传入 watch 为 true 时，不可能在 Zookeeper 实际判断文件是否存在，和建立 watch 通道之间，插入任何的创建文件的操作，这对于正确性来说非常重要。
- `GETDATA(PATH，WATCH)`。入参分别是文件的全路径名 PATH，和 WATCH 标志位。这里的 watch 监听的是文件的内容的变化。
- `SETDATA(PATH，DATA，VERSION)`。入参分别是文件的全路径名 PATH，数据 DATA，和版本号 VERSION。如果你传入了 version，那么 Zookeeper 当且仅当文件的版本号与传入的 version 一致时，才会更新文件。
- `LIST(PATH)`。入参是目录的路径名，返回的是路径下的所有文件。
