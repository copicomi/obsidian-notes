# 7.5 日志快照（Log Snapshot）

Log 压缩和快照（Log compaction and snapshots）在 Lab3b 中出现的较多。在 Raft 中，Log 压缩和快照解决的问题是：对于一个长期运行的系统，例如运行了几周，几个月甚至几年，如果我们按照 Raft 论文图 2 的规则，那么 Log 会持续增长。最后可能会有数百万条 Log，从而需要大量的内存来存储。如果持久化存储在磁盘上，最终会消耗磁盘的大量空间。如果一个服务器重启了，它需要通过重新从头开始执行这数百万条 Log 来重建自己的状态。当故障重启之后，遍历并执行整个 Log 的内容可能要花费几个小时来完成。这在某种程度上来说是浪费，因为在重启之前，服务器已经有了一定的应用程序状态。

为了应对这种场景，Raft 有了快照（Snapshots）的概念。快照背后的思想是，要求应用程序将其状态的拷贝作为一种特殊的 Log 条目存储下来。我们之前几乎都忽略了应用程序，但是事实是，假设我们基于 Raft 构建一个 key-value 数据库，Log 将会包含一系列的 Put/Get 或者 Read/Write 请求。假设一条 Log 包含了一个 Put 请求，客户端想要将 X 设置成 1，另一条 Log 想要将 X 设置成 2，下一条将 Y 设置成 7。

![](<../assets/image (73).png>)

如果 Raft 一直执行没有故障，Raft 之上的将会是应用程序，在这里，应用程序将会是 key-value 数据库。它将会维护一个表单，当 Raft 一个接一个的上传命令时，应用程序会更新它的表单。

![](<../assets/image (74).png>)

所以第一个命令之后，应用程序会将表单中的 X 设置为 1。

![](<../assets/image (75).png>)

第二个命令之后，表单中的 X 会被设置为 2。

![](<../assets/image (76).png>)

第三个命令之后，表单中的 Y 会被设置为 7。

![](<../assets/image (77).png>)

这里有个有趣的事实，那就是：对于大多数的应用程序来说，应用程序的状态远小于 Log 的大小。某种程度上我们知道，在某些时间点，Log 和应用程序的状态是可以互换的，它们是用来表示应用程序状态的不同事物。但是 Log 可能包含大量的重复的记录（例如对于 X 的重复赋值），这些记录使用了 Log 中的大量的空间，但是同时却压缩到了 key-value 表单中的一条记录。这在多副本系统中很常见。在这里，如果存储 Log，可能尺寸会非常大，相应的，如果存储 key-value 表单，这可能比 Log 尺寸小得多。这就是快照的背后原理。

所以，当 Raft 认为它的 Log 将会过于庞大，例如大于 1MB，10MB 或者任意的限制，Raft 会要求应用程序在 Log 的特定位置，对其状态做一个快照。所以，如果 Raft 要求应用程序做一个快照，Raft 会从 Log 中选取一个与快照对应的点，然后要求应用程序在那个点的位置做一个快照。这里极其重要，因为我们接下来将会丢弃所有那个点之前的 Log 记录。如果我们有一个点的快照，那么我们可以安全的将那个点之前的 Log 丢弃。（在 key-value 数据库的例子中）快照本质上就是 key-value 表单。

![](<../assets/image (78).png>)

我们还需要为快照标注 Log 的槽位号。在这个图里面，这个快照对应的正好是槽位 3。

![](<../assets/image (79).png>)

有了快照，并且 Raft 将它存放在磁盘中之后，Raft 将不会再需要这部分 Log。只要 Raft 持久化存储了快照，快照对应的 Log 槽位号，以及 Log 槽位号之后的所有 Log，那么快照对应槽位号之前的这部分 Log 可以被丢弃，我们将不再需要这部分 Log。

![](<../assets/image (80).png>)

所以这就是 Raft 快照的工作原理，Raft 要求应用程序做快照，得到快照之后将其存储在磁盘中，同时持久化存储快照之后的 Log，并丢弃快照之前的 Log。所以，Raft 的持久化存储实际上是持久化应用程序快照，和快照之后的 Log。大家都明白了吗？

> 学生提问：听不清。
>
> Robert 教授：或许可以这样看这些 Log，快照之后的 Log 是实际存在的，而快照之前的 Log 可以认为是幽灵条目，我们可以认为它们还在那，只是说我们永远不会再去查看它们了， 因为我们现在有快照了。事实上，我们不再存储幽灵条目，但是效果上是等效于有完整的 Log。

![](<../assets/image (81).png>)

刚刚的回答可能有些草率。因为如果按照 Raft 论文的图 2，你有时还是需要这些早期的 Log（槽位 1，2，3）。所以，在知道了有时候某些 Log 可能不存在的事实之后，你可能需要稍微重新理解一下图 2。

所以，重启的时候会发生什么呢？现在，重启的场景比之前只有 Log 会更加复杂一点。重启的时候，必须让 Raft 有方法知道磁盘中最近的快照和 Log 的组合，并将快照传递给应用程序。因为现在我们不能重演所有的 Log（部分被删掉了），所以必须要有一种方式来初始化应用程序。所以应用程序不仅需要有能力能生成一个快照，它还需要能够吸纳一个之前创建的快照，并通过它稳定的重建自己的内存。所以，尽管 Raft 在管理快照，快照的内容实际上是应用程序的属性。Raft 并不理解快照中有什么，只有应用程序知道，因为快照里面都是应用程序相关的信息。所以重启之后，应用程序需要能够吸纳 Raft 能找到的最近的一次快照。到目前为止还算简单。

不幸的是，这里丢弃了快照之前的 Log，引入了大量的复杂性。如果有的 Follower 的 Log 较短，在 Leader 的快照之前就结束，那么除非有一种新的机制，否则那个 Follower 永远也不可能恢复完整的 Log。因为，如果一个 Follower 只有前两个槽位的 Log，Leader 不再有槽位 3 的 Log 可以通过 AppendEntries RPC 发给 Follower，Follower 的 Log 也就不可能补齐至 Leader 的 Log。

![](<../assets/image (82).png>)

我们可以通过这种方式来避免这个问题：如果 Leader 发现有任何一个 Follower 的 Log 落后于 Leader 要做快照的点，那么 Leader 就不丢弃快照之前的 Log。Leader 原则上是可以知道 Follower 的 Log 位置，然后 Leader 可以不丢弃所有 Follower 中最短 Log 之后的本地 Log。

这或许是一个短暂的好方法，之所以这个方法不完美的原因在于，如果一个 Follower 关机了一周，它也就不能确认 Log 条目，同时也意味着 Leader 不能通过快照来减少自己的内存消耗（因为那个 Follower 的 Log 长度一直没有更新）。

所以，Raft 选择的方法是，Leader 可以丢弃 Follower 需要的 Log。所以，我们需要某种机制让 AppendEntries 能处理某些 Follower Log 的结尾到 Leader Log 开始之间丢失的这一段 Log。解决方法是（一个新的消息类型）InstallSnapshot RPC。

![](<../assets/image (83).png>)

当 Follower 刚刚恢复，如果它的 Log 短于 Leader 通过 AppendEntries RPC 发给它的内容，那么它首先会强制 Leader 回退自己的 Log。在某个点，Leader 将不能再回退，因为它已经到了自己 Log 的起点。这时，Leader 会将自己的快照发给 Follower，之后立即通过 AppendEntries 将后面的 Log 发给 Follower。

![](<../assets/image (84).png>)

不幸的是，这里明显的增加了的复杂度。因为这里需要 Raft 组件之间的协同，这里还有点违反模块性，因为这里需要组件之间有一些特殊的协商。例如，当 Follower 收到了 InstallSnapshot，这个消息是被 Raft 收到的，但是 Raft 实际需要应用程序能吸纳这个快照。所以它们现在需要更多的交互了。

> 学生提问：快照的创建是否依赖应用程序？
>
> Robert 教授：肯定依赖。快照生成函数是应用程序的一部分，如果是一个 key-value 数据库，那么快照生成就是这个数据库的一部分。Raft 会通过某种方式调用到应用程序，通知应用程序生成快照，因为只有应用程序自己才知道自己的状态（进而能生成快照）。而通过快照反向生成应用程序状态的函数，同样也是依赖应用程序的。但是这里又有点纠缠不清，因为每个快照又必须与某个 Log 槽位号对应。
>
> 学生提问：如果 RPC 消息乱序该怎么处理？
>
> Robert 教授：是在说 Raft 论文图 13 的规则 6 吗？这里的问题是，你们会在 Lab3 遇到这个问题，因为 RPC 系统不是完全的可靠和有序，RPC 可以乱序的到达，甚至不到达。你或许发了一个 RPC，但是收不到回复，并认为这个消息丢失了，但是消息实际上送达了，实际上是回复丢失了。所有这些都可能发生，包括发生在 InstallSnapshot RPC 中。Leader 几乎肯定会并发发出大量 RPC，其中包含了 AppendEntries 和 InstallSnapshot，因此，Follower 有可能受到一条很久以前的 InstallSnapshot 消息。因此，Follower 必须要小心应对 InstallSnapshot 消息。我认为，你想知道的是，如果 Follower 收到了一条 InstallSnapshot 消息，但是这条消息看起来完全是冗余的，这条 InstallSnapshot 消息包含的信息比当前 Follower 的信息还要老，这时，Follower 该如何做？
>
> Raft 论文图 13 的规则 6 有相应的说明。我认为正常的响应是，Follower 可以忽略明显旧的快照。其实我（Robert 教授）看不懂那条规则 6。
