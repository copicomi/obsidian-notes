# 7.3 快速恢复（Fast Backup）

在前面（7.1）介绍的日志恢复机制中，如果 Log 有冲突，Leader 每次会回退一条 Log 条目。 这在许多场景下都没有问题。但是在某些现实的场景中，至少在 Lab2 的测试用例中，每次只回退一条 Log 条目会花费很长很长的时间。所以，现实的场景中，可能一个 Follower 关机了很长时间，错过了大量的 AppendEntries 消息。这时，Leader 重启了。按照 Raft 论文中的图 2，如果一个 Leader 重启了，它会将所有 Follower 的 nextIndex 设置为 Leader 本地 Log 记录的下一个槽位（7.1 有说明）。所以，如果一个 Follower 关机并错过了 1000 条 Log 条目，Leader 重启之后，需要每次通过一条 RPC 来回退一条 Log 条目来遍历 1000 条 Follower 错过的 Log 记录。这种情况在现实中并非不可能发生。在一些不正常的场景中，假设我们有 5 个服务器，有 1 个 Leader，这个 Leader 和另一个 Follower 困在一个网络分区。但是这个 Leader 并不知道它已经不再是 Leader 了。它还是会向它唯一的 Follower 发送 AppendEntries，因为这里没有过半服务器，所以没有一条 Log 会 commit。在另一个有多数服务器的网络分区中，系统选出了新的 Leader 并继续运行。旧的 Leader 和它的 Follower 可能会记录无限多的旧的任期的未 commit 的 Log。当旧的 Leader 和它的 Follower 重新加入到集群中时，这些 Log 需要被删除并覆盖。可能在现实中，这不是那么容易发生，但是你会在 Lab2 的测试用例中发现这个场景。

所以，为了能够更快的恢复日志，Raft 论文在论文的 5.3 结尾处，对一种方法有一些模糊的描述。原文有些晦涩，在这里我会以一种更好的方式尝试解释论文中有关快速恢复的方法。这里的大致思想是，让 Follower 返回足够的信息给 Leader，这样 Leader 可以以任期（Term）为单位来回退，而不用每次只回退一条 Log 条目。所以现在，在恢复 Follower 的 Log 时，如果 Leader 和 Follower 的 Log 不匹配，Leader 只需要对每个不同的任期发送一条 AppendEntries，而不用对每个不同的 Log 条目发送一条 AppendEntries。这只是一种加速策略，当然，或许你也可以想出许多其他不同的日志恢复加速策略。

我将可能出现的场景分成 3 类，为了简化，这里只画出一个 Leader（S2）和一个 Follower（S1），S2 将要发送一条任期号为 6 的 AppendEntries 消息给 Follower。

- 场景 1：S1 没有任期 6 的任何 Log，因此我们需要回退一整个任期的 Log。

![](<../assets/image (62).png>)

- 场景 2：S1 收到了任期 4 的旧 Leader 的多条 Log，但是作为新 Leader，S2 只收到了一条任期 4 的 Log。所以这里，我们需要覆盖 S1 中有关旧 Leader 的一些 Log。

![](<../assets/image (64).png>)

- 场景 3：S1 与 S2 的 Log 不冲突，但是 S1 缺失了部分 S2 中的 Log。

![](<../assets/image (65).png>)

可以让 Follower 在回复 Leader 的 AppendEntries 消息中，携带 3 个额外的信息，来加速日志的恢复。这里的回复是指，Follower 因为 Log 信息不匹配，拒绝了 Leader 的 AppendEntries 之后的回复。这里的三个信息是指：

- XTerm：这个是 Follower 中与 Leader 冲突的 Log 对应的任期号。在之前（7.1）有介绍 Leader 会在 prevLogTerm 中带上本地 Log 记录中，前一条 Log 的任期号。如果 Follower 在对应位置的任期号不匹配，它会拒绝 Leader 的 AppendEntries 消息，并将自己的任期号放在 XTerm 中。如果 Follower 在对应位置没有 Log，那么这里会返回 -1。
- XIndex：这个是 Follower 中，对应任期号为 XTerm 的第一条 Log 条目的槽位号。
- XLen：如果 Follower 在对应位置没有 Log，那么 XTerm 会返回-1，XLen 表示空白的 Log 槽位数。

![](<../assets/image (67).png>)

我们再来看这些信息是如何在上面 3 个场景中，帮助 Leader 快速回退到适当的 Log 条目位置。

- 场景 1。Follower（S1）会返回 XTerm=5，XIndex=2。Leader（S2）发现自己没有任期 5 的日志，它会将自己本地记录的，S1 的 nextIndex 设置到 XIndex，也就是 S1 中，任期 5 的第一条 Log 对应的槽位号。所以，如果 Leader 完全没有 XTerm 的任何 Log，那么它应该回退到 XIndex 对应的位置（这样，Leader 发出的下一条 AppendEntries 就可以一次覆盖 S1 中所有 XTerm 对应的 Log）。
- 场景 2。Follower（S1）会返回 XTerm=4，XIndex=1。Leader（S2）发现自己其实有任期 4 的日志，它会将自己本地记录的 S1 的 nextIndex 设置到本地在 XTerm 位置的 Log 条目后面，也就是槽位 2。下一次 Leader 发出下一条 AppendEntries 时，就可以一次覆盖 S1 中槽位 2 和槽位 3 对应的 Log。
- 场景 3。Follower（S1）会返回 XTerm=-1，XLen=2。这表示 S1 中日志太短了，以至于在冲突的位置没有 Log 条目，Leader 应该回退到 Follower 最后一条 Log 条目的下一条，也就是槽位 2，并从这开始发送 AppendEntries 消息。槽位 2 可以从 XLen 中的数值计算得到。

这些信息在 Lab 中会有用，如果你错过了我的描述，你可以再看看视频（Robert 教授说的）。

对于这里的快速回退机制有什么问题吗？

> 学生提问：这里是线性查找，可以使用类似二分查找的方法进一步加速吗？
>
> Robert 教授：我认为这是对的，或许这里可以用二分查找法。我没有排除其他方法的可能，我的意思是，Raft 论文中并没有详细说明是怎么做的，所以我这里加工了一下。或许有更好，更快的方式来完成。如果 Follower 返回了更多的信息，那是可以用一些更高级的方法，例如二分查找，来完成。
>
> 为了通过 Lab2 的测试，你肯定需要做一些优化工作。我们提供的 Lab2 的测试用例中，有一件不幸但是不可避免的事情是，它们需要一些实时特性。这些测试用例不会永远等待你的代码执行完成并生成结果。所以有可能你的方法技术上是对的，但是花了太多时间导致测试用例退出。这个时候，你是不能通过全部的测试用例的。因此你的确需要关注性能，从而使得你的方案即是正确的，又有足够的性能。不幸的是，性能与 Log 的复杂度相关，所以很容易就写出一个正确但是不够快的方法出来。
>
> 学生提问：能在解释一下这里的流程吗？
>
> Robert 教授：这里，Leader 发现冲突的方法在于，Follower 会返回它从冲突条目中看到的任期号（XTerm）。在场景 1 中，Follower 会设置 XTerm=5，因为这是有冲突的 Log 条目对应的任期号。Leader 会发现，哦，我的 Log 中没有任期 5 的条目。因此，在场景 1 中，Leader 会一次性回退到 Follower 在任期 5 的起始位置。因为 Leader 并没有任何任期 5 的 Log，所以它要删掉 Follower 中所有任期 5 的 Log，这通过回退到 Follower 在任期 5 的第一条 Log 条目的位置，也就是 XIndex 达到的。
