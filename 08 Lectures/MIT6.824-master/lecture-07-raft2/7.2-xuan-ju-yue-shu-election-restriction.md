# 7.2 选举约束（Election Restriction）

在前面的例子中，我们选择 S3 作为 Leader。现在有个问题是，哪些节点允许成为 Leader？

如果你读了 Raft 论文，那么你就知道答案：为了保证系统的正确性，并非任意节点都可以成为 Leader。不是说第一个选举定时器超时了并触发选举的节点，就一定是 Leader。Raft 对于谁可以成为 Leader，谁不能成为 Leader 是有一些限制的。

为了证明并非任意节点都可以成为 Leader，我们这里提出一个例子来证伪。在这个反例中，Raft 会选择拥有最长 Log 记录的节点作为 Leader，这个规则或许适用于其他系统，实际上在一些其他设计的系统中的确使用了这样的规则，但是在 Raft 中，这条规则不适用。所以，我们这里需要研究的问题是：为什么不选择拥有最长 Log 记录的节点作为 Leader？如果我们这么做了的话，我们需要更改 Raft 中的投票规则，让选民只投票给拥有更长 Log 记录的节点。

![](<../assets/image (55).png>)

很容易可以展示为什么这是一个错误的观点。我们还是假设我们有 3 个服务器，现在服务器 1（S1）有任期 5，6，7 的 Log，服务器 2 和服务器 3（S2 和 S3）有任期 5，8 的 Log。

![](<../assets/image (56).png>)

为了避免我们在不可能出现的问题上浪费时间，这里的第一个问题是，这个场景可能出现吗？让我们回退一些时间，在这个时间点 S1 赢得了选举，现在它的任期号是 6。它收到了一个客户端请求，在发出 AppendEntries 之前，它先将请求存放在自己的 Log 中，然后它就故障了，所以它没能发出任何 AppendEntries 消息。

![](<../assets/image (57).png>)

之后它很快就故障重启了，因为它是之前的 Leader，所以会有一场新的选举。这次，它又被选为 Leader。然后它收到了一个任期 7 的客户端请求，将这个请求加在本地 Log 之后，它又故障了。

![](<../assets/image (58).png>)

S1 故障之后，我们又有了一次新的选举，这时 S1 已经关机了，不能再参加选举，这次 S2 被选为 Leader。如果 S2 当选，而 S1 还在关机状态，S2 会使用什么任期号呢？

明显我们的答案是 8（因为之前画出来了），但是为什么任期号是 8 而不是 6 呢？尽管没有写在黑板上，但是 S1 在任期 6，7 能当选，它必然拥有了过半节点的投票，过半服务器至少包含了 S2，S3 中的一个节点。如果你去看处理 RequestVote 的代码和 Raft 论文的图 2，当某个节点为候选人投票时，节点应该将候选人的任期号记录在持久化存储中。所里在这里，S2 或者 S3 或者它们两者都知道任期 6 和任期 7 的存在。因此，当 S1 故障了，它们中至少一个知道当前的任期是 8。这里，只有知道了任期 8 的节点才有可能当选，如果只有一个节点知道，那么这个节点会赢得选举，因为它拥有更高的任期号。如果 S2 和 S3 都知道当前任期是 8，那么它们两者中的一个会赢得选举。所以，下一个任期必然为 8 这个事实，依赖于不同任期的过半服务器之间必然有重合这个特点。同时，也依赖任期号会通过 RequestVote RPC 更新给其他节点，并持久化存储，这样出现故障才不会丢失数据。所以下一个任期号将会是 8，S2 或者 S3 会赢得选举。不管是哪一个，新的 Leader 会继续将客户端请求转换成 AppendEntries 发给其他节点。所以我们现在有了这么一个场景。

![](<../assets/image (59).png>)

现在我们回到对于这个场景的最初的问题，假设 S1 重新上线了，并且我们又有了一次新的选举，这时候可以选择 S1 作为 Leader 吗？或者说，可以选择拥有最长 Log 记录的节点作为 Leader 可以吗？明显，答案是不可以的。

如果 S1 是 Leader，它会通过 AppendEntries 机制将自己的 Log 强加给 2 个 Followers，这个我们刚刚（上一节）说过了。如果我们让 S1 作为 Leader，它会发出 AppendEntries 消息来覆盖 S2 和 S3 在任期 8 的 Log，并在 S2 和 S3 中写入 S1 中的任期 6 和任期 7 的 Log，这样所有的节点的 Log 才能与 S1 保持一致。为什么我们不能认可这样的结果呢？

是的，因为 S2 和 S3 可以组成过半服务器，所以任期 8 的 Log 已经被 commit 了，对应的请求很可能已经执行了，应用层也很可能发送一个回复给客户端了。所以我们不能删除任期 8 的 Log。因此，S1 也就不能成为 Leader 并将自己的 Log 强制写入 S2 和 S3。大家都明白了为什么这对于 Raft 来说是个坏的结果吗？正因为这个原因，我们不能在选举的时候直接选择拥有最长 Log 记录的节点。当然，最短 Log 记录的节点也不行。

在 Raft 论文的 5.4.1，Raft 有一个稍微复杂的选举限制（Election Restriction）。这个限制要求，在处理别节点发来的 RequestVote RPC 时，需要做一些检查才能投出赞成票。这里的限制是，节点只能向满足下面条件之一的候选人投出赞成票：

1. 候选人最后一条 Log 条目的任期号**大于**本地最后一条 Log 条目的任期号；
2. 或者，候选人最后一条 Log 条目的任期号**等于**本地最后一条 Log 条目的任期号，且候选人的 Log 记录长度**大于等于**本地 Log 记录的长度

![](<../assets/image (60).png>)

回到我们的场景，如果 S2 收到了 S1 的 RequestVote RPC，因为 S1 的最后一条 Log 条目的任期号是 7，而 S2 的最后一条 Log 条目的任期号是 8，两个限制都不满足，所以 S2 和 S3 都不会给 S1 投赞成票。即使 S1 的选举定时器的超时时间更短，并且先发出了 RequestVote 请求，除了它自己，没人会给它投票，所以它只能拿到一个选票，不能凑够过半选票。如果 S2 或者 S3 成为了候选人，它们中的另一个都会投出赞成票，因为它们最后的任期号一样，并且它们的 Log 长度大于等于彼此（满足限制 2）。所以 S2 或者 S3 中的任意一个都会为另一个投票。S1 会为它们投票吗？会的，因为 S2 或者 S3 最后一个 Log 条目对应的任期号更大（满足限制 1）。

所以在这里，Raft 更喜欢拥有更高任期号记录的候选人，或者说更喜欢拥有任期号更高的旧 Leader 记录的候选人。限制 2 说明，如果候选人都拥有任期号最高的旧 Leader 记录，那么 Raft 更喜欢拥有更多记录的候选人。
