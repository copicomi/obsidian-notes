# 7.1 日志恢复（Log Backup）

（接 6.9 的内容）

我们现在处于这样一个场景

![](<../assets/image (43).png>)

我们假设下一个任期是 6。尽管你无法从黑板上确认这一点，但是下一个任期号至少是 6 或者更大。我们同时假设 S3 在任期 6 被选为 Leader。在某个时刻，新 Leader S3 会发送任期 6 的第一个 AppendEntries RPC，来传输任期 6 的第一个 Log，这个 Log 应该在槽位 13。

这里的 AppendEntries 消息实际上有两条，因为要发给两个 Followers。它们包含了客户端发送给 Leader 的请求。我们现在想将这个请求复制到所有的 Followers 上。这里的 AppendEntries RPC 还包含了 prevLogIndex 字段和 prevLogTerm 字段。所以 Leader 在发送 AppendEntries 消息时，会附带前一个槽位的信息。在我们的场景中，prevLogIndex 是前一个槽位的位置，也就是 12；prevLogTerm 是 S3 上前一个槽位的任期号，也就是 5。

![](<../assets/image (46).png>)

这样的 AppendEntries 消息发送给了 Followers。而 Followers，它们在收到 AppendEntries 消息时，可以知道它们收到了一个带有若干 Log 条目的消息，并且是从槽位 13 开始。Followers 在写入 Log 之前，会检查本地的前一个 Log 条目，是否与 Leader 发来的有关前一条 Log 的信息匹配。

所以对于 S2 它显然是不匹配的。S2 在槽位 12 已经有一个条目，但是它来自任期 4，而不是任期 5。所以 S2 将拒绝这个 AppendEntries，并返回 False 给 Leader。S1 在槽位 12 还没有任何 Log，所以 S1 也将拒绝 Leader 的这个 AppendEntries。到目前位置，一切都还好。为什么这么说呢？因为我们完全不想看到的是，S2 把这条新的 Log 添加在槽位 13。因为这样会破坏 Raft 论文中图 2 所依赖的归纳特性，并且隐藏 S2 实际上在槽位 12 有一条不同的 Log 的这一事实。

![我们不想看到的场景](<../assets/image (47).png>)

所以 S1 和 S2 都没有接受这条 AppendEntries 消息，所以，Leader 看到了两个拒绝。

Leader 为每个 Follower 维护了 nextIndex。所以它有一个 S2 的 nextIndex，还有一个 S1 的 nextIndex。之前没有说明的是，如果 Leader 之前发送的是有关槽位 13 的 Log，这意味着 Leader 对于其他两个服务器的 nextIndex 都是 13。这种情况发生在 Leader 刚刚当选，因为 Raft 论文的图 2 规定了，nextIndex 的初始值是从新任 Leader 的最后一条日志开始，而在我们的场景中，对应的就是槽位 13.

为了响应 Followers 返回的拒绝，Leader 会减小对应的 nextIndex。所以它现在减小了两个 Followers 的 nextIndex。这一次，Leader 发送的 AppendEntries 消息中，prevLogIndex 等于 11，prevLogTerm 等于 3。同时，这次 Leader 发送的 AppendEntries 消息包含了 prevLogIndex 之后的所有条目，也就是 S3 上槽位 12 和槽位 13 的 Log。

![](<../assets/image (49).png>)

对于 S2 来说，这次收到的 AppendEntries 消息中，prevLogIndex 等于 11，prevLogTerm 等于 3，与自己本地的 Log 匹配，所以，S2 会接受这个消息。Raft 论文中的图 2 规定，如果接受一个 AppendEntries 消息，那么需要首先删除本地相应的 Log（如果有的话），再用 AppendEntries 中的内容替代本地 Log。所以，S2 会这么做：它会删除本地槽位 12 的记录，再添加 AppendEntries 中的 Log 条目。这个时候，S2 的 Log 与 S3 保持了一致。

![](<../assets/image (50).png>)

但是，S1 仍然有问题，因为它的槽位 11 是空的，所以它不能匹配这次的 AppendEntries。它将再次返回 False。而 Leader 会将 S1 对应的 nextIndex 变为 11，并在 AppendEntries 消息中带上从槽位 11 开始之后的 Log（也就是槽位 11，12，13 对应的 Log）。并且带上相应的 prevLogIndex（10）和 prevLogTerm（3）。

![](<../assets/image (51).png>)

这次的请求可以被 S1 接受，并得到肯定的返回。现在它们都有了一致的 Log。

![](<../assets/image (52).png>)

而 Leader 在收到了 Followers 对于 AppendEntries 的肯定的返回之后，它会增加相应的 nextIndex 到 14。&#x20;

![](<../assets/image (53).png>)

在这里，Leader 使用了一种备份机制来探测 Followers 的 Log 中，第一个与 Leader 的 Log 相同的位置。在获得位置之后，Leader 会给 Follower 发送从这个位置开始的，剩余的全部 Log。经过这个过程，所有节点的 Log 都可以和 Leader 保持一致。

重复一个我们之前讨论过的话题，或许我们还会再讨论。在刚刚的过程中，我们擦除了一些 Log 条目，比如我们刚刚删除了 S2 中的槽位 12 的 Log。这个位置是任期 4 的 Log。现在的问题是，为什么 Raft 系统可以安全的删除这条记录？毕竟我们在删除这条记录时，某个相关的客户端请求也随之被丢弃了。

![](<../assets/image (54).png>)

我在上堂课说过这个问题，这里的原理是什么呢？是的，这条 Log 条目并没有存在于过半服务器中，因此无论之前的 Leader 是谁，发送了这条 Log，它都没有得到过半服务器的认可。因此旧的 Leader 不可能 commit 了这条记录，也就不可能将它应用到应用程序的状态中，进而也就不可能回复给客户端说请求成功了。因为它没有存在于过半服务器中，发送这个请求的客户端没有理由认为这个请求被执行了，也不可能得到一个回复。因为这里有一条规则就是，Leader 只会在 commit 之后回复给客户端。客户端甚至都没有理由相信这个请求被任意服务器收到了。并且，Raft 论文中的图 2 说明，如果客户端发送请求之后一段时间没有收到回复，它应该重新发送请求。所以我们知道，不论这个被丢弃的请求是什么，我们都没有执行它，没有把它包含在任何状态中，并且客户端之后会重新发送这个请求。

> 学生提问：前面的过程中，为什么总是删除 Followers 的 Log 的结尾部分？
>
> Robert 教授：一个备选的答案是，Leader 有完整的 Log，所以当 Leader 收到有关 AppendEntries 的 False 返回时，它可以发送完整的日志给 Follower。如果你刚刚启动系统，甚至在一开始就发生了非常反常的事情，某个 Follower 可能会从第一条 Log 条目开始恢复，然后让 Leader 发送整个 Log 记录，因为 Leader 有这些记录。如果有必要的话，Leader 拥有填充每个节点的日志所需的所有信息。
