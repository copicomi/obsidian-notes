# 10.2 故障可恢复事务（Crash Recoverable Transaction）

为了能更好的理解 Aurora 的设计，在进一步介绍它是如何工作之前，我们必须要知道典型的数据库是如何设计的。因为 Aurora 使用的是与 MySQL 类似的机制实现，但是又以一种有趣的方式实现了加速，所以我们需要知道一个典型的数据库是如何设计实现的，这样我们才能知道 Aurora 是如何实现加速的。

所以这一部分是数据库教程，但是实际上主要关注的是，如何实现一个故障可恢复事务（Crash Recoverable Transaction）。所以这一部分我们主要看的是事务（Transaction）和故障可恢复（Crash Recovery）。数据库还涉及到很多其他的方面，但是对于 Aurora 来说，这两部分最重要。

首先，什么是事务？事务是指将多个操作打包成原子操作，并确保多个操作顺序执行。假设我们运行一个银行系统，我们想在不同的银行账户之间转账。你可以这样看待一个事务，首先需要定义想要原子打包的多个操作的开始；之后是操作的内容，现在我们想要从账户 Y 转 10 块钱到账户 X，那么账户 X 需要增加 10 块，账户 Y 需要减少 10 块；最后表明事务结束。

![](<../assets/image (319).png>)

我们希望数据库顺序执行这两个操作，并且不允许其他任何人看到执行的中间状态。同时，考虑到故障，如果在执行的任何时候出现故障，我们需要确保故障恢复之后，要么所有操作都已经执行完成，要么一个操作也没有执行。这是我们想要从事务中获得的效果。除此之外，数据库的用户期望数据库可以通知事务的状态，也就是事务是否真的完成并提交了。如果一个事务提交了，用户期望事务的效果是可以持久保存的，即使数据库故障重启了，数据也还能保存。

通常来说，事务是通过对涉及到的每一份数据加锁来实现。所以你可以认为，在整个事务的过程中，都对 X，Y 加了锁。并且只有当事务结束、提交并且持久化存储之后，锁才会被释放。所以，数据库实际上在事务的过程中，是通过对数据加锁来确保其他人不能访问。这一点很重要，理解了这一点，论文中有一些细节才变得有意义。

![](<../assets/image (329).png>)

所以，这里具体是怎么实现的呢？对于一个简单的数据库模型，数据库运行在单个服务器上，并且使用本地硬盘。

![](<../assets/image (321).png>)

在硬盘上存储了数据的记录，或许是以 B-Tree 方式构建的索引。所以有一些 data page 用来存放数据库的数据，其中一个存放了 X 的记录，另一个存放了 Y 的记录。每一个 data page 通常会存储大量的记录，而 X 和 Y 的记录是 page 中的一些 bit 位。

![](<../assets/image (322).png>)

在硬盘中，除了有数据之外，还有一个预写式日志（Write-Ahead Log，简称为 WAL）。预写式日志对于系统的容错性至关重要。

![](<../assets/image (323).png>)

在服务器内部，有数据库软件，通常数据库会对最近从磁盘读取的 page 有缓存。

![](<../assets/image (324).png>)

当你在执行一个事务内的各个操作时，例如执行 X=X+10 的操作时，数据库会从硬盘中读取持有 X 的记录，给数据加 10。但是在事务提交之前，数据的修改还只在本地的缓存中，并没有写入到硬盘。我们现在还不想向硬盘写入数据，因为这样可能会暴露一个不完整的事务。

为了让数据库在故障恢复之后，还能够提供同样的数据，在允许数据库软件修改硬盘中真实的 data page 之前，数据库软件需要先在 WAL 中添加 Log 条目来描述事务。所以在提交事务之前，数据库需要先在 WAL 中写入完整的 Log 条目，来描述所有有关数据库的修改，并且这些 Log 是写入磁盘的。

让我们假设，X 的初始值是 500，Y 的初始值是 750。

![](<../assets/image (325).png>)

在提交并写入硬盘的 data page 之前，数据库通常需要写入至少 3 条 Log 记录：

1. 第一条表明，作为事务的一部分，我要修改 X，它的旧数据是 500，我要将它改成 510。
2. 第二条表明，我要修改 Y，它的旧数据是 750，我要将它改成 740。
3. 第三条记录是一个 Commit 日志，表明事务的结束。

通常来说，前两条 Log 记录会打上事务的 ID 作为标签，这样在故障恢复的时候，可以根据第三条 commit 日志找到对应的 Log 记录，进而知道哪些操作是已提交事务的，哪些是未完成事务的。

![](<../assets/image (326).png>)

> 学生提问：为什么在 WAL 的 log 中，需要带上旧的数据值？
>
> Robert 教授：在这个简单的数据库中，在 WAL 中只记录新的数据就可以了。如果出现故障，只需要重新应用所有新的数据即可。但是大部分真实的数据库同时也会在 WAL 中存储旧的数值，这样对于一个非常长的事务，只要 WAL 保持更新，在事务结束之前，数据库可以提前将更新了的 page 写入硬盘，比如说将 Y 写入新的数据 740。之后如果在事务提交之前故障了，恢复的软件可以发现，事务并没有完成，所以需要撤回之前的操作，这时，这些旧的数据，例如 Y 的 750，需要被用来撤回之前写入到 data page 中的操作。对于 Aurora 来说，实际上也使用了 undo/redo 日志，用来撤回未完成事务的操作。

如果数据库成功的将事务对应的操作和 commit 日志写入到磁盘中，数据库可以回复给客户端说，事务已经提交了。而这时，客户端也可以确认事务是永久可见的。

接下来有两种情况。

如果数据库没有崩溃，那么在它的 cache 中，X，Y 对应的数值分别是 510 和 740。最终数据库会将 cache 中的数值写入到磁盘对应的位置。所以数据库写磁盘是一个 lazy 操作，它会对更新进行累积，每一次写磁盘可能包含了很多个更新操作。这种累积更新可以提升操作的速度。

如果数据库在将 cache 中的数值写入到磁盘之前就崩溃了，这样磁盘中的 page 仍然是旧的数值。当数据库重启时，恢复软件会扫描 WAL 日志，发现对应事务的 Log，并发现事务的 commit 记录，那么恢复软件会将新的数值写入到磁盘中。这被称为 redo，它会重新执行事务中的写操作。

这就是事务型数据库的工作原理的简单描述，同时这也是一个极度精简的 MySQL 数据库工作方式的介绍，MySQL 基本以这种方式实现了故障可恢复事务。而 Aurora 就是基于这个开源软件 MYSQL 构建的。
