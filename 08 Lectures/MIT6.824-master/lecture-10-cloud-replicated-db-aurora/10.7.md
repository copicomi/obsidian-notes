# 10.7 Aurora 读写存储服务器

我之前也解释过，Aurora 中的写请求并不是像一个经典的 Quorum 系统一样直接更新数据。对于 Aurora 来说，它的写请求从来不会覆盖任何数据，它的写请求只会在当前 Log 中追加条目（Append Entries）。所以，Aurora 使用 Quorum 只是在数据库执行事务并发出新的 Log 记录时，确保 Log 记录至少出现在 4 个存储服务器上，之后才能提交事务。所以，Aurora 的 Write Quorum 的实际意义是，每个新的 Log 记录必须至少追加在 4 个存储服务器中，之后才可以认为写请求完成了。当 Aurora 执行到事务的结束，并且在回复给客户端说事务已经提交之前，Aurora 必须等待 Write Quorum 的确认，也就是 4 个存储服务器的确认，组成事务的每一条 Log 都成功写入了。

实际上，在一个故障恢复过程中，事务只能在之前所有的事务恢复了之后才能被恢复。所以，实际中，在 Aurora 确认一个事务之前，它必须等待 Write Quorum 确认之前所有已提交的事务，之后再确认当前的事务，最后才能回复给客户端。

这里的存储服务器接收 Log 条目，这是它们看到的写请求。它们并没有从数据库服务器获得到新的 data page，它们得到的只是用来描述 data page 更新的 Log 条目。

但是存储服务器内存最终存储的还是数据库服务器磁盘中的 page。在存储服务器的内存中，会有自身磁盘中 page 的 cache，例如 page1（P1），page2（P2），这些 page 其实就是数据库服务器对应磁盘的 page。

![](<../assets/image (342).png>)

当一个新的写请求到达时，这个写请求只是一个 Log 条目，Log 条目中的内容需要应用到相关的 page 中。但是我们不必立即执行这个更新，可以等到数据库服务器或者恢复软件想要查看那个 page 时才执行。对于每一个存储服务器存储的 page，如果它最近被一个 Log 条目修改过，那么存储服务器会在内存中缓存一个旧版本的 page 和一系列来自于数据库服务器有关修改这个 page 的 Log 条目。所以，对于一个新的 Log 条目，它会立即被追加到影响到的 page 的 Log 列表中。这里的 Log 列表从上次 page 更新过之后开始（相当于 page 是 snapshot，snapshot 后面再有一系列记录更新的 Log）。如果没有其他事情发生，那么存储服务器会缓存旧的 page 和对应的一系列 Log 条目。

![](<../assets/image (343).png>)

如果之后数据库服务器将自身缓存的 page 删除了，过了一会又需要为一个新的事务读取这个 page，它会发出一个读请求。请求发送到存储服务器，会要求存储服务器返回当前最新的 page 数据。在这个时候，存储服务器才会将 Log 条目中的新数据更新到 page，并将 page 写入到自己的磁盘中，之后再将更新了的 page 返回给数据库服务器。同时，存储服务器在自身 cache 中会删除 page 对应的 Log 列表，并更新 cache 中的 page，虽然实际上可能会复杂的多。

如刚刚提到的，数据库服务器有时需要读取 page。所以，可能你已经发现了，数据库服务器写入的是 Log 条目，但是读取的是 page。这也是与 Quorum 系统不一样的地方。Quorum 系统通常读写的数据都是相同的。除此之外，在一个普通的操作中，数据库服务器可以避免触发 Quorum Read。数据库服务器会记录每一个存储服务器接收了多少 Log。所以，首先，Log 条目都有类似 12345 这样的编号，当数据库服务器发送一条新的 Log 条目给所有的存储服务器，存储服务器接收到它们会返回说，我收到了第 79 号和之前所有的 Log。数据库服务器会记录这里的数字，或者说记录每个存储服务器收到的最高连续的 Log 条目号。这样的话，当一个数据库服务器需要执行读操作，它只会挑选拥有最新 Log 的存储服务器，然后只向那个服务器发送读取 page 的请求。所以，数据库服务器执行了 Quorum Write，但是却没有执行 Quorum Read。因为它知道哪些存储服务器有最新的数据，然后可以直接从其中一个读取数据。这样的代价小得多，因为这里只读了一个副本，而不用读取 Quorum 数量的副本。

但是，数据库服务器有时也会使用 Quorum Read。假设数据库服务器运行在某个 EC2 实例，如果相应的硬件故障了，数据库服务器也会随之崩溃。在 Amazon 的基础设施有一些监控系统可以检测到 Aurora 数据库服务器崩溃，之后 Amazon 会自动的启动一个 EC2 实例，在这个实例上启动数据库软件，并告诉新启动的数据库：你的数据存放在那 6 个存储服务器中，请清除存储在这些副本中的任何未完成的事务，之后再继续工作。这时，Aurora 会使用 Quorum 的逻辑来执行读请求。因为之前数据库服务器故障的时候，它极有可能处于执行某些事务的中间过程。所以当它故障了，它的状态极有可能是它完成并提交了一些事务，并且相应的 Log 条目存放于 Quorum 系统。同时，它还在执行某些其他事务的过程中，这些事务也有一部分 Log 条目存放在 Quorum 系统中，但是因为数据库服务器在执行这些事务的过程中崩溃了，这些事务永远也不可能完成。对于这些未完成的事务，我们可能会有这样一种场景，第一个副本有第 101 个 Log 条目，第二个副本有第 102 个 Log 条目，第三个副本有第 104 个 Log 条目，但是没有一个副本持有第 103 个 Log 条目。

![](<../assets/image (344).png>)

所以故障之后，新的数据库服务器需要恢复，它会执行 Quorum Read，找到第一个缺失的 Log 序号，在上面的例子中是 103，并说，好吧，我们现在缺失了一个 Log 条目，我们不能执行这条 Log 之后的所有 Log，因为我们缺失了一个 Log 对应的更新。

所以，这种场景下，数据库服务器执行了 Quorum Read，从可以连接到的存储服务器中发现 103 是第一个缺失的 Log 条目。这时，数据库服务器会给所有的存储服务器发送消息说：请丢弃 103 及之后的所有 Log 条目。103 及之后的 Log 条目必然不会包含已提交的事务，因为我们知道只有当一个事务的所有 Log 条目存在于 Write Quorum 时，这个事务才会被 commit，所以对于已经 commit 的事务我们肯定可以看到相应的 Log。这里我们只会丢弃未 commit 事务对应的 Log 条目。

所以，某种程度上，我们将 Log 在 102 位置做了切割，102 及之前的 Log 会保留。但是这些会保留的 Log 中，可能也包含了未 commit 事务的 Log，数据库服务器需要识别这些 Log。这是可行的，可以通过 Log 条目中的事务 ID 和事务的 commit Log 条目来判断（10.3）哪些 Log 属于已经 commit 的事务，哪些属于未 commit 的事务。数据库服务器可以发现这些未完成的事务对应 Log，并发送 undo 操作来撤回所有未 commit 事务做出的变更。这就是为什么 Aurora 在 Log 中同时也会记录旧的数值的原因。因为只有这样，数据库服务器在故障恢复的过程中，才可以回退之前只提交了一部分，但是没 commit 的事务。
