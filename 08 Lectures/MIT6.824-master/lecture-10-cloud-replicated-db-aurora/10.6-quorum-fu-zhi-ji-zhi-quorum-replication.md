# 10.6 Quorum 复制机制（Quorum Replication）

Aurora 使用了 Quorum 这种思想。接下来，我将描述一下经典的 Quorum 思想，它最早可以追溯到 1970 年代。Aurora 使用的是一种经典 quorum 思想的变种。Quorum 系统背后的思想是通过复制构建容错的存储系统，并确保即使有一些副本故障了，读请求还是能看到最近的写请求的数据。通常来说，Quorum 系统就是简单的读写系统，支持 Put/Get 操作。它们通常不直接支持更多更高级的操作。你有一个对象，你可以读这个对象，也可以通过写请求覆盖这个对象的数值。

假设有 N 个副本。为了能够执行写请求，必须要确保写操作被 W 个副本确认，W 小于 N。所以你需要将写请求发送到这 W 个副本。如果要执行读请求，那么至少需要从 R 个副本得到所读取的信息。这里的 W 对应的数字称为 Write Quorum，R 对应的数字称为 Read Quorum。这是一个典型的 Quorum 配置。

![](<../assets/image (335).png>)

这里的关键点在于，W、R、N 之间的关联。Quorum 系统要求，任意你要发送写请求的 W 个服务器，必须与任意接收读请求的 R 个服务器有重叠。这意味着，R 加上 W 必须大于 N（ 至少满足 R + W = N + 1 ），这样任意 W 个服务器至少与任意 R 个服务器有一个重合。

![](<../assets/image (336).png>)

假设你有 3 个服务器，并且假设每个服务器只存了一个对象。

![](<../assets/image (337).png>)

我们发送了一个写请求，想将我们的对象设置成 23。为了能够执行写请求，我们需要至少将写请求发送到 W 个服务器。我们假设在这个系统中，R 和 W 都是 2，N 是 3。为了执行一个写请求，我们需要将新的数值 23 发送到至少 2 个服务器上。所以，或许我们的写请求发送到了 S1 和 S3。所以，它们现在知道了我们对象的数值是 23。

![](<../assets/image (338).png>)

如果某人发起读请求，读请求会至少检查 R 个服务器。在这个配置中，R 也是 2。这里的 R 个服务器可能包含了并没有看到之前写请求的服务器（S2），但同时也至少还需要一个其他服务器来凑齐 2 个服务器。这意味着，任何读请求都至少会包含一个看到了之前写请求的服务器。

![](<../assets/image (339).png>)

这是 Quorum 系统的要求，Read Quorum 必须至少与 Write Quorum 有一个服务器是重合的。所以任何读请求可以从至少一个看见了之前写请求的服务器得到回复。

这里还有一个关键的点，客户端读请求可能会得到 R 个不同的结果，现在的问题是，客户端如何知道从 R 个服务器得到的 R 个结果中，哪一个是正确的呢？通过不同结果出现的次数来投票（Vote）在这是不起作用的，因为我们只能确保 Read Quorum 必须至少与 Write Quorum 有一个服务器是重合的，这意味着客户端向 R 个服务器发送读请求，可能只有一个服务器返回了正确的结果。对于一个有 6 个副本的系统，可能 Read Quorum 是 4，那么你可能得到了 4 个回复，但是只有一个与之前写请求重合的服务器能将正确的结果返回，所以这里不能使用投票。在 Quorum 系统中使用的是版本号（Version）。所以，每一次执行写请求，你需要将新的数值与一个增加的版本号绑定。之后，客户端发送读请求，从 Read Quorum 得到了一些回复，客户端可以直接使用其中的最高版本号的数值。

假设刚刚的例子中，S2 有一个旧的数值 20。每一个服务器都有一个版本号，S1 和 S3 是版本 3，因为它们看到了相同的写请求，所以它们的版本号是相同的。同时我们假设没有看到前一个写请求的 S2 的版本号是 2。

![](<../assets/image (340).png>)

之后客户端从 S2 和 S3 读取数据，得到了两个不同结果，它们有着不同的版本号，客户端会挑选版本号最高的结果。

如果你不能与 Quorum 数量的服务器通信，不管是 Read Quorum 还是 Write Quorum，那么你只能不停的重试了。这是 Quorum 系统的规则，你只能不停的重试，直到服务器重新上线，或者重新联网。

相比 Chain Replication，这里的优势是可以轻易的剔除暂时故障、失联或者慢的服务器。实际上，这里是这样工作的，当你执行写请求时，你会将新的数值和对应的版本号给所有 N 个服务器，但是只会等待 W 个服务器确认。类似的，对于读请求，你可以将读请求发送给所有的服务器，但是只等待 R 个服务器返回结果。因为你只需要等待 R 个服务器，这意味着在最快的 R 个服务器返回了之后，你就可以不用再等待慢服务器或者故障服务器超时。这里忽略慢服务器或者挂了的服务器的机制完全是隐式的。在这里，我们不用决定哪个服务器是在线或者是离线的，只要 Quorum 能达到，系统就能继续工作，所以我们可以非常平滑的处理慢服务或者挂了的服务。

除此之外，Quorum 系统可以调整读写的性能。通过调整 Read Quorum 和 Write Quorum，可以使得系统更好的支持读请求或者写请求。对于前面的例子，我们可以假设 Write Quorum 是 3，每一个写请求必须被所有的 3 个服务器所确认。这样的话，Read Quorum 可以只是 1。所以，如果你想要提升读请求的性能，在一个 3 个服务器的 Quorum 系统中，你可以设置 R 为 1，W 为 3，这样读请求会快得多，因为它只需要等待一个服务器的结果，但是代价是写请求执行的比较慢。如果你想要提升写请求的性能，可以设置 R 为 3，W 为 1，这意味着可能只有 1 个服务器有最新的数值，但是因为客户端会咨询 3 个服务器，3 个服务器其中一个肯定包含了最新的数值。

当 R 为 1，W 为 3 时，写请求就不再是容错的了，同样，当 R 为 3，W 为 1 时，读请求不再是容错的，因为对于读请求，所有的服务器都必须在线才能执行成功。所以在实际场景中，你不会想要这么配置，你或许会与 Aurora 一样，使用更多的服务器，将 N 变大，然后再权衡 Read Quorum 和 Write Quorum。

为了实现上一节描述的 Aurora 的容错目标，也就是在一个 AZ 完全下线时仍然能写，在一个 AZ 加一个其他 AZ 的服务器下线时仍然能读，Aurora 的 Quorum 系统中，N=6，W=4，R=3。W 等于 4 意味着，当一个 AZ 彻底下线时，剩下 2 个 AZ 中的 4 个服务器仍然能完成写请求。R 等于 3 意味着，当一个 AZ 和一个其他 AZ 的服务器下线时，剩下的 3 个服务器仍然可以完成读请求。当 3 个服务器下线了，系统仍然支持读请求，仍然可以返回当前的状态，但是却不能支持写请求。所以，当 3 个服务器挂了，现在的 Quorum 系统有足够的服务器支持读请求，并据此重建更多的副本，但是在新的副本创建出来替代旧的副本之前，系统不能支持写请求。同时，如我之前解释的，Quorum 系统可以剔除暂时的慢副本。
