# 3.2 错误的设计（Bad Design）

这里说到了一致性，我在后面的课程会对“好”的一致性做更多的介绍（lec6-7）。对于具备强一致或者好的一致性的系统，从应用程序或者客户端看起来就像是和一台服务器在通信。尽管我们会通过数百台计算机构建一个系统，但是对于一个理想的强一致模型，你看到的就像是只有一台服务器，一份数据，并且系统一次只做一件事情。这是一种直观的理解强一致的方式。你可以认为只有一台服务器，甚至这个服务器只运行单线程，它同一时间只处理来自客户端的一个请求。这很重要，因为可能会有大量的客户端并发的发送请求到服务器上。这里要求服务器从请求中挑选一个出来先执行，执行完成之后再执行下一个。

![](<../assets/image (224).png>)

对于存储服务器来说，它上面会有一块磁盘。执行一个写请求或许意味着向磁盘写入一个数据或者对数据做一次自增。如果这是一次修改操作，并且我们有一个以 key-value 为索引的数据表单，那么我们会修改这个表单。如果是一次读取操作，我们只需要将之前写入的数据，从表单中取出即可。

![](<../assets/image (225).png>)

为了让这里的简单服务有可预期的行为，需要定义一条规则：一个时间只执行一条请求。这样每个请求都可以看到之前所有请求按照顺序执行生成的数据。所以，如果有一些写请求，并且服务器以某种顺序一次一个的处理了它们，当你从服务器读数据时，你可以看到期望的数据。这里的解释不是很直观，你可以通过下面的例子去理解。

例如，我们有一些客户端，客户端 C1 发起写请求将 X 设置成 1。在同一时刻，客户端 C2 发起写请求将 X 设置成 2。

![](<../assets/image (226).png>)

过了一会，在 C1 和 C2 的写请求都执行完毕之后，客户端 C3 会发送读取 X 的请求，并得到了一个结果。客户端 C4 也会发送读取 X 的请求，也得到了一个结果。现在的问题是，这两个客户端看到的结果是什么？

![](<../assets/image (227).png>)

> 学生提问：为什么一定要一次只处理一个请求？
>
> Robert 教授：这是个好问题。在这里，我假设 C1 和 C2 在同一时间发起请求。所以，如果我们在监控网络的话，我们可以看到两个请求同时发往服务器。之后在某个时刻，服务器会响应它们。但是这里没有足够的信息来判断，服务器会以哪种顺序执行这两个写请求。如果服务器先处理了写 X 为 1 的请求，那么就意味着它接下来会处理写 X 为 2 的请求，所以接下来的读 X 请求可以看到 2。然而，如果服务器先处理了写 X 为 2 的请求，再处理写 X 为 1 的请求，那么接下来的读 X 请求看到的就是 1。

我这里提出这个场景的目的是为了展示，即使在一个非常简单的系统中，仍然会出现一些模糊的场景使得你不知道系统的执行过程以及输出结果。你能做的只是从产生的结果来判断系统的输出是一致性还是非一致性。

如果 C3 读 X 得到 2，那么 C4 最好也是读 X 得到 2，因为在我们的例子中，C3 读 X 得到 2 意味着，写 X 为 2 的请求必然是第二个执行的写请求。当 C4 读 X 时，写 X 为 2 应该仍然是第二个写请求。希望这里完全直观的介绍清楚了有关强一致的一个模型。

当然，这里的问题是，因为只有单个服务器，所以容错能力很差。如果服务器故障了，磁盘坏了，系统整个就不可用了。所以，在现实世界中，我们会构建多副本的分布式系统，但这却又是所有问题的开始。

这里有一个几乎是最糟糕的多副本设计，我提出它是为了让你们知道问题所在，并且同样的问题在 GFS 中也存在。这个设计是这样，我们有两台服务器，每个服务器都有数据的一份完整拷贝。它们在磁盘上都存储了一个 key-value 表单。当然，直观上我们希望这两个表单是完全一致的，这样，一台服务器故障了，我们可以切换到另一台服务器去做读写。

![](<../assets/image (228).png>)

两个表单完全一致意味着，每一个写请求都必须在两台服务器上执行，而读请求只需要在一台服务器上执行，否则就没有容错性了。因为如果读请求也需要从两台服务器读数据，那么一台服务器故障我们就没法提供服务了。现在问题来了，假设客户端 C1 和 C2 都想执行写请求，其中一个要写 X 为 1，另一个写 X 为 2。C1 会将写 X 为 1 的请求发送个两个服务器，因为我们想要更新两台服务器上的数据。C2 也会将写 X 为 2 的请求发送给两个服务器。

![](<../assets/image (229).png>)

这里会出现什么错误呢？是的，我们没有做任何事情来保障两台服务器以相同的顺序处理这 2 个请求。这个设计真不咋样。如果服务器 1（S1）先处理 C1 的请求，那么在它的表单里面，X 先是 1，之后 S1 看到了来自 C2 的请求，会将自己表单中的 X 覆盖成 2。但是，如果 S2 恰好以不同的顺序收到客户端请求，那么 S2 会先执行 C2 的请求，将 X 设置为 2，之后收到 C1 的请求，将 X 设置为 1。

![](<../assets/image (230).png>)

之后，如果另外一些客户端，假设 C3 从 S1 读数据，C4 从 S2 读数据，我们就会面临一个可怕的场景：这两个客户端读取的数据不一样。但是从前一个例子中的简单模型可以看出，相连的读请求应该读出相同的数据。

这里的问题可以以另一种方式暴露出来。假设我们尝试修复上面的问题，我们让客户端在 S1 还在线的时候，只从 S1 读取数据，S1 不在线了再从 S2 读取数据。这样最开始所有的客户端读 X 都能得到 2。但是突然，如果 S1 故障了，尽管没有写请求将 X 改成 1，客户端读 X 得到的数据将会从 2 变成 1。因为 S1 故障之后，所有的客户端都会切换到 S2 去读数据。这种数据的神奇变化与任何写操作都没有关联，并且也不可能在前一个例子的简单模型中发生。

当然，这里的问题是可以修复的，修复需要服务器之间更多的通信，并且复杂度也会提升。由于获取强一致会带来不可避免的复杂性的提升，有大量的方法可以在好的一致性和一些小瑕疵行为之间追求一个平衡。
