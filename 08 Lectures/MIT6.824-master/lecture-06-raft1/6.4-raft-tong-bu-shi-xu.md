# 6.4 Log 同步时序

这一部分我们从另一个角度来看 Raft Log 同步的一些交互，这种角度将会在这门课中出现很多次，那就是时序图。

接下来我将画一个时序图来描述 Raft 内部的消息是如何工作的。假设我们有一个客户端，服务器 1 是当前 Raft 集群的 Leader。同时，我们还有服务器 2，服务器 3。这张图的纵坐标是时间，越往下时间越长。假设客户端将请求发送给服务器 1，这里的客户端请求就是一个简单的请求，例如一个 Put 请求。

![](<../assets/image (19).png>)

之后，服务器 1 的 Raft 层会发送一个添加日志（AppendEntries）的 RPC 到其他两个副本（S2，S3）。现在服务器 1 会一直等待其他副本节点的响应，一直等到过半节点的响应返回。这里的过半节点包括 Leader 自己。所以在一个只有 3 个副本节点的系统中，Leader 只需要等待一个其他副本节点。

![](<../assets/image (18).png>)

一旦过半的节点返回了响应，这里的过半节点包括了 Leader 自己，所以在一个只有 3 个副本的系统中，Leader 只需要等待一个其他副本节点返回对于 AppendEntries 的正确响应。

![](<../assets/image (17).png>)

当 Leader 收到了过半服务器的正确响应，Leader 会执行（来自客户端的）请求，得到结果，并将结果返回给客户端。

![](<../assets/image (16).png>)

与此同时，服务器 3 可能也会将它的响应返回给 Leader，尽管这个响应是有用的，但是这里不需要等待这个响应。这一点对于理解 Raft 论文中的图 2 是有用的。

![](<../assets/image (15).png>)

好了，大家明白了吗？这是系统在没有故障情况下，处理普通操作的流程。

> 学生提问：S2 和 S3 的状态怎么保持与 S1 同步？
>
> Robert 教授：我的天，我忘了一些重要的步骤。现在 Leader 知道过半服务器已经添加了 Log，可以执行客户端请求，并返回给客户端。但是服务器 2 还不知道这一点，服务器 2 只知道：我从 Leader 那收到了这个请求，但是我不知道这个请求是不是已经被 Leader 提交（committed）了，这取决于我的响应是否被 Leader 收到。服务器 2 只知道，它的响应提交给了网络，或许 Leader 没有收到这个响应，也就不会决定 commit 这个请求。所以这里还有一个阶段。一旦 Leader 发现请求被 commit 之后，它需要将这个消息通知给其他的副本。所以这里有一个额外的消息。

![](<../assets/image (20).png>)

这条消息的具体内容依赖于整个系统的状态。至少在 Raft 中，没有明确的 committed 消息。相应的，committed 消息被夹带在下一个 AppendEntries 消息中，由 Leader 下一次的 AppendEntries 对应的 RPC 发出。任何情况下，当有了 committed 消息时，这条消息会填在 AppendEntries 的 RPC 中。下一次 Leader 需要发送心跳，或者是收到了一个新的客户端请求，要将这个请求同步给其他副本时，Leader 会将新的更大的 commit 号随着 AppendEntries 消息发出，当其他副本收到了这个消息，就知道之前的 commit 号已经被 Leader 提交，其他副本接下来也会执行相应的请求，更新本地的状态。

![](<../assets/image (21).png>)

> 学生提问：这里的内部交互有点多吧？
>
> Robert 教授：是的，这是一个内部需要一些交互的协议，它不是特别的快。实际上，客户端发出请求，请求到达某个服务器，这个服务器至少需要与一个其他副本交互，在返回给客户端之前，需要等待多条消息。所以，一个客户端响应的背后有多条消息的交互。
>
> 学生提问：也就是说 commit 信息是随着普通的 AppendEntries 消息发出的？那其他副本的状态更新就不是很及时了。
>
> Robert 教授：是的，作为实现者，这取决于你在什么时候将新的 commit 号发出。如果客户端请求很稀疏，那么 Leader 或许要发送一个心跳或者发送一条特殊的 AppendEntries 消息。如果客户端请求很频繁，那就无所谓了。因为如果每秒有 1000 个请求，那么下一条 AppendEntries 很快就会发出，你可以在下一条消息中带上新的 commit 号，而不用生成一条额外的消息。额外的消息代价还是有点高的，反正你要发送别的消息，可以把新的 commit 号带在别的消息里。
>
> 实际上，我不认为其他副本（非 Leader）执行客户端请求的时间很重要，因为没有人在等这个步骤。至少在不出错的时候，其他副本执行请求是个不太重要的步骤。例如说，客户端就没有等待其他副本执行请求，客户端只会等待 Leader 执行请求。所以，其他副本在什么时候执行请求，不会影响客户端感受的请求时延。
