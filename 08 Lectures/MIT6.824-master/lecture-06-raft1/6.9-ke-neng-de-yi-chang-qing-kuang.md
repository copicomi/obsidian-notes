# 6.9 可能的异常情况

一个旧 Leader 在各种奇怪的场景下故障之后，为了恢复系统的一致性，一个新任的 Leader 如何能整理在不同副本上可能已经不一致的 Log？

这个话题只在 Leader 故障之后才有意义，如果 Leader 正常运行，Raft 不太会出现问题。如果 Leader 正在运行，并且在其运行时，系统中有过半服务器。Leader 只需要告诉 Followers，Log 该是什么样子。Raft 要求 Followers 必须同意并接收 Leader 的 Log，这在 Raft 论文的图 2 中有说明。只要 Followers 还能处理，它们就会全盘接收 Leader 在 AppendEntries 中发送给它们的内容，并加到本地的 Log 中。之后再收到来自 Leader 的 commit 消息，在本地执行请求。这里很难出错。

在 Raft 中，当 Leader 故障了才有可能出错。例如，旧的 Leader 在发送消息的过程中故障了，或者新 Leader 在刚刚当选之后，还没来得及做任何操作就故障了。所以这里有一件事情我们非常感兴趣，那就是在一系列故障之后，Log 会是怎样？

这里有个例子，假设我们有 3 个服务器（S1，S2，S3），我将写出每个服务器的 Log，每一列对齐之后就是 Log 的一个槽位。我这里写的值是 Log 条目对应的任期号，而不是 Log 记录的客户端请求。所以第一列是槽位 1，第二列是槽位 2。所有节点在任期 3 的时候记录了一个请求在槽位 1，S2 和 S3 在任期 3 的时候记录了一个请求在槽位 2。在槽位 2，S1 没有任何记录。&#x20;

![](<../assets/image (39).png>)

所以，这里的问题是：这种情况可能发生吗？如果可能发生，是怎么发生的？

这种情况是可能发生的。假设 S3 是任期 3 的 Leader，它收到了一个客户端请求，之后发送给其他服务器。其他服务器收到了相应的 AppendEntries 消息，并添加 Log 到本地，这是槽位 1 的情况。之后，S3 从客户端收到了第二个请求，它还是需要将这个请求发送给其他服务器。但是这里有三种情况：

- 发送给 S1 的消息丢了
- S1 当时已经关机了
- S3 在向 S2 发送完 AppendEntries 之后，在向 S1 发送 AppendEntries 之前故障了

现在，只有 S2 和 S3 有槽位 2 的 Log。Leader 在发送 AppendEntries 消息之前，总是会将新的请求加到自己的 Log 中（所以 S3 有 Log），而现在 AppendEntries RPC 只送到了 S2（所以 S2 有 Log）。这是不同节点之间 Log 不一样的一种最简单的场景。我们现在知道了它是如何发生的。

如果现任 Leader S3 故障了，首先我们需要新的选举，之后某个节点会被选为新的 Leader。接下来会发生两件事情：

- 新的 Leader 需要认识到，槽位 2 的请求可能已经 commit 了，从而不能丢弃。
- 新的 Leader 需要确保 S1 在槽位 2 记录与其他节点完全一样的请求。

这里还有另外一个例子需要考虑。还是 3 个服务器，这次我会给 Log 的槽位加上数字，这样更方便我们后面说明。我们这里有槽位 10、11、12、13。槽位 10 和槽位 11 类似于前一个例子。在槽位 12，S2 有一个任期 4 的请求，而 S3 有一个任期 5 的请求。在我们分析之前，我们需要明白，发生了什么会导致这个场景？我们需要清楚这个场景是否真的存在，因为有些场景不可能存在我们也就没必要考虑它。所以现在的问题是，这种场景可能发生吗？

![](<../assets/image (40).png>)

这种场景是可能发生的。我们假设 S2 在槽位 12 时，是任期 4 的新 Leader，它收到了来自客户端的请求，将这个请求加到了自己的 Log 中，然后就故障了。

![](<../assets/image (41).png>)

因为 Leader 故障了，我们需要一次新的选举。我们来看哪个服务器可以被选为新的 Leader。这里 S3 可能被选上，因为它只需要从过半服务器获得认可投票，而在这个场景下，过半服务器就是 S1 和 S3。所以 S3 可能被选为任期 5 的新 Leader，之后收到了来自客户端的请求，将这个请求加到自己的 Log 中，然后故障了。之后就到了例子中的场景了。

![](<../assets/image (42).png>)

因为可能发生，Raft 必须能够处理这种场景。在我们讨论 Raft 会如何做之前，我们必须了解，怎样才是一种可接受的结果。大概看一眼这个图，我们知道在槽位 10 的 Log，3 个副本都有记录，它可能已经 commit 了，所以我们不能丢弃它。类似的在槽位 11 的 Log，因为它被过半服务器记录了，它也可能 commit 了，所以我们也不能丢弃它。在槽位 12 记录的两个 Log（分别是任期 4 和任期 5），都没有被 commit，所以 Raft 可以丢弃它们。这里没有要求必须都丢弃它们，但是至少需要丢弃一个 Log，因为最终你还是要保持多个副本之间的 Log 一致。

> 学生提问：槽位 10 和 11 的请求必然执行成功了吗？
>
> Robert 教授：对于槽位 11，甚至对于槽位 10，我们不能从 Log 中看出来 Leader 在故障之前到底执行到了哪一步。有一种可能是 Leader 在发送完 AppendEntries 之后就立刻故障了，所以 Leader 没能收到其他副本的确认，相应的请求也就不会 commit，进而也就不会执行这个请求，所以它也就不会发出增加了的 commit 值，其他副本也就可能也没有执行这个请求。所以完全可能槽位 10 和槽位 11 的请求没有被执行。如果 Raft 能知道这些，那么丢弃槽位 10 和槽位 11 的 Log 也是合法的，因为它们没有被 commit。但是从 Log 上看，没有办法否认这些请求被 commit 了。换句话说，这些请求可能 commit 了。所以 Raft 必须认为它们已经被 commit 了，因为完全有可能，Leader 是在对这些请求走完完整流程之后再故障。所以这里，我们不能排除 Leader 已经返回响应给客户端的可能性，只要这种可能性存在，我们就不能将槽位 10 和槽位 11 的 Log 丢弃，因为客户端可能已经知道了这个请求被执行了。所以我们必须假设这些请求被 commit 了。

我们会在下一节课继续这个话题。
