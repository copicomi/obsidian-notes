# 6.6 应用层接口

这一部分简单介绍一下应用层和 Raft 层之间的接口。你或许已经通过实验了解了一些，但是我们这里大概来看一下。假设我们的应用程序是一个 key-value 数据库，下面一层是 Raft 层。

![](<../assets/image (23).png>)

在 Raft 集群中，每一个副本上，这两层之间主要有两个接口。

第一个接口是 key-value 层用来转发客户端请求的接口。如果客户端发送一个请求给 key-value 层，key-value 层会将这个请求转发给 Raft 层，并说：请将这个请求存放在 Log 中的某处。

![](<../assets/image (24).png>)

这个接口实际上是个函数调用，称之为 Start 函数。这个函数只接收一个参数，就是客户端请求。key-value 层说：我接到了这个请求，请把它存在 Log 中，并在 committed 之后告诉我。

![](<../assets/image (25).png>)

另一个接口是，随着时间的推移，Raft 层会通知 key-value 层：哈，你刚刚在 Start 函数中传给我的请求已经 commit 了。Raft 层通知的，不一定是最近一次 Start 函数传入的请求。例如在任何请求 commit 之前，可能会再有超过 100 个请求通过 Start 函数传给 Raft 层。

![](<../assets/image (26).png>)

这个向上的接口以 go channel 中的一条消息的形式存在。Raft 层会发出这个消息，key-value 层要读取这个消息。所以这里有个叫做 applyCh 的 channel，通过它你可以发送 ApplyMsg 消息。

![](<../assets/image (27).png>)

当然，key-value 层需要知道从 applyCh 中读取的消息，对应之前调用的哪个 Start 函数，所以 Start 函数的返回需要有足够的信息给 key-value 层，这样才能完成对应。Start 函数的返回值包括，这个请求将会存放在 Log 中的位置（index）。这个请求不一定能 commit 成功，但是如果 commit 成功的话，会存放在这个 Log 位置。同时，它还会返回当前的任期号（term number）和一些其它我们现在还不太关心的内容。

![](<../assets/image (28).png>)

在 ApplyMsg 中，将会包含请求（command）和对应的 Log 位置（index）。

![](<../assets/image (29).png>)

所有的副本都会收到这个 ApplyMsg 消息，它们都知道自己应该执行这个请求，弄清楚这个请求的具体含义，并将它应用在本地的状态中。所有的副本节点还会拿到 Log 的位置信息（index），但是这个位置信息只在 Leader 有用，因为 Leader 需要知道 ApplyMsg 中的请求究竟对应哪个客户端请求（进而响应客户端请求）。

> 学生提问：为什么不在 Start 函数返回的时候就响应客户端请求呢？
>
> Robert 教授：我们假设客户端发送了任意的请求，我们假设这里是一个 Put 或者 Get 请求，是什么其实不重要，我们还是假设这里是个 Get 请求。客户端发送了一个 Get 请求，并且等待响应。当 Leader 知道这个请求被（Raft）commit 之后，会返回响应给客户端。所以这里会是一个 Get 响应。所以，（在 Leader 返回响应之前）客户端看不到任何内容。
>
> 这意味着，在实际的软件中，客户端调用 key-value 的 RPC，key-value 层收到 RPC 之后，会调用 Start 函数，Start 函数会立即返回，但是这时，key-value 层不会返回消息给客户端，因为它还没有执行客户端请求，它也不知道这个请求是否会被（Raft）commit。一个不能 commit 的场景是，当 key-value 层调用了 Start 函数，Start 函数返回之后，它就故障了，所以它必然没有发送 Apply Entry 消息或者其他任何消息，所以也不能执行 commit。
>
> 所以实际上，Start 函数返回了，随着时间的推移，对应于这个客户端请求的 ApplyMsg 从 applyCh channel 中出现在了 key-value 层。只有在那个时候，key-value 层才会执行这个请求，并返回响应给客户端。

有一件事情你们需要熟悉，那就是，首先，对于 Log 来说有一件有意思的事情：不同副本的 Log 或许不完全一样。有很多场合都会不一样，至少不同副本节点的 Log 的末尾，会短暂的不同。例如，一个 Leader 开始发出一轮 AppendEntries 消息，但是在完全发完之前就故障了。这意味着某些副本收到了这个 AppendEntries，并将这条新 Log 存在本地。而那些没有收到 AppendEntries 消息的副本，自然也不会将这条新 Log 存入本地。所以，这里很容易可以看出，不同副本中，Log 有时会不一样。

不过对于 Raft 来说，Raft 会最终强制不同副本的 Log 保持一致。或许会有短暂的不一致，但是长期来看，所有副本的 Log 会被 Leader 修改，直到 Leader 确认它们都是一致的。

接下来会有有关 Raft 的两个大的主题，一个是 Lab2 的内容：Leader Election 是如何工作的；另一个是，Leader 如何处理不同的副本日志的差异，尤其在出现故障之后。
