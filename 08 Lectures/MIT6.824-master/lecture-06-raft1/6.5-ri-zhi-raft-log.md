# 6.5 日志（Raft Log）

你们应该关心的一个问题是：为什么 Raft 系统这么关注 Log，Log 究竟起了什么作用？这个问题值得好好来回答一下。

Raft 系统之所以对 Log 关注这么多的一个原因是，Log 是 Leader 用来对操作排序的一种手段。这对于复制状态机（详见 4.2）而言至关重要，对于这些复制状态机来说，所有副本不仅要执行相同的操作，还需要用相同的顺序执行这些操作。而 Log 与其他很多事物，共同构成了 Leader 对接收到的客户端操作分配顺序的机制。比如说，我有 10 个客户端同时向 Leader 发出请求，Leader 必须对这些请求确定一个顺序，并确保所有其他的副本都遵从这个顺序。实际上，Log 是一些按照数字编号的槽位（类似一个数组），槽位的数字表示了 Leader 选择的顺序。

Log 的另一个用途是，在一个（非 Leader，也就是 Follower）副本收到了操作，但是还没有执行操作时。该副本需要将这个操作存放在某处，直到收到了 Leader 发送的新的 commit 号才执行。所以，对于 Raft 的 Follower 来说，Log 是用来存放临时操作的地方。Follower 收到了这些临时的操作，但是还不确定这些操作是否被 commit 了。我们将会看到，这些操作可能会被丢弃。

Log 的另一个用途是用在 Leader 节点，我（Robert 教授）很喜欢这个特性。Leader 需要在它的 Log 中记录操作，因为这些操作可能需要重传给 Follower。如果一些 Follower 由于网络原因或者其他原因短时间离线了或者丢了一些消息，Leader 需要能够向 Follower 重传丢失的 Log 消息。所以，Leader 也需要一个地方来存放客户端请求的拷贝。即使对那些已经 commit 的请求，为了能够向丢失了相应操作的副本重传，也需要存储在 Leader 的 Log 中。

所有节点都需要保存 Log 还有一个原因，就是它可以帮助重启的服务器恢复状态。你可能的确需要一个故障了的服务器在修复后，能重新加入到 Raft 集群，要不然你就永远少了一个服务器。比如对于一个 3 节点的集群来说，如果一个节点故障重启之后不能自动加入，那么当前系统只剩 2 个节点，那将不能再承受任何故障，所以我们需要能够重新并入故障重启了的服务器。对于一个重启的服务器来说，会使用存储在磁盘中的 Log。每个 Raft 节点都需要将 Log 写入到它的磁盘中，这样它故障重启之后，Log 还能保留。而这个 Log 会被 Raft 节点用来从头执行其中的操作进而重建故障前的状态，并继续以这个状态运行。所以，Log 也会被用来持久化存储操作，服务器可以依赖这些操作来恢复状态。

> 学生提问：假设 Leader 每秒可以执行 1000 条操作，Follower 只能每秒执行 100 条操作，并且这个状态一直持续下去，会怎样？
>
> Robert（教授）：这里有一点需要注意，Follower 在实际执行操作前会确认操作。所以，它们会确认，并将操作堆积在 Log 中。而 Log 又是无限的，所以 Follower 或许可以每秒确认 1000 个操作。如果 Follower 一直这么做，它会生成无限大的 Log，因为 Follower 的执行最终将无限落后于 Log 的堆积。 所以，当 Follower 堆积了 10 亿（不是具体的数字，指很多很多）Log 未执行，最终这里会耗尽内存。之后 Follower 调用内存分配器为 Log 申请新的内存时，内存申请会失败。Raft 并没有流控机制来处理这种情况。
>
> 所以我认为，在一个实际的系统中，你需要一个额外的消息，这个额外的消息可以夹带在其他消息中，也不必是实时的，但是你或许需要一些通信来（让 Follower）告诉 Leader，Follower 目前执行到了哪一步。这样 Leader 就能知道自己在操作执行上领先太多。所以是的，我认为在一个生产环境中，如果你想使用系统的极限性能，你还是需要一条额外的消息来调节 Leader 的速度。

![](<../assets/image (22).png>)

> 学生提问：如果其中一个服务器故障了，它的磁盘中会存有 Log，因为这是 Raft 论文中图 2 要求的，所以服务器可以从磁盘中的 Log 恢复状态，但是这个服务器不知道它当前在 Log 中的执行位置。同时，当它第一次启动时，它也不知道那些 Log 被 commit 了。
>
> Robert 教授：所以，对于第一个问题的答案是，一个服务器故障重启之后，它会立即读取 Log，但是接下来它不会根据 Log 做任何操作，因为它不知道当前的 Raft 系统对 Log 提交到了哪一步，或许有 1000 条未提交的 Log。
>
> 学生补充问题：如果 Leader 出现了故障会怎样？
>
> Robert 教授：如果 Leader 也关机也没有区别。让我们来假设 Leader 和 Follower 同时故障了，那么根据 Raft 论文图 2，它们只有 non-volatile 状态（也就是磁盘中存储的状态）。这里的状态包括了 Log 和最近一次任期号（Term Number）。如果大家都出现了故障然后大家都重启了，它们中没有一个在刚启动的时候就知道它们在故障前执行到了哪一步。所以这个时候，会先进行 Leader 选举，其中一个被选为 Leader。如果你回顾一下 Raft 论文中的图 2 有关 AppendEntries 的描述，这个 Leader 会在发送第一次心跳时弄清楚，整个系统中目前执行到了哪一步。Leader 会确认一个过半服务器认可的最近的 Log 执行点，这就是整个系统的执行位置。另一种方式来看这个问题，一旦你通过 AppendEntries 选择了一个 Leader，这个 Leader 会迫使其他所有副本的 Log 与自己保持一致。这时，再配合 Raft 论文中介绍的一些其他内容，由于 Leader 知道它迫使其他所有的副本都拥有与自己一样的 Log，那么它知道，这些 Log 必然已经 commit，因为它们被过半的副本持有。这时，按照 Raft 论文的图 2 中对 AppendEntries 的描述，Leader 会增加 commit 号。之后，所有节点可以从头开始执行整个 Log，并从头构造自己的状态。但是这里的计算量或许会非常大。所以这是 Raft 论文的图 2 所描述的过程，很明显，这种从头开始执行的机制不是很好，但是这是 Raft 协议的工作流程。下一课我们会看一种更有效的，利用 checkpoint 的方式。

所以，这就是普通的，无故障操作的时序。
