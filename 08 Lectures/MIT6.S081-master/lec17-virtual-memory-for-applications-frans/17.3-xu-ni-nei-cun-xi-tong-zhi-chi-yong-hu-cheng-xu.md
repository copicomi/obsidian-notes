# 17.3 虚拟内存系统如何支持用户应用程序

有关实现，有两个方面较为有趣。

第一个是虚拟内存系统为了支持这里的特性，具体会发生什么？这里我们只会讨论最重要的部分，并且它也与即将开始的 mmap lab 有一点相关，因为在 mmap lab 中你们将要做类似的事情。在现代的 Unix 系统中，地址空间是由硬件 Page Table 来体现的，在 Page Table 中包含了地址翻译。但是通常来说，地址空间还包含了一些操作系统的数据结构，这些数据结构与任何硬件设计都无关，它们被称为 Virtual Memory Areas（VMAs）。VMA 会记录一些有关连续虚拟内存地址段的信息。在一个地址空间中，可能包含了多个 section，每一个 section 都由一个连续的地址段构成，对于每个 section，都有一个 VMA 对象。连续地址段中的所有 Page 都有相同的权限，并且都对应同一个对象 VMA（例如一个进程的代码是一个 section，数据是另一个 section，它们对应不同的 VMA，VMA 还可以表示属于进程的映射关系，例如下面提到的 Memory Mapped File）。

![](<../assets/image (86).png>)

举个例子，如果进程有一个 Memory Mapped File，那么对于这段地址，会有一个 VMA 与之对应，VMA 中会包含文件的权限，以及文件本身的信息，例如文件描述符，文件的 offset 等。在接下来的 mmap lab 中，你们将会实现一个非常简单版本的 VMA，并用它来实现针对文件的 mmap 系统调用。你可以在 VMA 中记录 mmap 系统调用参数中的文件描述符和 offset。

第二个部分我们了解的就不多了，它或许值得仔细看一下，也就是 User level trap 是如何实现的？我们假设一个 PTE 被标记成 invalid 或者只读，而你想要向它写入数据。这时，CPU 会跳转到 kernel 中的固定程序地址，也就是 XV6 中的 trampoline 代码（注，详见 6.2）。kernel 会保存应用程序的状态，在 XV6 中是保存到 trapframe。之后再向虚拟内存系统查询，现在该做什么呢？虚拟内存系统或许会做点什么，例如在 lazy lab 和 copy-on-write lab 中，trap handler 会查看 Page Table 数据结构。而在我们的例子中会查看 VMA，并查看需要做什么。举个例子，如果是 segfault，并且应用程序设置了一个 handler 来处理它，那么

- segfault 事件会被传播到用户空间
- 并且通过一个到用户空间的 upcall 在用户空间运行 handler
- 在 handler 中或许会调用 mprotect 来修改 PTE 的权限
- 之后 handler 返回到内核代码
- 最后，内核再恢复之前被中断的进程。

![](<../assets/image (123).png>)

当内核恢复了中断的进程时，如果 handler 修复了用户程序的地址空间，那么程序指令可以继续正确的运行，如果哪里出错了，那么会通过 trap 再次回到内核，因为硬件还是不能翻译特定的虚拟内存地址。

> 学生提问：当我们允许用户针对 Page Fault 来运行 handler 代码时，这不会引入安全漏洞吗？
>
> Frans 教授：这是个很好的问题。会有安全问题吗？你们怎么想的？这会破坏 User/kernel 或者不同进程之间的隔离性吗？或者从另一个角度来说，你的问题是 sigalarm 会破坏隔离性吗？
>
> 当我们执行 upcall 的时候，upcall 会走到设置了 handler 的用户空间进程中，所以 handler 与设置了它的应用程序运行在相同的 context，相同的 Page Table 中。所以 handler 唯一能做的事情就是影响那个应用程序，并不能影响其他的应用程序，因为它不能访问其他应用程序的 Page Table，或者切换到其他应用程序的 Page Table。所以这里还好。
>
> 当然，如果 handler 没有返回，或者做了一些坏事，最终内核还是会杀掉进程。所以唯一可能出错的地方就是进程伤害了自己，但是它不能伤害任何其他进程。
