# 17.1 应用程序使用虚拟内存所需要的特性

今天的话题是用户应用程序使用的虚拟内存，它主要是受这篇 1991 年的[论文](https://pdos.csail.mit.edu/6.828/2020/readings/appel-li.pdf)的启发。

首先，你们已经知道了，操作系统内核以非常灵活的方式使用了虚拟内存 Page Table。你们已经通过 Lazy Allocation Lab，Copy on Write Lab，以及 XV6 中的各种内存实现了解到了这一点。而今天论文中的核心观点是，用户应用程序也应该从灵活的虚拟内存中获得收益，也就是说用户应用程序也可以使用虚拟内存。用户应用程序本身就是运行在虚拟内存之上，我们这里说的虚拟内存是指：User Mode 或者应用程序想要使用与内核相同的机制，来产生 Page Fault 并响应 Page Fault（注，详见 Lec08，内核中几乎所有的虚拟内存技巧都基于 Page Fault）。也就是说 User Mode 需要能够修改 PTE 的 Protection 位（注，Protection 位是 PTE 中表明对当前 Page 的保护，对应了 4.3 中的 Writeable 和 Readable 位）或者 Privileged level。今天的论文，通过查看 6-7 种不同的应用程序，来说明用户应用程序使用虚拟内存的必要性。这些应用程序包括了：

- Garbage Collector
- Data Compression Application
- Shared Virtual Memory

![](<../assets/image (3).png>)

你可以发现这都是一些非常不同的应用程序，并且它们都依赖虚拟内存的一些特性来正常工作。所以第一个问题是，上面的应用程序需要的特性是什么？所以我们先来讨论一下需要的特性是什么？

- 首先，你需要 trap 来使得发生在内核中的 Page Fault 可以传播到用户空间，然后在用户空间的 handler 可以处理相应的 Page Fault，之后再以正常的方式返回到内核并恢复指令的执行。这个特性是必须的，否则的话，你不能基于 Page Fault 做任何事情。
- 第二个特性是 Prot1，它会降低了一个内存 Page 的 accessability。accessability 的意思是指内存 Page 的读写权限。内存 Page 的 accessability 有不同的降低方式，例如，将一个可以读写的 Page 变成只读的，或者将一个只读的 Page 变成完全没有权限。
- 除了对于每个内存 Page 的 Prot1，还有管理多个 Page 的 ProtN。ProtN 基本上等效于调用 N 次 Prot1，那为什么还需要有 ProtN？因为单次 ProtN 的损耗比 Prot1 大不了多少，使用 ProtN 可以将成本分摊到 N 个 Page，使得操作单个 Page 的性能损耗更少。在使用 Prot1 时，你需要修改 PTE 的 bit 位，并且在 Prot1 的结束时，需要清除 TLB（注，详见 4.4 Translation Lookaside Buffer），而清除 TLB 比较费时。如果能对所有需要修改的内存 Page 集中清理一次 TLB，就可以将成本分摊。所以 ProtN 等效于修改 PTE 的 bit 位 N 次，再加上清除一次 TLB。如果执行了 N 次 Prot1，那就是 N 次修改 PTE 的 bit 位，再加上清除 N 次 TLB，所以 ProtN 可以减少清除 TLB 的次数，进而提升性能。
- 下一个特性是 Unprot，它增加了内存 Page 的 accessability，例如将本来只读的 Page 变成可读可写的。
- 除此之外，还需要能够查看内存 Page 是否是 Dirty。
- 以及 map2。map2 使得一个应用程序可以将一个特定的内存地址空间映射两次，并且这两次映射拥有不同的 accessability（注，也就是一段物理内存对应两份虚拟内存，并且两份虚拟内存有不同的 accessability）。

![](<../assets/image (756).png>)

XV6 在用户程序中支持以上任意的特性吗？除了有类似于 trap 及其相关的 alarm hander 之外，XV6 不支持任何一个以上的特性。XV6 只有一个最小化的 Unix 接口，并不支持以上任何虚拟内存特性。尽管在 XV6 的内核中包含了所有的可用的虚拟内存的机制，但是并没有以系统调用的形式将它们暴露给用户空间。论文的观点是，任何一个好的操作系统都应该以系统调用的形式提供以上特性，以供应用程序使用。

所以自然的，这就引出了另一个问题，当今的 Unix 系统的功能范围是什么？以上特性属于 Unix 的范畴吗？如果你查看现在的 Unix 系统，例如 Linux，你会发现，或许并不与论文中描述的完全一样，但是这些特性都存在。在论文那个年代（1991 年），某些操作系统只包含了部分以上特性，但是如今这些特性都已经在现代的 Unix 系统中广泛支持了。接下来我们看一下如何实现这些特性。
