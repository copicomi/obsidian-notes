# 17.2 支持应用程序使用虚拟内存的系统调用

第一个或许也是最重要的一个，是一个叫做 mmap 的系统调用。它接收某个对象，并将其映射到调用者的地址空间中。举个例子，如果你想映射一个文件，那么你需要将文件描述符传递给 mmap 系统调用。mmap 系统调用有许多令人眼花缭乱的参数（注，mmap 的具体说明可以参考[man page](https://man7.org/linux/man-pages/man2/mmap.2.html)）：

- 第一个参数是一个你想映射到的特定地址，如果传入 null 表示不指定特定地址，这样的话内核会选择一个地址来完成映射，并从系统调用返回。
- 第二个参数是想要映射的地址段长度 len。
- 第三个参数是 Protection bit，例如读写 R|W。
- 第四个参数我们会跳过不做讨论，它的值可以是 MAP_PRIVATE。它指定了如果你更新了传入的对象，会发生什么。（注，第四个参数是 flags，MAP_PRIVATE 是其中一个值，在 mmap 文件的场景下，MAP_PRIVATE 表明更新文件不会写入磁盘，只会更新在内存中的拷贝，详见[man page](https://man7.org/linux/man-pages/man2/mmap.2.html)）。
- 第五个参数是传入的对象，在上面的例子中就是文件描述符。
- 第六个参数是 offset。

![](<../assets/image (142).png>)

通过上面的系统调用，可以将文件描述符指向的文件内容，从起始位置加上 offset 的地方开始，映射到特定的内存地址（如果指定了的话），并且连续映射 len 长度。这使得你可以实现 Memory Mapped File，你可以将文件的内容带到内存地址空间，进而只需要方便的通过普通的指针操作，而不用调用 read/write 系统调用，就可以从磁盘读写文件内容。这是一个方便的接口，可以用来操纵存储在文件中的数据结构。实际上，你们将会在下个 lab 实现基于文件的 mmap，下个 lab 结合了 XV6 的文件系统和虚拟内存，进而实现 mmap。

mmap 还可以用作他途。除了可以映射文件之外，还可以用来映射匿名的内存（Anonymous Memory）。这是 sbrk（注，详见 8.2）的替代方案，你可以向内核申请物理内存，然后映射到特定的虚拟内存地址。

mmap 是实现应用程序虚拟内存的核心系统调用之一，我们稍后会将它与之前提到的特性关联起来。

![](<../assets/image (53).png>)

除此之外，还需要有一些系统调用来支持论文中讨论到的特性。

mprotect 系统调用（注，详见[man page](https://man7.org/linux/man-pages/man2/mprotect.2.html)）。当你将某个对象映射到了虚拟内存地址空间，你可以修改对应虚拟内存的权限，这样你就可以以特定的权限保护对象的一部分，或者整个对象。

![](<../assets/image (48).png>)

举个例子，通过上图对于 mprotect 的调用将权限设置成只读（R），这时，对于 addr 到 addr+len 这段地址，load 指令还能执行，但是 store 指令将会变成 Page Fault。类似的，如果你想要将一段地址空间变成完成不可访问的，那么可以在 mprotect 中的权限参数传入 None，那么任何对于 addr 到 addr+len 这段地址的访问，都会生成 Page Fault。

对应 mmap 还有一个系统调用 munmap，它使得你可以移除一个地址或者一段内存地址的映射关系。如果你好奇这里是怎么工作的，你应该查看这些系统调用的[man page](https://man7.org/linux/man-pages/man2/)。

![](<../assets/image (23).png>)

最后一个系统调用是 sigaction，它本质上是用来处理 signal。它使得应用程序可以设置好一旦特定的 signal 发生了，就调用特定的函数。可以给它传入函数 f 作为特定 signal 的 handler。在 Page Fault 的场景下，生成的 signal 是 segfault。你或许之前在用户代码中看过了 segfault，通常来说当发生 segfault 时，应用程序会停止运行并 crash。但是如果应用程序为 segfault signal 设置了 handler，发生 segfault 时，应用程序不会停止，相应的 handler 会被内核调用，然后应用程序可以在 handler 中响应 segfault。

当内核发现 Page Fault 时，或许会通过修复 Page Table 来使得应用程序还能继续执行。与内核响应 Page Fault 的方式类似，在这里的 handler 中或许会调用 mprotect 来修改内存的权限来避免 segfault，这样应用程序的指令就可以恢复运行。

![](<../assets/image (127).png>)

与 sigaction 类似的有 sigalarm（译注：sigalarm 是[traps lab](https://pdos.csail.mit.edu/6.S081/2020/labs/traps.html) 中实现的一个系统调用，不属于标准 Unix 接口），在 sigalarm 中可以设置每隔一段时间就调用 handler。sigaction 也可以实现这个功能，只是它更加的通用，因为它可以响应不同类型的 signal。

> 学生提问：看起来 mprotect 暗示了你可以为单独的地址添加不同的权限，然而在 XV6 中，我们只能为整个 Page 设置相同的权限，这里是有区别吗？
>
> Frans 教授：不，这里并没有区别，它们都在 Page 粒度工作。如果你好奇的话，有一个单独的系统调用可以查看 Page 的大小。

如果你回想前面提到过的虚拟内存特性，我们可以将它们对应到这一节描述的 Unix 接口中来。

- trap 对应的是 sigaction 系统调用
- Prot1，ProtN 和 Unprot 可以使用 mprotect 系统调用来实现。mprotect 足够的灵活，你可以用它来修改一个 Page 的权限，也可以用它来修改多个 Page 的权限。当修改多个 Page 的权限时，可以获得只清除一次 TLB 的好处。
- 查看 Page 的 Dirty 位要稍微复杂点，并没有一个直接的系统调用实现这个特性，不过你可以使用一些技巧完成它，我稍后会介绍它。
- map2 也没有一个系统调用能直接对应它，通过多次调用 mmap，你可以实现 map2 特性。

或许并不完全受这篇论文所驱动，但是内核开发人员已经在操作系统中为现在的应用程序提供了这些特性。接下来，我将在框架层面简单介绍一下这些特性是如何实现的，之后再看看应用程序是如何使用这些特性。
