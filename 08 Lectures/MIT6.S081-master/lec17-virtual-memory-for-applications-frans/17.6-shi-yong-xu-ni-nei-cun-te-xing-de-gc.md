# 17.6 使用虚拟内存特性的 GC

论文中介绍，如果拥有了前面提到的虚拟内存特性，你可以使用虚拟内存来减少指针检查的损耗，并且以几乎零成本的代价来并行运行 GC。这里的基本思想是将 heap 内存中 from 和 to 空间，再做一次划分，每一个部分包含 scanned，unscanned 两个区域。在程序启动，或者刚刚完成了 from 和 to 空间的切换时，整个空间都是 unscanned，因为其中还没有任何对象。

之后的过程与前面描述的相同，在开始 GC 时，我们将根节点对象拷贝到 to 空间，但是根节点中的指针还是指向了位于 from 空间的对象。现在 unscanned 区域包括了所有的对象（注，现在只有根节点），我们会将 unscanned 区域的权限设置为 None。这意味着，当开始 GC 之后，应用程序第一次使用根节点，它会得到 Page Fault，因为这部分内存的权限为 None。

![](<../assets/image (101).png>)

在 Page Fault Handler 中，GC 需要扫描位于内存 Page 中所有的对象，然后将这些对象所指向的其他对象从 from 空间 forward 到 to 空间。所以，在 GC 最开始的时候，我们将根节点拷贝过来了；之后在 Page Fault Handler 中通过扫描，将根节点指向的对象也都拷贝过来了。在我们的例子中根节点指向的只有两个对象，这两个对象会被拷贝到 unscanned 区域中，而根节点会被标记成 scanned。在我们扫描完一个内存 Page 中的对象时，我们可以通过 Unprot（注，详见 17.1）恢复对应内存 Page 的权限。

![](<../assets/image (116).png>)

之后，应用程序就可以访问特定的对象，因为我们将对象中的指针转换成了可以安全暴露给应用程序的指针（注，因为这些指针现在指向了位于 to 空间的对象），所以应用程序可以访问这些指针。当然这些指针对应的对象中还没有被扫描。如果 dereference 这些指针，我们会再次得到 Page Fault，之后我们会继续扫描。

这种方案的好处是，它仍然是递增的 GC，因为每次只需要做一小部分 GC 的工作。除此之外，它还有额外的优势：现在不需要对指针做额外的检查了（注，也就是不需要查看指针是不是指向 from 空间，如果是的话，将其 forward 到 to 空间）。或者说指针检查还在，只是现在通过虚拟内存相关的硬件来完成了。

![](<../assets/image (60).png>)

> 学生提问：刚刚说到在 Handler 里面会扫描一个 Page 中的所有对象，但是对象怎么跟内存 Page 对应起来呢？
>
> Frans 教授：在最开始的时候，to 空间是没有任何对象的。当需要 forward 的时候，我刚刚描述的是拷贝一个对象，但是实际上拷贝的是一个内存 Page 中的 N 个对象，这样它们可以填满整个 Page。所以现在我们在 to 空间中，有 N 个对象位于一个 Page 中，并且它们都没有被扫描。之后某个时间，Page Fault Handler 会被调用，GC 会遍历这个内存 Page 上的 N 个对象，并检查它们的指针。对于这些指针，GC 会将对应的对象拷贝到 to 空间的 unscanned 区域中。之后，当应用程序使用了这些未被扫描的对象，它会再次得到 Page Fault，进而再扫描这些对象，以此类推。
>
> 学生提问：在完成了 GC 之后，会切换 from 和 to 空间吗？
>
> Frans 教授：最开始我们使用的是 from 空间，当用完了的时候，你会将对象拷贝到 to 空间，一旦完成了扫描，from 空间也被完全清空了，你可以切换两个空间的名字。现在会使用 to 空间来完成内存分配。直到它也满了，你会再次切换。

论文中提到使用虚拟内存的另一个好处是，它简化了 GC 的并发。GC 现在可以遍历未被扫描的内存 Page，并且一次扫描一个 Page，同时可以确保应用程序不能访问这个内存 Page，因为对于应用程序来说，未被扫描的内存 Page 权限为 None。虚拟内存硬件引入了这种显式的同步机制，或者说对于抢占的保护。

现在只有 GC 可以访问未被扫描的内存 Page，而应用程序不能访问。所以这里提供了自动的并发，应用程序可以运行并完成它的工作，GC 也可以完成自己的工作，它们不会互相得罪，因为一旦应用程序访问了一个未被扫描的 Page，它就会得到一个 Page Fault。而 GC 也永远不会访问扫描过的 Page，所以也永远不会干扰到应用程序。所以这里以近乎零成本获取到了并发性。

但是实际上有个麻烦的问题。回到我们之前那张图，我们在 heap 中有 from 空间，to 空间。在 to 空间中又分为了 unscanned 和 scanned 区域，对于应用程序来说，unscanned 区域中的 Page 权限为 None。

![](<../assets/image (30).png>)

这就引出了另一个问题，GC 怎么能访问这个区域的内存 Page？因为对于应用程序来说，这些 Page 是 inaccessible。

这里的技巧是使用 map2（注，详见 17.1）。这里我们会将同一个物理内存映射两次，第一次是我们之前介绍的方式，也就是为应用程序进行映射，第二次专门为 GC 映射。在 GC 的视角中，我们仍然有 from 和 to 空间。在 to 空间的 unscanned 区域中，Page 具有读写权限。

![](<../assets/image (66).png>)

所以 GC 可以遍历这些内存 Page，读取内容并 forward 必要的对象。这里使用了 map2 将物理内存映射到应用程序地址空间中两次的能力，其中每次映射都有不同的权限，这样这里的场景才能工作。

> 学生提问：GC 和应用程序是不是有不同的 Page Table？
>
> Frans 教授：不，它们拥有相同的 Page Table。它们只是将物理内存映射到了地址空间的两个位置，也就是 Page Table 的两个位置。在一个位置，PTE 被标记成 invalid，在另一个位置，PTE 被标记成可读写的。
