# 17.7 使用虚拟内存特性的 GC 代码展示

为了更清晰的说明上一节的内容，我这里有个针对论文中方法的简单实现，我可以肯定它包含了一些 bug，因为我并没有认真的测试它。

首先，应用程序使用的 API 包括了 new 和 readptr。

![](<../assets/image (117).png>)

readptr 会检查指针是否位于 from 空间，如果是的话，那么它指向的对象需要被拷贝。当然，当我们使用虚拟内存时，这里的 readptr 成本会比较低，它会直接返回参数。在这个简单的例子中，我有一个循环链表，并且有两个根节点，其中一个指向链表的头节点，另一个指向链表的尾节点。

应用程序线程的工作是循环 1000 次，每次创建 list，再检查 list。

![](<../assets/image (102).png>)

所以它会产生大量的垃圾，因为每次 make_clist 完成之后，再次 make_clist，上一个 list 就成为垃圾了。所以 GC 必然会有一些工作要做。

make_clist 的代码有点丑，主要是因为每个指针都需要被 readptr 检查包围。通常这里的检查代码是由编译器生成的。但是我这里并没有一个针对带 GC 的编程语言的编译器，所以我只能模仿一个编译器可能生成的内容。

![](<../assets/image (78).png>)

make_clist 会构建一个 LISTSZ 大小的链表，分配新的元素，并将新元素加到链表的起始位置，之后更新链表尾指针指向链表新的起始位置，这样就能构成一个循环链表。

这里更有趣的部分是，GC 部分怎么实现。首先让我们看看如果没有虚拟内存会怎样。我们只需要查看两个 API：new 和 readptr。

![](<../assets/image (90).png>)

以上就是 new 的实现，先不考虑这里的 mutex，因为这是为基于虚拟内存的实现提供的。先假设我们不需要扫描，也不需要 collect。接下来会检查是否有足够的空间，如果有足够的空间，我们就将指针地址增加一些，以分配内存空间给新的对象，最后返回。

如果没有足够的空间，我们需要调用 flip，也就是运行 GC。

![](<../assets/image (38).png>)

flip 首先会切换 from 和 to 指针，之后将这个应用程序的两个根节点从 from 空间 forward 到 to 空间。接下来我们看一下 forward 函数。

![](<../assets/image (72).png>)

这个函数会 forward 指针 o 指向的对象，首先检查指针 o 是不是在 from 空间，如果是的话，并且之前没有被拷贝过，那么就将它拷贝到 to 空间。如果之前拷贝过，那么就可以用 to 空间的指针代替对象指针，并将其返回。

![](<../assets/image (769).png>)

对于 readptr，如果我们没有使用虚拟内存。会对指针 p 做 forward 操作，forward 操作的意思是如果对象在 from 空间，那么就将其拷贝到 to 空间，所以这里会有耗时的检查。

接下来我们看一下这里如何使用虚拟内存。

![](<../assets/image (91).png>)

首先是设置内存，通过[shm_open](https://man7.org/linux/man-pages/man3/shm_open.3.html)创建一个 Share-memory object，shm_open 是一个 Linux/Uinx 系统调用。Share-memory object 表现的像是一个文件，但是它并不是一个文件，它位于内存，并没有磁盘文件与之对应，如果你愿意的话，可以认为它是一个位于内存的文件系统。

之后我们裁剪这个 Shared-memory object 到 from 和 to 空间的大小。

之后我们通过 mmap 先将其映射一次，以供 mutator 也就是实际的应用程序使用。然后再映射一次，以供 GC 使用。这里 shm_open，ftruncate，和两次 mmap，等效于 map2。

回过去看之前的代码，

![](<../assets/image (13).png>)

使用了虚拟内存之后，readptr 将不做任何事情，直接将参数返回。当然，如果我们使用这里的指针，并且指针对应的对象位于 unscanned 区域，我们会得到 Page Fault。

![](<../assets/image (71).png>)

在 Page Fault hanlder 中，GC 会运行 scan 函数。但是 scan 函数是以 GC 对应的 PTE 来运行的，所以它能工作。而同时，应用程序或者 mutator 不能访问这些 Page，如果访问了的话，这会产生 Page Fault。一旦 scan 执行完成，handler 中会将 Page 设置成对应用程序可访问的（注，也就是调用 mprotect）。

在 flip 函数中，

![](<../assets/image (38).png>)

完成 from 和 to 空间的切换时，如果使用了虚拟内存，我们会通过 mprotect 将整个 to 空间对应用程序标记成不可访问的。之后 GC 将 root_head 和 root_last 移到 to 空间中，这样应用程序就不能访问这两个对象，任何时候应用程序需要访问这两个对象，都会导致一个 Page Fault。在 Page Fault handler 中，GC 可以将其他对象从 from 空间拷贝到 to 空间，然后再 Unprot 对应的 Page。

在 Page Fault handler 中，先 scan 内存 Page，再将内存 Page 标记成对应用程序可访问的这个顺序是至关重要的。因为如果你先将内存 Page 标记成应用程序可访问的，然后再扫描它，如果有多个应用程序线程，那么应用程序可能会查看到 unscanned 区域的对象。当然我们要禁止这一点（注，因为为了避免抢占，unscanned 区域只能 GC 访问），所以这里的代码是先扫描，再增加内存的访问权限，这样应用程序就可以安全的访问这些内存 Page。

接下来，我总结一下这节课的内容。有一个问题，你应该在这里使用虚拟内存吗？或者说这里的这些技巧值得吗？许多的 GC 并没有使用虚拟内存，而是通过编译器生成的代码来完成 GC，并且还有各种其他的技巧来减少性能损耗。所以 GC 的大部分场景都可以通过一些额外的指令来完成。这对于一个编译器，程序运行时，或者编程语言来说，并不是一个太糟糕的选择，因为编译器就可以完成这些操作。但是如果没有程序运行时或者编译器，那么这个过程就会很痛苦。所以对于一些完全没有编译器参与的应用程序，例如 checkpointing，shared-virtual memory，它们的确需要这里提到的虚拟内存特性。实际中，足够多的应用程序开发人员发现了这些特性的价值，所以今天的操作系统都支持了这些虚拟内存特性。

![](<../assets/image (34).png>)

很多人问了这个问题，从 91 年（论文发表的年份）至今，虚拟内存系统发生了什么改变？其中一个改变是，大部分的 Unix 系统都支持了这些虚拟内存特性了，并且从 91 年至今有许多变化。或许很难想象，但是在虚拟内存系统中有持续的开发，所以如果你查看 Linux 的 git log，你可以发现在内核的各个方面都有持续的开发，其中包括了对虚拟内存系统的持续开发。在过去有一些重大的改变，比如说：

- 现在的 Page Table 是 5 级的，这样可以处理非常大的地址
- 可以通过地址空间标识符来处理 TLB flush
- 大概一年前，一种叫做 KPTI（kernel page table isolation）的功能被引入，它是针对 Meltdown attack 的功能

虚拟内存系统绝对不是一个静态的系统，几乎 Linux 内核的所有方向都不是静态的。几乎每两个月在内核的不同方向都会有大量的更新。所以每个子系统时不时的就会被重写。

![](<../assets/image (21).png>)

> 学生提问：VMA 中的连续地址是什么意思？
>
> Frans 教授：这里是指连续的虚拟内存地址，比如说一个 VMA 表示 1000-2000 这段地址。如果你有另一段地址，2100-2200，那么它会有属于自己的 VMA。所以每个 VMA 覆盖了一段连续的地址，中间不会有中断。你们将会在 mmap lab 中看到这样的设计是更加的合理的。你们可以认为对于每个 mmap 系统调用，如果地址没有重叠的话，都会有一个 VMA。
>
> 学生提问：GC 什么时候会停止，什么时候又会再开始？我认为 GC 可以一直运行，如果它是并发的。
>
> Frans 教授：是的，基于虚拟内存的解决方案一个酷的地方在于，GC 可以一直运行。它可以在没有 unscanned 对象时停止。
>
> 学生提问：但是你需要遍历所有在 from 空间的对象，你怎么知道已经遍历了所有的对象呢？&#x20;
>
> Frans 教授：你会从根节点开始扫描整个对象的图，然后拷贝到 to 空间。在某个时间点，你不再添加新的对象了，因为所有的对象已经被拷贝过了。当你不再添加新的对象，你的 unscanned 区域就不再增长，如果它不再增长，那么你就遍历了所有的对象（注，可以想象一个普通的 DFS 或者 BFS 过程）。
