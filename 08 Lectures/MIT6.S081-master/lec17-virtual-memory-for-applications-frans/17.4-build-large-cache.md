# 17.4 构建大的缓存表

接下来，我将通过介绍几个例子来看一下如何使用之前介绍的内容。我会从一个非常简单的例子开始，之后我们会看一下 Garbage Collector，因为很多同学都问了 Garbage Collector 的问题，所以 GC 是一个可以深入探讨的好话题。

首先我想讨论的是一个非常简单的应用，它甚至都没有在论文中提到，但它却是展示这节课的内容非常酷的一个方法。这个应用里是构建一个大的缓存表，什么是缓存表？它是用来记录一些运算结果的表单。举个例子，你可以这么想，下面是我们的表单，它从 0 开始到 n。表单记录的是一些费时的函数运算的结果，函数的参数就是 0 到 n 之间的数字。

![](<../assets/image (149).png>)

如果这个表单在最开始的时候就预计算好了，那么当你想知道 f(i)的结果是什么时，你需要做的就是查看表单的 i 槽位，并获取 f(i)的值。这样你可以将一个费时的函数运算转变成快速的表单查找，所以这里一个酷的技巧就是预先将费时的运算结果保存下来。如果相同的计算需要运行很多很多次，那么预计算或许是一个聪明的方案。

![](<../assets/image (155).png>)

这里的挑战是，表单可能会很大，或许会大过物理内存，这里可以使用论文提到的虚拟内存特性来解决这个挑战。

首先，你需要分配一个大的虚拟地址段，但是并不分配任何物理内存到这个虚拟地址段。这里只是从地址空间获取了很大一段地址，并说我将要使用地址空间的这部分来保存表单。

但是现在表单中并没有内容，表单只是一段内存地址。如果你现在查找表单的 i 槽位，会导致 Page Fault。所以这里的计划是，在发生 Page Fault 时，先针对对应的虚拟内存地址分配物理内存 Page，之后计算 f(i)，并将结果存储于 tb\[i]，也就是表单的第 i 个槽位，最后再恢复程序的运行。

这种方式的优势是，如果你需要再次计算 f(i)，你不需要在进行任何费时的计算，只需要进行表单查找。即使接下来你要查找表单的 i+1 槽位，因为一个内存 Page 可能可以包含多个表单项，这时也不用通过 Page Fault 来分配物理内存 Page。

![](<../assets/image (39).png>)

不过如果你一直这么做的话，因为表单足够大，你最终还是会消耗掉所有的物理内存。所以 Page Fault Handler 需要在消耗完所有的内存时，回收一些已经使用过的物理内存 Page。当然，你需要修改已经被回收了的物理内存对应的 PTE 的权限，这样在将来使用对应地址段时，就可以获得 Page Fault。所以你需要使用 Prot1 或者 ProtN 来减少这些 Page 的 accessbility。

![](<../assets/image (26).png>)

> 学生提问：在分配物理内存 Page 时，我们需要让操作系统映射到地址空间的特定地址，否则的话可能会映射到任意地址，是吧？
>
> Frans 教授：操作系统会告知是哪个地址，并且这里可能是任意的地址。

为了更具体的描述这里的应用，我这里有个小的实现，我们可以看一看这里是如何使用现有的 Unix 特性。

![](<../assets/image (154).png>)

在 main 函数中，首先调用 setup_sqrt_region 函数，它会从地址空间分配地址段，但是又不实际分配物理 Page。之后调用 test_sqrt_region。

![](<../assets/image (134).png>)

在 test_sqrt_region 中，会以随机数来遍历表单，并通过实际运算对应的平方根值，来检查表单中相应位置值是不是保存了正确的平方根值。在 test_sqrt_region 运行的过程中，会产生 Page Fault，因为现在还并没有分配任何物理内存 Page。

应用程序该如何收到 Page Fault 呢？

![](<../assets/image (104).png>)

在 setup_sqrt_region 函数中有一段代码，通过将 handle_sigsegv 函数注册到了 SIGSEGV 事件。这样当 segfault 或者 Page Fault 发生时，内核会调用 handle_sigsegv 函数。

![](<../assets/image (56).png>)

handle_sigsegv 函数与你们之前看过很多很多次的 trap 代码非常相似。

- 它首先会获取触发 Page Fault 的地址，
- 之后调用 mmap 对这个虚拟内存地址分配一个物理内存 Page（注，这里是 mmap 映射匿名内存）。这里的虚拟内存地址就是我们想要在表单中用来保存数据的地址。
- 然后我们为这个 Page 中所有的表单项都计算对应的平方根值，之后就完事了。

这个应用程序有点极端，它在运行的时候只会使用一个物理内存 Page，所以不论上一次使用的 Page 是什么，在 handle_sigsegv 的最后都会通过 munmap 释放它。所以我们有一个巨大的表单，但是它只对应一个物理内存 Page。

接下来我将运行一下这个应用程序。test_sqrt_region 会随机查看表单的内容，所以可以假设这会触发很多 Page Fault，但是可以看出表单中的所有内容都能通过检查。

![](<../assets/image (97).png>)

所以，尽管这里有一个巨大的表单用来保存平方根，但是实际在物理内存中只有一个内存 Page。这是一个简单的例子，它展示了用户应用程序使用之前提到的虚拟内存特性之后可以做的一些酷的事情。

> 学生提问：能再讲一下为什么一个物理内存 Page 就可以工作吗？我觉得这像是 lazy allocation，但是区别又是什么呢？
>
> Frans 教授：当我们刚刚完成设置时，我们一个内存 Page 都没有，setup_sqrt_region 分配了一个地址段，但是又立即通过 munmap 将与这个地址段关联的内存释放了。所以在启动的最开始对于表单并没有一个物理内存 Page 与之关联。
>
> 之后，当我们得到了一个 Page Fault，这意味着整个表单对应的地址中至少有一个 Page 没有被映射，虽然实际上我们一个 Page 都没有映射。现在我们得到了一个 Page Fault，我们只需要映射一个 Page，在这个 Page 中，我们会存入 i，i+1。。。的平方根（注，因为一个 Page4096 字节，一个 double8 个字节，所以一个 Page 可以保存 512 个表单项）。
>
> 因为这是第一个 Page Fault，之前并没有映射了内存 Page，所以不需要做任何事情。
>
> 之后，程序继续运行并且查找了表单中的更多项，如果查找一个没有位于已分配 Page 上的表单项时，会得到另一个 Page Fault。这时，在 handle_sigsegv 会分配第二个内存 Page，并为这个 Page 计算平方根的值。之后会 munmap 记录在 last_page_base 中的内存。
>
> 当然，在实际中我们永远也不会这么做，在实际中至少会保留一些内存 Page，这里只是以一种极端的方式展示，你可以只通过内存中的一个 Page 来表示一个巨大的表单。所以在 handle_sigsegv 中，会释放上一次映射的内存 Page。
>
> 之后程序继续运行，所以在任何一个时间，只有一个物理内存 Page 被使用了。很明显，你们在实际中不会这么做，这里更多的是展示前面提到特性的能力。
