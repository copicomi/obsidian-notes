# 3.7 编译运行 kernel

接下来我会切换到代码介绍，来看一下 XV6 是如何工作的。

首先，我们来看一下代码结构，你们或许已经看过了。代码主要有三个部分组成：

![](<../assets/image (195).png>)

- 第一个是 kernel。我们可以 ls kernel 的内容，里面包含了基本上所有的内核文件。因为 XV6 是一个宏内核结构，这里所有的文件会被编译成一个叫做 kernel 的二进制文件，然后这个二进制文件会被运行在 kernle mode 中。

![](<../assets/image (395).png>)

- 第二个部分是 user。这基本上是运行在 user mode 的程序。这也是为什么一个目录称为 kernel，另一个目录称为 user 的原因。
- 第三部分叫做 mkfs。它会创建一个空的文件镜像，我们会将这个镜像存在磁盘上，这样我们就可以直接使用一个空的文件系统。

接下来，我想简单的介绍一下内核是如何编译的。你们可能已经编译过内核，但是还没有真正的理解编译过程，这个过程还是比较重要的。

首先，Makefile（XV6 目录下的文件）会读取一个 C 文件，例如 proc.c；之后调用 gcc 编译器，生成一个文件叫做 proc.s，这是 RISC-V 汇编语言文件；之后再走到汇编解释器，生成 proc.o，这是汇编语言的二进制格式。

![](<../assets/image (91) (1).png>)

Makefile 会为所有内核文件做相同的操作，比如说 pipe.c，会按照同样的套路，先经过 gcc 编译成 pipe.s，再通过汇编解释器生成 pipe.o。

![](<../assets/image (370).png>)

之后，系统加载器（Loader）会收集所有的.o 文件，将它们链接在一起，并生成内核文件。

![](<../assets/image (272).png>)

这里生成的内核文件就是我们将会在 QEMU 中运行的文件。同时，为了你们的方便，Makefile 还会创建 kernel.asm，这里包含了内核的完整汇编语言，你们可以通过查看它来定位究竟是哪个指令导致了 Bug。比如，我接下来查看 kernel.asm 文件，我们可以看到用汇编指令描述的内核：

![](<../assets/image (318).png>)

这里你们可能已经注意到了，第一个指令位于地址 0x80000000，对应的是一个 RISC-V 指令：auipc 指令。有人知道第二列，例如 0x0000a117、0x83010113、0x6505，是什么意思吗？有人想来回答这个问题吗？

> 学生回答：这是汇编指令的 16 进制表现形式对吗？

是的，完全正确。所以这里 0x0000a117 就是 auipc，这里是二进制编码后的指令。因为每个指令都有一个二进制编码，kernel 的 asm 文件会显示这些二进制编码。当你在运行 gdb 时，如果你想知道具体在运行什么，你可以看具体的二进制编码是什么，有的时候这还挺方便的。

接下来，让我们不带 gdb 运行 XV6（make 会读取 Makefile 文件中的指令）。这里会编译文件，然后调用 QEMU（qemu-system-riscv64 指令）。这里本质上是通过 C 语言来模拟仿真 RISC-V 处理器。

![](<../assets/image (199).png>)

我们来看传给 QEMU 的几个参数：

- \-kernel：这里传递的是内核文件（kernel 目录下的 kernel 文件），这是将在 QEMU 中运行的程序文件。
- \-m：这里传递的是 RISC-V 虚拟机将会使用的内存数量
- \-smp：这里传递的是虚拟机可以使用的 CPU 核数
- \-drive：传递的是虚拟机使用的磁盘驱动，这里传入的是 fs.img 文件

这样，XV6 系统就在 QEMU 中启动了。
