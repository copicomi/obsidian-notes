# 13.5 Pipe 中的 sleep 和 wakeup

前面我们介绍了在 UART 的驱动中，如何使用 sleep 和 wakeup 才能避免 lost wakeup。前面这个特定的场景中，sleep 等待的 condition 是发生了中断并且硬件准备好了传输下一个字符。在一些其他场景，内核代码会调用 sleep 函数并等待其他的线程完成某些事情。这些场景从概念上来说与我们介绍之前的场景没有什么区别，但是感觉上还是有些差异。例如，在读写 pipe 的代码中，如果你查看 pipe.c 中的 piperead 函数，

![](<../assets/image (529) (1).png>)

这里有很多无关的代码可以忽略。当 read 系统调用最终调用到 piperead 函数时，pi->lock 会用来保护 pipe，这就是 sleep 函数对应的 condition lock。piperead 需要等待的 condition 是 pipe 中有数据，而这个 condition 就是 pi->nwrite 大于 pi->nread，也就是写入 pipe 的字节数大于被读取的字节数。如果这个 condition 不满足，那么 piperead 会调用 sleep 函数，并等待 condition 发生。同时 piperead 会将 condition lock 也就是 pi->lock 作为参数传递给 sleep 函数，以确保不会发生 lost wakeup。

之所以会出现 lost wakeup，是因为在一个不同的 CPU 核上可能有另一个线程刚刚调用了 pipewrite。

![](<../assets/image (490).png>)

pipewrite 会向 pipe 的缓存写数据，并最后在 piperead 所等待的 sleep channel 上调用 wakeup。而我们想要避免这样的风险：在 piperead 函数检查发现没有字节可以读取，到 piperead 函数调用 sleep 函数之间，另一个 CPU 调用了 pipewrite 函数。因为这样的话，另一个 CPU 会向 pipe 写入数据并在 piperead 进程进入 SLEEPING 之前调用 wakeup，进而产生一次 lost wakeup。

在 pipe 的代码中，pipewrite 和 piperead 都将 sleep 包装在一个 while 循环中。piperead 中的循环等待 pipe 的缓存为非空（pipewrite 中的循环等待的是 pipe 的缓存不为 full）。之所以要将 sleep 包装在一个循环中，是因为可能有多个进程在读取同一个 pipe。如果一个进程向 pipe 中写入了一个字节，这个进程会调用 wakeup 进而同时唤醒所有在读取同一个 pipe 的进程。但是因为 pipe 中只有一个字节并且总是有一个进程能够先被唤醒，哦，这正好提醒了我有关 sleep 我忘记了一些非常关键的事情。sleep 函数中最后一件事情就是重新获取 condition lock。所以调用 sleep 函数的时候，需要对 condition lock 上锁（注，在 sleep 函数内部会对 condition lock 解锁），在 sleep 函数返回时会重新对 condition lock 上锁。这样第一个被唤醒的线程会持有 condition lock，而其他的线程在重新对 condition lock 上锁的时候会在锁的 acquire 函数中等待。

那个幸运的进程（注，这里线程和进程描述的有些乱，但是基本意思是一样的，当说到线程时是指进程唯一的内核线程）会从 sleep 函数中返回，之后通过检查可以发现 pi->nwrite 比 pi->nread 大 1，所以进程可以从 piperead 的循环中退出，并读取一个字节，之后 pipe 缓存中就没有数据了。之后 piperead 函数释放锁并返回。接下来，第二个被唤醒的线程，它的 sleep 函数可以获取 condition lock 并返回，但是通过检查发现 pi->nwrite 等于 pi->nread（注，因为唯一的字节已经被前一个进程读走了），所以这个线程以及其他所有的等待线程都会重新进入 sleep 函数。所以这里也可以看出，几乎所有对于 sleep 的调用都需要包装在一个循环中，这样从 sleep 中返回的时候才能够重新检查 condition 是否还符合。

sleep 和 wakeup 的规则稍微有点复杂。因为你需要向 sleep 展示你正在等待什么数据，你需要传入锁并遵循一些规则，某些时候这些规则还挺烦人的。另一方面 sleep 和 wakeup 又足够灵活，因为它们并不需要理解对应的 condition，只是需要有个 condition 和保护这个 condition 的锁。

除了 sleep\&wakeup 之外，还有一些其他的更高级的 Coordination 实现方式。例如今天课程的阅读材料中的 semaphore，它的接口就没有那么复杂，你不用告诉 semaphore 有关锁的信息。而 semaphore 的调用者也不需要担心 lost wakeup 的问题，在 semaphore 的内部实现中考虑了 lost wakeup 问题。因为定制了 up-down 计数器，所以 semaphore 可以在不向接口泄露数据的同时（注，也就是不需要向接口传递 condition lock），处理 lost wakeup 问题。semaphore 某种程度来说更简单，尽管它也没那么通用，如果你不是在等待一个计数器，semaphore 也就没有那么有用了。这也就是为什么我说 sleep 和 wakeup 更通用的原因。
