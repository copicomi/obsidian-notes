# 13.2 Sleep\&Wakeup 接口

接下来看一下通过 Sleep\&Wakeup 实现 Coordination。

我们听过很多关于锁的介绍，锁可以使得线程本身不必关心其他线程的具体实现。我们为共享的数据增加锁，这样就不用担心其他线程也使用了相同的数据，因为锁可以确保对于数据的操作是依次发生的。

当你在写一个线程的代码时，有些场景需要等待一些特定的事件，或者不同的线程之间需要交互。

- 假设我们有一个 Pipe，并且我正在从 Pipe 中读数据。但是 Pipe 当前又没有数据，所以我需要等待一个 Pipe 非空的事件。
- 类似的，假设我在读取磁盘，我会告诉磁盘控制器请读取磁盘上的特定块。这或许要花费较长的时间，尤其当磁碟需要旋转时

  （通常是毫秒级别），磁盘才能完成读取。而执行读磁盘的进程需要等待读磁盘结束的事件。

- 类似的，一个 Unix 进程可以调用 wait 函数。这个会使得调用进程等待任何一个子进程退出。所以这里父进程有意的在等待另一个进程产生的事件。

![](<../assets/image (499).png>)

以上就是进程需要等待特定事件的一些例子。特定事件可能来自于 I/O，也可能来自于另一个进程，并且它描述了某件事情已经发生。Coordination 是帮助我们解决这些问题并帮助我们实现这些需求的工具。Coordination 是非常基础的工具，就像锁一样，在实现线程代码时它会一直出现。

我们怎么能让进程或者线程等待一些特定的事件呢？一种非常直观的方法是通过循环实现 busy-wait。假设我们想从一个 Pipe 读取数据，我们就写一个循环一直等待 Pipe 的 buffer 不为空。

![](<../assets/image (590).png>)

这个循环会一直运行直到其他的线程向 Pipe 的 buffer 写了数据。之后循环会结束，我们就可以从 Pipe 中读取数据并返回。

实际中会有这样的代码。如果你知道你要等待的事件极有可能在 0.1 微秒内发生，通过循环等待或许是最好的实现方式。通常来说在操作设备硬件的代码中会采用这样的等待方式，如果你要求一个硬件完成一个任务，并且你知道硬件总是能非常快的完成任务，这时通过一个类似的循环等待或许是最正确的方式。

另一方面，事件可能需要数个毫秒甚至你都不知道事件要多久才能发生，或许要 10 分钟其他的进程才能向 Pipe 写入数据，那么我们就不想在这一直循环并且浪费本可以用来完成其他任务的 CPU 时间。这时我们想要通过类似 switch 函数调用的方式出让 CPU，并在我们关心的事件发生时重新获取 CPU。Coordination 就是有关出让 CPU，直到等待的事件发生再恢复执行。人们发明了很多不同的 Coordination 的实现方式，但是与许多 Unix 风格操作系统一样，XV6 使用的是 Sleep\&Wakeup 这种方式。

介绍完背景了，接下来我们看一下 XV6 的代码。为了准备这节课，我重写了 UART 的驱动代码，XV6 通过这里的驱动代码从 console 中读写字符。

![](<../assets/image (576).png>)

首先是 uartwrite 函数。当 shell 需要输出时会调用 write 系统调用最终走到 uartwrite 函数中，这个函数会在循环中将 buf 中的字符一个一个的向 UART 硬件写入。这是一种经典的设备驱动实现风格，你可以在很多设备驱动中看到类似的代码。UART 硬件一次只能接受一个字符的传输，而通常来说会有很多字符需要写到 UART 硬件。你可以向 UART 硬件写入一个字符，并等待 UART 硬件说：好的我完成了传输上一个字符并且准备好了传输下一个字符，之后驱动程序才可以写入下一个字符。因为这里的硬件可能会非常慢，或许每秒只能传输 1000 个字符，所以我们在两个字符之间的等待时间可能会很长。而 1 毫秒在现在计算机上是一个非常非常长的时间，它可能包含了数百万条指令时间，所以我们不想通过循环来等待 UART 完成字符传输，我们想通过一个更好的方式来等待。如大多数操作系统一样，XV6 也的确存在更好的等待方式。

UART 硬件会在完成传输一个字符后，触发一个中断。所以 UART 驱动中除了 uartwrite 函数外，还有名为 uartintr 的中断处理程序。这个中断处理程序会在 UART 硬件触发中断时由 trap.c 代码调用。

![](<../assets/image (496).png>)

中断处理程序会在最开始读取 UART 对应的 memory mapped register，并检查其中表明传输完成的相应的标志位，也就是 LSR_TX_IDLE 标志位。如果这个标志位为 1，代码会将 tx_done 设置为 1，并调用 wakeup 函数。这个函数会使得 uartwrite 中的 sleep 函数恢复执行，并尝试发送一个新的字符。所以这里的机制是，如果一个线程需要等待某些事件，比如说等待 UART 硬件愿意接收一个新的字符，线程调用 sleep 函数并等待一个特定的条件。当特定的条件满足时，代码会调用 wakeup 函数。这里的 sleep 函数和 wakeup 函数是成对出现的。我们之后会看 sleep 函数的具体实现，它会做很多事情最后再调用 switch 函数来出让 CPU。

这里有件事情需要注意，sleep 和 wakeup 函数需要通过某种方式链接到一起。也就是说，如果我们调用 wakeup 函数，我们只想唤醒正在等待刚刚发生的特定事件的线程。所以，sleep 函数和 wakeup 函数都带有一个叫做 sleep channel 的参数。我们在调用 wakeup 的时候，需要传入与调用 sleep 函数相同的 sleep channel。不过 sleep 和 wakeup 函数只是接收表示了 sleep channel 的 64bit 数值，它们并不关心这个数值代表什么。当我们调用 sleep 函数时，我们通过一个 sleep channel 表明我们等待的特定事件，当调用 wakeup 时我们希望能传入相同的数值来表明想唤醒哪个线程。

有关这里的接口有什么问题吗？

> 学生提问：进程会在写入每个字符时候都被唤醒一次吗？
>
> Robert 教授：在这个我出于演示目的而特别改过的 UART 驱动中，传输每个字符都会有一个中断，所以你是对的，对于 buffer 中的每个字符，我们都会等待 UART 可以接收下一个字符，之后写入一个字符，将 tx_done 设置为 0，回到循环的最开始并再次调用 sleep 函数进行睡眠状态，直到 tx_done 为 1。当 UART 传输完了这个字符，uartintr 函数会将 tx_done 设置为 1，并唤醒 uartwrite 所在的线程。所以对于每个字符都有调用一次 sleep 和 wakeup，并占用一次循环。
>
> UART 实际上支持一次传输 4 或者 16 个字符，所以一个更有效的驱动会在每一次循环都传输 16 个字符给 UART，并且中断也是每 16 个字符触发一次。更高速的设备，例如以太网卡通常会更多个字节触发一次中断。

以上就是接口的演示。Sleep\&wakeup 的一个优点是它们可以很灵活，它们不关心代码正在执行什么操作，你不用告诉 sleep 函数你在等待什么事件，你也不用告诉 wakeup 函数发生了什么事件，你只需要匹配好 64bit 的 sleep channel 就行。

不过，对于 sleep 函数，有一个有趣的参数，我们需要将一个锁作为第二个参数传入，这背后是一个大的故事，我后面会介绍背后的原因。总的来说，不太可能设计一个 sleep 函数并完全忽略需要等待的事件。所以很难写一个通用的 sleep 函数，只是睡眠并等待一些特定的事件，并且这也很危险，因为可能会导致 lost wakeup，而几乎所有的 Coordination 机制都需要处理 lost wakeup 的问题。在 sleep 接口中，我们需要传入一个锁是一种稍微丑陋的实现，我在稍后会再介绍。
