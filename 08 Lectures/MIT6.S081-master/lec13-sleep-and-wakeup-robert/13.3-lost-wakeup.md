# 13.3 Lost wakeup

在解释 sleep 函数为什么需要一个锁使用作为参数传入之前，我们先来看看假设我们有了一个更简单的不带锁作为参数的 sleep 函数，会有什么样的结果。这里的结果就是 lost wakeup。

假设 sleep 只是接收任意的 sleep channel 作为唯一的参数。它其实不能正常工作，我们称这个 sleep 实现为 broken_sleep。你可以想象一个 sleep 函数内会将进程的状态设置为 SLEEPING，表明当前进程不想再运行，而是正在等待一个特定的事件。如果你们看过了 XV6 的实现，你们可以发现 sleep 函数中还会做很多其他操作。我们需要记录特定的 sleep channel 值，这样之后的 wakeup 函数才能发现是当前进程正在等待 wakeup 对应的事件。最后再调用 switch 函数出让 CPU。

![](<../assets/image (599).png>)

如果 sleep 函数只做了这些操作，那么很明显 sleep 函数会出问题，我们至少还应该在这里获取进程的锁。

之后是 wakeup 函数。我们希望唤醒所有正在等待特定 sleep channel 的线程。所以 wakeup 函数中会查询进程表单中的所有进程，如果进程的状态是 SLEEPING 并且进程对应的 channel 是当前 wakeup 的参数，那么将进程的状态设置为 RUNNABLE。

![](<../assets/image (572).png>)

在一些平行宇宙中，sleep\&wakeup 或许就是这么简单。在我回到 XV6 代码之前，让我演示一下如何在 UART 驱动中使用刚刚介绍的 sleep 和 wakeup 函数。这基本上是重复前一节的内容，不过这次我们使用刚刚介绍的稍微简单的接口。

首先是定义 done 标志位。之后是定义 uartwrite 函数。在函数中，对于 buffer 内的每一个字符，检查 done 标志位，如果标志位为 0，就调用 sleep 函数并传入 tx_channel。之后将字符传递给 UART 并将 done 设置为 0。

![](<../assets/image (570).png>)

之后是中断处理函数 uartintr。函数中首先将 done 标志位设置为 1，并调用 wakeup。

![](<../assets/image (573).png>)

以上就是使用 broken_sleep 的方式。这里缺失的是锁。这里 uartwrite 和 uartintr 两个函数需要使用锁来协调工作。

- 第一个原因是 done 标志位，任何时候我们有了共享的数据，我们需要为这个数据加上锁。
- 另一个原因是两个函数都需要访问 UART 硬件，通常来说让两个线程并发的访问 memory mapped register 是错误的行为。

所以我们需要在两个函数中加锁来避免对于 done 标志位和硬件的竞争访问。

现在的问题是，我们该在哪个位置加锁？在中断处理程序中较为简单，我们在最开始加锁，在最后解锁。

![](<../assets/image (617).png>)

难的是如何在 uartwrite 函数中加锁。一种可能是，每次发送一个字符的过程中持有锁，所以在每一次遍历 buffer 的起始和结束位置加锁和解锁。

![](<../assets/image (595).png>)

为什么这样肯定不能工作？一个原因是，我们能从 while not done 的循环退出的唯一可能是中断处理程序将 done 设置为 1。但是如果我们为整个代码段都加锁的话，中断处理程序就不能获取锁了，中断程序会不停“自旋”并等待锁释放。而锁被 uartwrite 持有，在 done 设置为 1 之前不会释放。而 done 只有在中断处理程序获取锁之后才可能设置为 1。所以我们不能在发送每个字符的整个处理流程都加锁。

上面加锁方式的问题是，uartwrite 在期望中断处理程序执行的同时又持有了锁。而我们唯一期望中断处理程序执行的位置就是 sleep 函数执行期间，其他的时候 uartwrite 持有锁是没有问题的。所以另一种实现可能是，在传输字符的最开始获取锁，因为我们需要保护共享变量 done，但是在调用 sleep 函数之前释放锁。这样中断处理程序就有可能运行并且设置 done 标志位为 1。之后在 sleep 函数返回时，再次获取锁。

![](<../assets/image (416).png>)

让我来修改代码，并看看相应的运行结果是什么。现有的代码中，uartwrite 在最开始获取了锁，并在最后释放了锁。

![](<../assets/image (629).png>)

中断处理程序也在最开始获取锁，之后释放锁。

![](<../assets/image (578).png>)

接下来，我们会探索为什么只接收一个参数的 broken_sleep 在这不能工作。为了让锁能正常工作，我们需要在调用 broken_sleep 函数之前释放 uart_tx_lock，并在 broken_sleep 返回时重新获取锁。broken_sleep 内的代码与之前在白板上演示的是一样的。也就是首先将进程状态设置为 SLEEPING，并且保存 tx_chan 到进程结构体中，最后调用 switch 函数。

![](<../assets/image (574).png>)

接下来编译代码并看一下会发生什么。

![](<../assets/image (587).png>)

在 XV6 启动的时候会打印“init starting”，这里看来输出了一些字符之后就 hang 住了。如果我输入任意字符，剩下的字符就能输出。这里发生了什么？

这里的问题必然与之前修改的代码相关。在前面的代码中，sleep 之前释放了锁，但是在释放锁和 broken_sleep 之间可能会发生中断。

![](<../assets/image (459) (1) (1) (1) (1).png>)

一旦释放了锁，当前 CPU 的中断会被重新打开。因为这是一个多核机器，所以中断可能发生在任意一个 CPU 核。在上面代码标记的位置，其他 CPU 核上正在执行 UART 的中断处理程序，并且正在 acquire 函数中等待当前锁释放。所以一旦锁被释放了，另一个 CPU 核就会获取锁，并发现 UART 硬件完成了发送上一个字符，之后会设置 tx_done 为 1，最后再调用 wakeup 函数，并传入 tx_chan。目前为止一切都还好，除了一点：现在写线程还在执行并位于 release 和 broken_sleep 之间，也就是写线程还没有进入 SLEEPING 状态，所以中断处理程序中的 wakeup 并没有唤醒任何进程，因为还没有任何进程在 tx_chan 上睡眠。之后写线程会继续运行，调用 broken_sleep，将进程状态设置为 SLEEPING，保存 sleep channel。但是中断已经发生了，wakeup 也已经被调用了。所以这次的 broken_sleep，没有人会唤醒它，因为 wakeup 已经发生过了。这就是 lost wakeup 问题。

> 学生提问：是不是总是这样，一旦一个 wakeup 被丢失了，下一次 wakeup 时，之前缓存的数据会继续输出？
>
> Robert 教授：这完全取决于实现细节。在我们的例子中，实际上出于偶然才会出现当我输入某些内容会导致之前的输出继续的现象。这里背后的原因是，我们的代码中，UART 只有一个中断处理程序。不论是有输入，还是完成了一次输出，都会调用到同一个中断处理程序中。所以当我输入某些内容时，会触发输入中断，之后会调用 uartintr 函数。然后在中断处理程序中又会判断 LSR_TX_IDLE 标志位，并再次调用 wakeup，所以刚刚的现象完全是偶然。如果出现了 lost wakeup 问题，并且你足够幸运的话，某些时候它们能自动修复。如果 UART 有不同的接收和发送中断处理程序的话，那么就没办法从 lost wakeup 恢复。
>
> 学生提问：tx_done 标志位的作用是什么？
>
> Robert 教授：这是一种简单的在 uartintr 和 uartwrite 函数之间通信的方法。tx_done 标志位为 1 表示已经完成了对于前一个字符的传输，并且 uartwrite 可以传输下一个字符，所以这是用来在中断处理程序和 uartwrite 之间通信的标志位。
>
> 同一个学生提问：当从 sleep 函数中唤醒时，不是已经知道是来自 UART 的中断处理程序调用 wakeup 的结果吗？这样的话 tx_done 有些多余。
>
> Robert 教授：我想你的问题也可以描述为：为什么需要通过一个循环 while(tx_done == 0)来调用 sleep 函数？这个问题的答案适用于一个更通用的场景：实际中不太可能将 sleep 和 wakeup 精确匹配。并不是说 sleep 函数返回了，你等待的事件就一定会发生。举个例子，假设我们有两个进程同时想写 UART，它们都在 uartwrite 函数中。可能发生这种场景，当一个进程写完一个字符之后，会进入 SLEEPING 状态并释放锁，而另一个进程可以在这时进入到循环并等待 UART 空闲下来。之后两个进程都进入到 SLEEPING 状态，当发生中断时 UART 可以再次接收一个字符，两个进程都会被唤醒，但是只有一个进程应该写入字符，所以我们才需要在 sleep 外面包一层 while 循环。实际上，你可以在 XV6 中的每一个 sleep 函数调用都被一个 while 循环包着。因为事实是，你或许被唤醒了，但是其他人将你等待的事件拿走了，所以你还得继续 sleep。这种现象还挺普遍的。
>
> 学生提问：我们只看到了一个 lost wakeup，当我们随便输入一个字符，整个剩下的字符都能输出，为什么没有在输出剩下字符的时候再次发生 lost wakeup？
>
> Robert 教授：这会发生的。我来敲一下 cat README，这会输出数千个字符。可以看到每过几个字符就会 hang 一次，需要我再次输入某个字符。这个过程我们可以看到很多 lost wakeup。之前之所以没有出现，是因为 lost wakeup 需要中断已经在等待获取锁，并且 uartwrite 位于 release 和 broken_sleep 之间，这需要一定的巧合并不总是会发生。
