# 13.4 如何避免 Lost wakeup

现在我们的目标是消灭掉 lost wakeup。这可以通过消除下面的窗口时间来实现。

![](<../assets/image (459) (1) (1) (1) (1).png>)

首先我们必须要释放 uart_tx_lock 锁，因为中断需要获取这个锁，但是我们又不能在释放锁和进程将自己标记为 SLEEPING 之间留有窗口。这样中断处理程序中的 wakeup 才能看到 SLEEPING 状态的进程，并将其唤醒，进而我们才可以避免 lost wakeup 的问题。所以，我们应该消除这里的窗口。

为了实现这个目的，我们需要将 sleep 函数设计的稍微复杂点。这里的解决方法是，即使 sleep 函数不需要知道你在等待什么事件，它还是需要你知道你在等待什么数据，并且传入一个用来保护你在等待数据的锁。sleep 函数需要特定的条件才能执行，而 sleep 自己又不需要知道这个条件是什么。在我们的例子中，sleep 函数执行的特定条件是 tx_done 等于 1。虽然 sleep 不需要知道 tx_done，但是它需要知道保护这个条件的锁，也就是这里的 uart_tx_lock。在调用 sleep 的时候，锁还被当前线程持有，之后这个锁被传递给了 sleep。

在接口层面，sleep 承诺可以原子性的将进程设置成 SLEEPING 状态，同时释放锁。这样 wakeup 就不可能看到这样的场景：锁被释放了但是进程还没有进入到 SLEEPING 状态。所以 sleep 这里将释放锁和设置进程为 SLEEPING 状态这两个行为合并为一个原子操作。

所以我们需要有一个锁来保护 sleep 的条件，并且这个锁需要传递给 sleep 作为参数。更进一步的是，当调用 wakeup 时，锁必须被持有。如果程序员想要写出正确的代码，都必须遵守这些规则来使用 sleep 和 wakeup。

接下来我们看一下 sleep 和 wakeup 如何使用这一小块额外的信息（注，也就是传入给 sleep 函数的锁）和刚刚提到的规则，来避免 lost wakeup。

首先我们来看一下 proc.c 中的 wakeup 函数。

![](<../assets/image (612).png>)

wakeup 函数并不十分出人意料。它查看整个进程表单，对于每个进程首先加锁，这点很重要。之后查看进程的状态，如果进程当前是 SLEEPING 并且进程的 channel 与 wakeup 传入的 channel 相同，将进程的状态设置为 RUNNABLE。最后再释放进程的锁。

接下来我们忽略 broken_sleep，直接查看带有锁作为参数的 sleep 函数。

![](<../assets/image (569).png>)

我们已经知道了 sleep 函数需要释放作为第二个参数传入的锁，这样中断处理程序才能获取锁。函数中第一件事情就是释放这个锁。当然在释放锁之后，我们会担心在这个时间点相应的 wakeup 会被调用并尝试唤醒当前进程，而当前进程还没有进入到 SLEEPING 状态。所以我们不能让 wakeup 在 release 锁之后执行。为了让它不在 release 锁之后执行，在 release 锁之前，sleep 会获取即将进入 SLEEPING 状态的进程的锁。

如果你还记得的话，wakeup 在唤醒一个进程前，需要先获取进程的锁。所以在整个时间 uartwrite 检查条件之前到 sleep 函数中调用 sched 函数之间，这个线程一直持有了保护 sleep 条件的锁或者 p->lock。让我回到 UART 的代码并强调一下这一点。

![](<../assets/image (559).png>)

uartwrite 在最开始获取了 sleep 的 condition lock，并且一直持有 condition lock 直到调用 sleep 函数。所以它首先获取了 condition lock，之后检查 condition（注，也就是 tx_done 等于 0），之后在持有 condition lock 的前提下调用了 sleep 函数。此时 wakeup 不能做任何事情，wakeup 现在甚至都不能被调用直到调用者能持有 condition lock。所以现在 wakeup 必然还没有执行。

sleep 函数在释放 condition lock 之前，先获取了进程的锁。在释放了 condition lock 之后，wakeup 就可以被调用了，但是除非 wakeup 获取了进程的锁，否则 wakeup 不能查看进程的状态。所以，在 sleep 函数中释放了 condition lock 之后，wakeup 也还没有执行。

在持有进程锁的时候，将进程的状态设置为 SLEEPING 并记录 sleep channel，之后再调用 sched 函数，这个函数中会再调用 switch 函数（注，详见 11.6），此时 sleep 函数中仍然持有了进程的锁，wakeup 仍然不能做任何事情。

如果你还记得的话，当我们从当前线程切换走时，调度器线程中会释放前一个进程的锁（注，详见 11.8）。所以在调度器线程释放进程锁之后，wakeup 才能终于获取进程的锁，发现它正在 SLEEPING 状态，并唤醒它。

这里的效果是由之前定义的一些规则确保的，这些规则包括了：

- 调用 sleep 时需要持有 condition lock，这样 sleep 函数才能知道相应的锁。
- sleep 函数只有在获取到进程的锁 p->lock 之后，才能释放 condition lock。
- wakeup 需要同时持有两个锁才能查看进程。

这样的话，我们就不会再丢失任何一个 wakeup，也就是说我们修复了 lost wakeup 的问题。
