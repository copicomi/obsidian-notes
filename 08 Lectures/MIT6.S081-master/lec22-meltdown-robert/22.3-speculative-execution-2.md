# 22.3 Speculative execution(2)

![](<../assets/image (87).png>)

如果 r0 中的内存地址是无效的，且在 Page Table 中完全没有映射关系，那么我也不知道会发生什么。如果 r0 中的内存地址在 Page Table 中存在映射关系，只是现在权限不够，比如说 pte_u 标志位为 0，那么 Intel 的 CPU 会加载内存地址对应的数据，并存储在 r2 寄存器的临时版本中。之后 r2 寄存器的临时版本可以被代码第 5 行使用。所以尽管 r0 中的内存地址是我们没有权限的内存，比如说一个内核地址，它的数据还是会被加载到 r2，之后再加 1 并存储在 r3 中。之后，当代码第 4 行 Retired 时，CPU 会发现这是一个无效的读内存地址行为，因为 PTE 不允许读取这个内存地址。这时 CPU 会产生 Page Fault 取消执行后续指令，并回撤对于 r2 和 r3 寄存器的修改。

所以，在这里的例子中，CPU 进行了两个推测：一个是 CPU 推测了 if 分支的走向，并选择了一个分支提前执行；除此之外，CPU 推测了代码第 4 行能够成功完成。对于 load 指令，如果数据在 CPU 缓存中且相应的 PTE 存在于 Page Table，不论当前代码是否有权限，Intel CPU 总是能将数据取出。如果没有权限，只有在代码第 4 行 Retired 的时候，才会生成 Page Fault，并导致预测执行被取消。

> 学生提问：我对 CPU 的第二个预测，也就是从 r0 中保存的内存地址加载数据有一些困惑，这是不是意味着 r0 对应的数据先被加载到了 r2，然后再检查 PTE 的标志位？
>
> Robert 教授：完全正确。在预测的阶段，不论 r0 指向了什么地址，只要它指向了任何东西，内存中的数据会被加载到 r2 中。之后，当 load 指令 Retired 时才会检查权限。如果我们并没有权限做操作，所有的后续指令的效果会被取消，也就是对于寄存器的所有修改会回滚。同时，Page Fault 会被触发，同时寄存器的状态就像是预测执行的指令没有执行过一样。
>
> 学生提问：难道不能限制 CPU 在 Speculative execution 的时候，先检查权限，再执行 load 指令吗？看起来我们现在的问题就是我们在不知道权限的情况下读取了内存，如果我们能先知道权限，那么 Speculative execution 能不能提前取消？
>
> Robert 教授：这里有两个回答。首先，Intel 芯片并不是这样工作的。其次，是的，我相信对于 Intel 来说如果先做权限检查会更简单，这样的话，在上面的例子中，r2 寄存器就不会被修改。
>
> 你们或许注意到论文中提到，尽管 AMD CPU 的手册与 Intel 的一样，它们有相同的指令集，Meltdown Attack 并不会在 AMD CPU 上生效。普遍接受的观点是，AMD CPU 在 Speculative execution 时，如果没有权限读取内存地址，是不会将内存地址中的数据读出。这就是为什么 Meltdown Attack 在 AMD CPU 上不生效的原因。最近的 Intel CPU 明显也采用了这种方法，如果程序没有权限，在 Speculative execution 的时候也不会加载内存数据。
>
> 这里使用哪种方式对于性能来说没有明显区别，或许在指令 Retired 的时候再检查权限能省一些 CPU 的晶体管吧。这里我要提醒一下，这里有很多内容都是猜的，不过我认为我说的都是对的。Intel 和 AMD 并没有太披露具体的细节。

这里有一些重要的术语。你可以从 CPU 手册中读到的，比如说一个 add 指令接收两个寄存器作为参数，并将结果存放在第三个寄存器，这一类设计被称为 CPU 的 Architectural，或者通告的行为。如果你读取一个你没有权限的内存地址，你会得到一个 Page Fault，你不允许读取这个内存地址，这就是一种通告的行为。CPU 的实际行为被称作 Micro-Architectural，CPU 的通告行为与实际行为是模糊不清的。比如说 CPU 会悄悄的有 Speculative execution。

![](<../assets/image (113).png>)

CPU 设计者在设计 Micro-Architectural 时的初衷是为了让它是透明的。的确有很多行为都发生在 CPU 内部，但是结果看起来就像是 CPU 完全按照手册在运行。举个例子，在上面代码的第 4 行，或许 Intel 的 CPU 在读取内存时没有检查权限，但是如果权限有问题的话，在指令 Retired 的时候，所有的效果都会回滚，你永远也看不到你不该看到的内存内容。所以看起来就跟 CPU 的手册一样，你不允许读取你没有权限的内存地址。这里 Architectural 和 Micro-Architectural 的区别是 Meltdown Attack 的主要攻击点。这里的攻击知道 CPU 内部是如何工作的。
