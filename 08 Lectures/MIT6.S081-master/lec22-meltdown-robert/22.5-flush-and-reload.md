# 22.5 Flush and Reload

为什么 Cache 与 Meltdown 相关呢？接下来我将讨论一下[论文](https://pdos.csail.mit.edu/6.828/2020/readings/meltdown.pdf)中使用 Cache 的主要方法。论文中讨论了这种叫做 Flush and Reload 的技术，这个技术回答了一个问题：一段特定的代码是否使用了特定内存地址的数据？这个技术本身并不是一个直接的安全漏洞，因为它只能基于你有权限的内存地址工作。

所以如果你是用户代码，你可以使用属于你的用户空间内存，并且你现在要调用一个你自己的函数，你可以使用 Flush and Reload 来知道你刚刚执行的函数是否使用了某个属于你自己的内存。你不能直接使用这种技术来获取其他进程的私有内存。进程之间有时候会共享内存，你还是可以访问这部分共享的内存。所以 Flush and Reload 回答了这个问题，特定的函数是否使用了特定内存地址？它的具体工作步骤如下：

1. 第一步，假设我们对地址 X 感兴趣，我们希望确保 Cache 中并没有包含位于 X 的内存数据。实际中，为了方便，Intel 提供了一条指令，叫做 clflush，它接收一个内存地址作为参数，并确保该内存地址不在任何 cache 中。这超级方便，不过即使 CPU 并没有提供这样的指令，实际中也有方法能够删除 Cache 中的数据，举个例子，如果你知道 Cache 有 64KB，那么你 load 64KB 大小的随机内存数据，这些数据会被加载到 Cache 中，这时 Cache 中原本的数据会被冲走，因为 Cache 只有 64KB 大小。所以即使没有这个好用的指令，你仍然可以清空 Cache 中的所有数据。
2. 第二步，如果你对某段可能使用了内存地址 X 的代码感兴趣，你可以调用这个函数，先不管这个函数做了什么，或许它使用了内存地址 X，或许没有。
3. 现在，你想要知道 X 是否在 Cache 中，如果是的话，因为在第一步清空了 Cache，必然是因为第二步的函数中 load 了这个内存地址。所以你现在想要执行 load，但是你更想知道 load 花费了多长时间，而且我们这里讨论的是纳秒级别的时间，比如 5 个纳秒或者 100 个纳秒，那么我们该怎样达到这种测量精度呢？这是个困难的任务。Intel CPU 会提供指令来向你返回 CPU cycle 的数量，这被称为 rdtsc。所以这里我们会执行 rdtsc 指令，它会返回 CPU 启动之后总共经过了多少个 CPU cycle。如果是 2GHZ 的 CPU，这意味着通过这个指令我们可以得到 0.5 纳秒的测量精度。
4. 现在我们会将内存地址 X 的数据加载到 junk 对象中。
5. 然后再通过 rdtsc 读取时间。如果两次读取时间的差是个位数，那么上一步的 load 指令走到了 cache 中，也就是第二步的函数中使用了内存地址 X 的数据。如果两次读取时间的差别超过 100，这意味着内存地址 X 不在 cache 中，虽然这并不绝对，但是这可能代表了第二步的函数中并没有使用内存 X 的数据。因为函数中可能使用了内存地址 X，然后又用了其他与 X 冲突的数据，导致内存地址 X 又被从 cache 中剔除了。但是对于简单的情况，如果两次时间差较大那么第二步的函数没有使用内存地址 X，如果两次时间差较小那么第二步函数使用了内存地址 X。

![](<../assets/image (59).png>)

现在还没有涉及到攻击，因为这里我们需要能够访问到内存地址 X，所以这是我们可以访问的内存地址。

以上就是有关 Meltdown 的前置知识。
