# 22.2 Speculative execution(1)

首先来看 Speculative execution（预测执行），这里也有一个示例代码。

![](<../assets/image (873) (2) (2) (1).png>)

现在我并没有讨论安全性，Speculative execution 是一种用来提升 CPU 性能的技术，所以这是 CPU 使用的一些优化技巧。假设我们在运行这里的代码：

- 在 r0 寄存器保存了一个内存地址，地址可能是有效的也可能是无效的，这取决于我代码的逻辑。
- 我们假设内存中还保存了一个 valid 变量。在使用 r0 中保存地址之前，我们会先将 valid 从内存中加载到 r1。
- 并且只有当 valid 等于 1 时，才使用 r0 中的地址。如果 valid 等于 0，我们将不会使用 r0 中的地址。
- 如果 valid 等于 1，我们会将 r0 的地址指向的内容加载到 r2。
- 并对 r2 寄存器加 1，保存在 r3 寄存器中。

在一个简单的 CPU 实现中，在代码的第 2 行，你会将 valid 从内存中加载到 r1，这里对应了从内存中读取数据的 load 指令。任何一个需要从内存中读取数据的 load 指令都会花费 2GHZ CPU 的数百个 CPU cycle。CPU 最多可以在每个 cycle 执行一条指令，如果我们需要在代码的第 2 行等待几百个 CPU cycle，那么机器会闲置数百个 CPU cycle。这是一个明显的降低性能的地方，因为如果一切都正常的话，CPU 可以在每个 cycle 内执行一条指令，而不是每几百个 cycle 才执行一条指令。

所有现在的 CPU 都使用了叫做 branch prediction 的功能。第 3 行的 if 语句是一个 branch，如果我们将其转换成机器指令，我们可以发现这里有一个 branch，并且这是一个带条件的 branch 用来测试 r1 寄存器是否等于 1。CPU 的 branch prediction 会至少为每个最近执行过的 branch 保存一个缓存，并记住这个 branch 是否被选中了，所以这里可能是基于上次 branch 的选择的预测。但是即使 CPU 没有足够的信息做预测，它仍然会选择一个 branch，并执行其中的指令。也就是说在 CPU 在知道第 3 行代码是否为 true 之前，它会选择某一个 branch 并开始执行。或许 branch 选错了，但是 CPU 现在还不知道。

所以在上面的代码中，或许在第 2 行代码的 load 结束之前，也就是在知道 valid 变量的值之前，CPU 会开始执行第 4 行的指令，并通过 load 指令读取 r0 指向的内存地址的内容。而 r0 中的内存地址或许是，也或许不是一个有效的指针。一旦 load 指令返回了一些内容，在代码的第 5 行对返回内容加 1 并设置到 r3 寄存器中。

或许很久之后，第 2 行的 load 指令终于完成了，现在我们知道 valid 变量的值。如果 valid 等于 1，那么一切都好，如果 valid 等于 0，CPU 会取消它执行第 4、5 行代码的效果，并重新执行合适的分支代码，也就是第 7 行代码。

这里在确定是否应该执行之前就提前执行分支代码的行为，被称作预测执行。这是为了提升性能，如果 CPU 赌对了，那么它就可以超前执行一些指令，而不用等待费时的内存加载。

CPU 中为了支持预测执行的硬件及其复杂，CPU 里面有大量的设计来让这里能工作，但是没有一个设计被公开了，这些都是 Intel 的内部信息，并且不在手册中。所以在 Meltdown Attack 时，涉及到大量有关 CPU 是如何工作的猜测来确保攻击能生效。

为了能回滚误判的预测执行，CPU 需要将寄存器值保存在别处。虽然代码中第 4 行，第 5 行将值保存在了 r2，r3，但是实际上是保存在了临时寄存器中。如果 CPU 赌对了，那么这些临时寄存器就成了真实寄存器，如果赌错了，CPU 会抛弃临时寄存器，这样代码第 4，5 行就像从来没有发生过一样。

在这里的代码中，我们需要考虑如果 r0 中是有效的指针会发生什么，如果不是有效的指针，又会发生什么。如果我们在超前执行代码第 4 行，并且 r0 中是有效的指针，那么 CPU 会真实的加载指针的内容到 r2 寄存器的临时版本中。如果 r0 中的指针指向的内容位于 CPU 的 cache 中，那么必然可以将内容拷贝到 r2 寄存器的临时版本。如果 CPU 的 cache 中没有包含数据，我并不清楚 CPU 是否会会从内存中读取 r0 中指针指向的内容。

对于我们来说，更有趣的一个问题是，如果 r0 中的指针不是一个有效的指针，会发生什么？如果 r0 中的指针不是一个有效的地址，并且我们在超前执行代码第 4 行，机器不会产生 Fault。机器或许知道 r0 是无效的地址，并且代码第 4 行尝试使用一个无效的地址，但是它不能产生 Page Fault，因为它不能确定代码第 4 行是否是一个正确的代码分支，因为有可能 CPU 赌错了。所以直到 CPU 知道了 valid 变量的内容，否则 CPU 不能在代码第 4 行生成 Page Fault。也就是说，如果 CPU 发现代码第 4 行中 r0 内的地址是无效的，且 valid 变量为 1，这时机器才会生成 Page Fault。如果 r0 是无效的地址，且 valid 变量为 0，机器不会生成 Page Fault。所以是否要产生 Page Fault 的决定，可能会推迟数百个 CPU cycle，直到 valid 变量的值被确定。

当我们确定一条指令是否正确的超前执行了而不是被抛弃了这个时间点，对应的技术术语是 Retired。所以当我们说一个指令被超前执行，在某个时间点 Retired，这时我们就知道这条指令要么会被丢弃，要么它应该实际生效，并且对机器处于可见状态。一条指令如果是 Retired 需要满足两个条件，首先它自己要结束执行，比如说结束了从内存加载数据，结束了对数据加 1；其次，所有之前的指令也需要 Retired。所以上面代码第 4 行在直到 valid 变量被从内存中加载出来且 if 被判定之前不能 Retired，所以第 4 行的 Retirement 可能会延后数百个 CPU cycle。

这是 Meltdown 攻击非常关键的一个细节。
