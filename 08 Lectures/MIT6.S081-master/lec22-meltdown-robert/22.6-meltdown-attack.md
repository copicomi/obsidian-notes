# 22.6 Meltdown Attack

接下来让我们回到 Meltdown。

![](<../assets/image (128).png>)

这段代码比 22.1 里面的代码更加完整，这里是一个更完整的 Meltdown 攻击代码，这里我们增加了 Flush and Reload 代码。

首先我们声明了一个 buffer，现在我们只需要从内核中窃取 1 个 bit 的数据，我们会将这个 bit 乘以 4096，所以我们希望下面的 Flush and Reload 要么看到 buffer\[0]在 cache 中，要么看到 buffer\[4096]在 cache 中。为什么要有这么的大的间隔？是因为硬件有预获取。如果你从内存加载一个数据，硬件极有可能会从内存中再加载相邻的几个数据到 cache 中。所以我们不能使用两个非常接近的内存地址，然后再来执行 Flush and Reload，我们需要它们足够的远，这样即使有硬件的预获取，也不会造成困扰。所以这里我们将两个地址放到了两个内存 Page 中（注，一个内存 Page 4096）。

现在的 Flush 部分直接调用了 clflush 指令（代码第 4 第 5 行），来确保我们 buffer 中相关部分并没有在 cache 中。

代码第 7 行或许并不必要，这里我们会创造时间差。我们将会在第 10 行执行 load 指令，它会 load 一个内核内存地址，所以它会产生 Page Fault。但是我们期望能够在第 10 行指令 Retired 之前，也就是实际的产生 Page Fault 并取消这些指令效果之前，再预测执行（Speculative execution）几条指令。如果代码第 10 行在下面位置 Retired，那么对我们来说就太早了。实际中我们需要代码第 13 行被预测执行，这样才能完成攻击。

![](<../assets/image (70).png>)

所以我们希望代码第 10 行的 load 指令尽可能晚的 Retired，这样才能推迟 Page Fault 的产生和推迟取消预测执行指令的效果。因为我们知道一个指令只可能在它之前的所有指令都 Retired 之后，才有可能 Retired。所以在代码第 7 行，我们可以假设存在一些非常费时的指令，它们需要很长时间才能完成。或许要从 RAM 加载一些数据，这会花费几百个 CPU cycle；或许执行了除法，或者平方根等。这些指令花费了很多时间，并且很长时间都不会 Retired，因此也导致代码第 10 行的 load 很长时间也不会 Retired，并给第 11 到 13 行的代码时间来完成预测执行。

现在假设我们已经有了内核的一个虚拟内存地址，并且要执行代码第 10 行。我们知道它会生成一个 Page Fault，但是它只会在 Retired 的时候才会真正的生成 Page Fault。我们设置好了使得它要过一会才 Retired。因为代码第 10 行还没有 Retired，并且在 Intel CPU 上，即使你没有内存地址的权限，数据也会在预测执行的指令中被返回。这样在第 11 行，CPU 可以预测执行，并获取内核数据的第 0 个 bit。第 12 行将其乘以 4096。第 13 行是另一个 load 指令，load 的内存地址是 buffer 加上 r2 寄存器的内容。我们知道这些指令的效果会被取消，因为第 10 行会产生 Page Fault，所以对于 r3 寄存器的修改会被取消。但是尽管寄存器都不会受影响，代码第 13 行会导致来自于 buffer 的部分数据被加载到 cache 中。取决于内核数据的第 0bit 是 0 还是 1，第 13 行会导致要么是 buffer\[0]，要么是 buffer\[4096]被加载到 cache 中。之后，尽管 r2 和 r3 的修改都被取消了，cache 中的变化不会被取消，因为这涉及到 Micro-Architectural，所以 cache 会被更新。

第 15 行表示最终 Page Fault 还是会发生，并且我们需要从 Page Fault 中恢复。用户进程可以注册一个 Page Fault Handler（注，详见 Lec17），并且在 Page Fault 之后重新获得控制。论文还讨论了一些其他的方法使得发生 Page Fault 之后可以继续执行程序。

现在我们需要做的就是弄清楚，是 buffer\[0]还是 buffer\[4096]被加载到了 cache 中。现在我们可以完成 Flush and Reload 中的 Reload 部分了。第 18 行获取当前的 CPU 时间，第 19 行 load buffer\[0]，第 20 行再次读取当前 CPU 时间，第 21 行 load buffer\[4096]，第 22 行再次读取当前 CPU 时间，第 23 行对比两个时间差。哪个时间差更短，就可以说明内核数据的 bit0 是 0 还是 1。如果我们重复几百万次，我们可以扫描出所有的内核内存。

> 学生提问：在这里例子中，如果 b-a\<c-b，是不是意味着 buffer\[0]在 cache 中？
>
> Robert 教授：是的，你是对的。

![](<../assets/image (135).png>)

> 学生提问：在第 9 行之前，我们需要 if 语句吗？
>
> Robert 教授：并不需要，22.2 中的 if 语句是帮助我展示 Speculative execution 的合理理由：尽管 CPU 不知道 if 分支是否命中，它还是会继续执行。但是在这里，预测执行的核心是我们并不知道第 10 行的 load 会造成 Page Fault，所以 CPU 会在第 10 行 load 之后继续预测执行。理论上，尽管这里的 load 可能会花费比较长的时间（例如数百个 CPU cycle），但是它现在不会产生 Page Fault，所以 CPU 会预测执行 load 之后的指令。如果 load 最终产生了 Page Fault，CPU 会回撤所有预测执行的效果。
>
> 预测执行会在任何长时间执行的指令，且不论这个指令是否能成功时触发。例如除法，我们不知道是否除以 0。一旦触发预测执行，所有之后的指令就会开始被预测执行。
>
> 不管怎样，真正核心的预测执行从第 10 行开始，但是为了让攻击更有可能成功，我们需要确保预测执行从第 7 行开始。
>
> 学生提问：在这个例子中，我们只读了一个 bit，有没有一些其他的修改使得我们可以读取一整个寄存器的数据？
>
> Robert 教授：有的，将这里的代码运行 64 次，每次获取 1 个 bit。
>
> 学生提问：为什么不能一次读取 64bit 呢？
>
> Robert 教授：如果这样的话，buffer 需要是 2^64 再乘以 4096，我们可能没有足够的内存来一次读 64bit。或许你可以一次读 8 个 bit，然后 buffer 大小是 256\*4096。论文中有相关的，因为这里主要的时间在第 17 行到第 24 行，也就是 Flush and Reload 的 Reload 部分。如果一次读取一个字节，那么找出这个字节的所有 bit，需要 256 次 Reload，每次针对一个字节的可能值。如果一次只读取一个 bit，那么每个 bit 只需要 2 次 Reload。所以一次读取一个 bit，那么读取一个字节只需要 16 次 Reload，一次读取一个字节，那么需要 256 次 Reload。所以论文中说一次只读取一个 bit 会更快，这看起来有点反直觉，但是又好像是对的。
>
> 学生提问：这里的代码会运行在哪？会运行在特定的位置吗？
>
> Robert 教授：这取决于你对于机器有什么样的权限，并且你想要窃取的数据在哪了。举个例子，你登录进了 Athena（注，MIT 的共享计算机系统），机器上还有几百个其他用户 ，然后你想要窃取某人的密码，并且你很有耐心。在几年前 Athena 运行的 Linux 版本会将内核内存映射到每一个用户进程的地址空间。那么你就可以使用 Meltdown 来一个 bit 一个 bit 的读取内核数据，其中包括了 I/O buffer 和 network buffer。如果某人在输入密码，且你足够幸运和有耐心，你可以在内核内存中看见这个密码。实际中，内核可能会映射所有的物理内存，比如 XV6 就是这么做的，这意味着你或许可以使用 Meltdown 在一个分时共享的机器上，读取所有的物理内存，其中包括了所有其他进程的内存。这样我就可以看到其他人在文本编辑器的内容，或者任何我喜欢的内容。这是你可以在一个分时共享的机器上使用 Meltdown 的方法。其他的场景会不太一样。
>
> 分时共享的机器并没有那么流行了，但是这里的杀手场景是云计算。如果你使用了云服务商，比如 AWS，它会在同一个计算机上运行多个用户的业务，取决于 AWS 如何设置它的 VMM 或者容器系统，如果你购买了 AWS 的业务，那么你或许就可以窥探其他运行在同一个 AWS 机器上的用户软件的内存。我认为这是人们使用 Meltdown 攻击的方式。
>
> 另一个可能有用的场景是，当你的浏览器在访问 web 时，你的浏览器其实运行了很多不被信任的代码，这些代码是各种网站提供的，或许是以插件的形式提供，或许是以 javascript 的形式提供。这些代码会被加载到浏览器，然后被编译并被运行。有可能当你在浏览网页的时候，你运行在浏览器中的代码会发起 Meltdown 攻击，而你丝毫不知道有一个网站在窃取你笔记本上的内容，但是我并不知道这里的细节。
>
> 学生提问：有人演示过通过 javascript 或者 WebAssembly 发起攻击吗？
>
> Robert 教授：我不知道。人们肯定担心过 WebAssembly，但是我不知道通过它发起攻击是否可行。对于 javascript 我知道难点在于时间的测量，你不能向上面一样获取到纳秒级别的时间，所以你并不能使用 Flush and Reload。或许一些更聪明的人可以想明白怎么做，但是我不知道。

实际中 Meltdown Attack 并不总是能生效，具体的原因我认为论文作者并没有解释或者只是猜测了一下。如果你查看论文的最后一页，

![](<../assets/image (84).png>)

你可以看到 Meltdown Attack 从机器的内核中读取了一些数据，这些数据里面有一些 XXXX，这些是没能获取任何数据的位置，也就是 Meltdown Attack 失败的位置。论文中的 Meltdown Attack 重试了很多很多次，因为在论文 6.2 还讨论了性能，说了在某些场景下，获取数据的速率只有 10 字节每秒，这意味着代码在那不停的尝试了数千次，最后终于获取到了数据，也就是说 Flush and Reload 表明了两个内存地址只有一个在 Cache 中。所以有一些无法解释的事情使得 Meltdown 会失败，从上图看，Meltdown Attack 获取了一些数据，同时也有一些数据无法获得。据我所知，人们并不真的知道所有的成功条件和失败条件，最简单的可能是如果内核数据在 L1 cache 中，Meltdown 能成功，如果内核数据不在 L1 Cache 中，Meltdown 不能成功。如果内核数据不在 L1 cache 中，在预测执行时要涉及很多机制，很容易可以想到如果 CPU 还不确定是否需要这个数据，并不一定会完成所有的工作来将数据从 RAM 中加载过来。你可以发现实际中并没有这么简单，因为论文说到，有时候当重试很多次之后，最终还是能成功。所以这里有一些复杂的情况，或许在 CPU 内有抢占使得即使内核数据并不在 Cache 中，这里的攻击偶尔还是可以工作。

论文的最后也值得阅读，因为它解释了一个真实的场景，比如说我们想要通过 Meltdown 窃取 Firefox 的密码管理器中的密码，你该怎么找出内存地址，以及一个攻击的完整流程，我的意思是由学院派而不是实际的黑客完成的一次完整的攻击流程。尽管如此，这里也包含了很多实用的细节。
