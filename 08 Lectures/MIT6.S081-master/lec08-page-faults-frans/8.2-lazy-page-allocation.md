# 8.2 Lazy page allocation

我们首先来看一下内存 allocation，或者更具体的说 sbrk。sbrk 是 XV6 提供的系统调用，它使得用户应用程序能扩大自己的 heap。当一个应用程序启动的时候，sbrk 指向的是 heap 的最底端，同时也是 stack 的最顶端。这个位置通过代表进程的数据结构中的 sz 字段表示，这里以*p->sz 表示*。

![](<../assets/image (335) (2).png>)

当调用 sbrk 时，它的参数是整数，代表了你想要申请的 page 数量（注，原视频说的是 page，但是根据 Linux [man page](https://man7.org/linux/man-pages/man2/sbrk.2.html)，实际中 sbrk 的参数是字节数）。sbrk 会扩展 heap 的上边界（也就是会扩大 heap）。

![](<../assets/image (334) (1).png>)

这意味着，当 sbrk 实际发生或者被调用的时候，内核会分配一些物理内存，并将这些内存映射到用户应用程序的地址空间，然后将内存内容初始化为 0，再返回 sbrk 系统调用。这样，应用程序可以通过多次 sbrk 系统调用来增加它所需要的内存。类似的，应用程序还可以通过给 sbrk 传入负数作为参数，来减少或者压缩它的地址空间。不过在这节课我们只关注增加内存的场景。

在 XV6 中，sbrk 的实现默认是 eager allocation。这表示了，一旦调用了 sbrk，内核会立即分配应用程序所需要的物理内存。但是实际上，对于应用程序来说很难预测自己需要多少内存，所以通常来说，应用程序倾向于申请多于自己所需要的内存。这意味着，进程的内存消耗会增加许多，但是有部分内存永远也不会被应用程序所使用到。

你或许会认为这里很蠢，怎么可以这样呢？你可以设想自己写了一个应用程序，读取了一些输入然后通过一个矩阵进行一些运算。你需要为最坏的情况做准备，比如说为最大可能的矩阵分配内存，但是应用程序可能永远也用不上这些内存，通常情况下，应用程序会在一个小得多的矩阵上进行运算。所以，程序员过多的申请内存但是过少的使用内存，这种情况还挺常见的。

原则上来说，这不是一个大问题。但是使用虚拟内存和 page fault handler，我们完全可以用某种更聪明的方法来解决这里的问题，这里就是利用 lazy allocation。核心思想非常简单，sbrk 系统调基本上不做任何事情，唯一需要做的事情就是提升*p->sz*，将*p->sz*增加 n，其中 n 是需要新分配的内存 page 数量。但是内核在这个时间点并不会分配任何物理内存。之后在某个时间点，应用程序使用到了新申请的那部分内存，这时会触发 page fault，因为我们还没有将新的内存映射到 page table。所以，如果我们解析一个大于旧的*p->sz*，但是又小于新的*p->sz（注，也就是旧的 p->sz + n）*的虚拟地址，我们希望内核能够分配一个内存 page，并且重新执行指令。

所以，当我们看到了一个 page fault，相应的虚拟地址小于当前*p->sz*，同时大于 stack，那么我们就知道这是一个来自于 heap 的地址，但是内核还没有分配任何物理内存。所以对于这个 page fault 的响应也理所当然的直接明了：在 page fault handler 中，通过 kalloc 函数分配一个内存 page；初始化这个 page 内容为 0；将这个内存 page 映射到 user page table 中；最后重新执行指令。比方说，如果是 load 指令，或者 store 指令要访问属于当前进程但是还未被分配的内存，在我们映射完新申请的物理内存 page 之后，重新执行指令应该就能通过了。

![](<../assets/image (718).png>)

> 学生提问：在 eager allocation 的场景，一个进程可能消耗了太多的内存进而耗尽了物理内存资源。如果我们不使用 eager allocation，而是使用 lazy allocation，应用程序怎么才能知道当前已经没有物理内存可用了？
>
> Frans 教授：这是个非常好的问题。从应用程序的角度来看，会有一个错觉：存在无限多可用的物理内存。但是在某个时间点，应用程序可能会用光了物理内存，之后如果应用程序再访问一个未被分配的 page，但这时又没有物理内存，这时内核可以有两个选择，我稍后会介绍更复杂的那个。你们在 lazy lab 中要做的是，返回一个错误并杀掉进程。因为现在已经 OOM（Out Of Memory）了，内核也无能为力，所以在这个时间点可以杀掉进程。
>
> 在这节课稍后的部分会介绍，可以有更加聪明的解决方案。
>
> 学生提问：如何判断一个地址是新分配的内存还是一个无效的地址？
>
> Frans 教授：在地址空间中，我们有 stack，data 和 text。通常来说我们将*p->sz*设置成一个更大的数，新分配的内存位于旧的*p->sz*和新的*p->sz*之间，但是这部分内存还没有实际在物理内存上进行分配。如果使用的地址低于*p->sz*，那么这是一个用户空间的有效地址。如果大于*p->sz*，对应的就是一个程序错误，这意味着用户应用程序在尝试解析一个自己不拥有的内存地址。希望这回答了你的问题。
>
> 学生提问：为什么我们需要杀掉进程？操作系统不能只是返回一个错误说现在已经 OOM 了，尝试做一些别的操作吧。
>
> Frans 教授：让我们稍后再回答这个问题。在 XV6 的 page fault 中，我们默认会直接杀掉进程，但是这里的处理可以更加聪明。实际的操作系统的处理都会更加聪明，尽管如此，如果最终还是找不到可用内存，实际的操作系统还是可能会杀掉进程。

为了进一步理解 lazy allocation，我们大概来看一下它的代码会是怎么样？这也是今天唯一编程相关的内容。实际上你可能会感到奇怪，相关的代码是如此的简单。这部分代码介绍对于接下来的 lazy lab 或许会有很大的帮助。

我们首先要修改的是 sys_sbrk 函数，sys_sbrk 会完成实际增加应用程序的地址空间，分配内存等等一系列相关的操作。

![](<../assets/image (649).png>)

这里我们要修改这个函数，让它只对 p->sz 加 n，并不执行增加内存的操作。

![](<../assets/image (665).png>)

修改完之后启动 XV6，并且执行“echo hi”，我们会得到一个 page fault。

![](<../assets/image (744).png>)

之所以会得到一个 page fault 是因为，在 Shell 中执行程序，Shell 会先 fork 一个子进程，子进程会通过 exec 执行 echo（注，详见 1.9）。在这个过程中，Shell 会申请一些内存，所以 Shell 会调用 sys_sbrk，然后就出错了（注，因为前面修改了代码，调用 sys_sbrk 不会实际分配所需要的内存）。

这里输出的内容包含了一些有趣的信息：

- 这里输出了 SCAUSE 寄存器内容，我们可以看到它的值是 15，表明这是一个 store page fault（详见 8.1）。
- 我们可以看到进程的 pid 是 3，这极可能是 Shell 的 pid。
- 我们还可以看到 SEPC 寄存器的值，是 0x12a4。
- 最后还可以看到出错的虚拟内存地址，也就是 STVAL 寄存器的内容，是 0x4008。

我们可以查看 Shell 的汇编代码，这是由 Makefile 创建的。我们搜索 SEPC 对应的地址，可以看到这的确是一个 store 指令。这看起来就是我们出现 page fault 的位置。

![](<../assets/image (833).png>)

如果我们向前看看汇编代码，我们可以看到 page fault 是出现在 malloc 的实现代码中。这也非常合理，在 malloc 的实现中，我们使用 sbrk 系统调用来获得一些内存，之后会初始化我们刚刚获取到的内存，在 0x12a4 位置，刚刚获取的内存中写入数据，但是实际上我们在向未被分配的内存写入数据。

另一个可以证明内存还没有分配的地方是，XV6 中 Shell 通常是有 4 个 page，包含了 text 和 data。出错的地址在 4 个 page 之外，也就是第 5 个 page，实际上我们在 4 个 page 之外 8 个字节。这也合理，因为在 0x12a4 对应的指令中，a0 持有的是 0x4000，而 8 相对 a0 的偏移量。偏移之后的地址就是我们想要使用的地址（注，也就是出错的地址）。

以上就是 page fault 的信息。我们接下来看看如何能够聪明的处理这里的 page fault。

首先查看 trap.c 中的 usertrap 函数，usertrap 在 lec06 中有介绍。在 usertrap 中根据不同的 SCAUSE 完成不同的操作。

![](<../assets/image (733).png>)

在 lec06 中，我们是因为 SCAUSE == 8 进入的 trap，这是我们处理普通系统调用的代码。如果 SCAUSE 不等于 8，接下来会检查是否有任何的设备中断，如果有的话处理相关的设备中断。如果两个条件都不满足，这里会打印一些信息，并且杀掉进程。

现在我们需要增加一个检查，判断 SCAUSE == 15，如果符合条件，我们需要一些定制化的处理。我们这里想要做什么样的定制化处理呢？

> 学生回答：我们想要检查 p->sz 是否大于当前存在 STVAL 寄存器中的虚拟地址。如果大于的话，就实际分配物理内存。

这是一种处理方式。这里我会以演示为目的简单的处理一下，在 lazy lab 中你们需要完成更多的工作。

![](<../assets/image (835).png>)

在上面增加的代码中，首先打印一些调试信息。之后分配一个物理内存 page，如果 ka 等于 0，表明没有物理内存我们现在 OOM 了，我们会杀掉进程。如果有物理内存，首先会将内存内容设置为 0，之后将物理内存 page 指向用户地址空间中合适的虚拟内存地址。具体来说，我们首先将虚拟地址向下取整，这里引起 page fault 的虚拟地址是 0x4008，向下取整之后是 0x4000。之后我们将物理内存地址跟取整之后的虚拟内存地址的关系加到 page table 中。对应的 PTE 需要设置常用的权限标志位，在这里是 u，w，r bit 位。

接下来运行一些这部分代码。先重新编译 XV6，再执行“echo hi”，我们或许可以乐观的认为现在可以正常工作了。

![](<../assets/image (713).png>)

但是实际上并没有正常工作。我们这里有两个 page fault，第一个对应的虚拟内存地址是 0x4008，但是很明显在处理这个 page fault 时，我们又有了另一个 page fault 0x13f48。现在唯一的问题是，uvmunmap 在报错，一些它尝试 unmap 的 page 并不存在。这里 unmap 的内存是什么？

> 学生回答：之前 lazy allocation 但是又没有实际分配的内存。

是的，完全正确。这里 unmap 的是之前 lazy allocated，但是又还没有用到的地址。所以对于这个内存，并没有对应的物理内存。所以在 uvmunmap 函数中，当 PTE 的 v 标志位为 0 并且没有对应的 mapping，这并不是一个实际的 panic，这是我们预期的行为。

![](<../assets/image (674).png>)

实际上，对于这个 page 我们并不用做任何事情，我们可以直接 continue 跳到下一个 page。

![](<../assets/image (698).png>)

接下来，我们再重新编译 XV6，并执行“echo hi”。

![](<../assets/image (828).png>)

现在我们可以看到 2 个 page fault，但是 echo hi 正常工作了。现在，我们一定程度上有了最基本最简单的 lazy allocation。这里有什么问题吗？

> 学生提问：我并不能理解为什么在 uvmunmap 中可以直接改成 continue？
>
> Frans 教授：之前的 panic 表明，我们尝试在释放一个并没有 map 的 page。怎么会发生这种情况呢？唯一的原因是 sbrk 增加了 p->sz，但是应用程序还没有使用那部分内存。因为对应的物理内存还没有分配，所以这部分新增加的内存的确没有映射关系。我们现在是 lazy allocation，我们只会为需要的内存分配物理内存 page。如果我们不需要这部分内存，那么就不会存在 map 关系，这非常的合理。相应的，我们对于这部分内存也不能释放，因为没有实际的物理内存可以释放，所以这里最好的处理方式就是 continue，跳过并处理下一个 page。
>
> 学生提问：在 uvmunmap 中，我认为之前的 panic 存在是有理由的，我们是不是应该判断一下，然后对于特定的场景还是 panic？
>
> Frans 教授：为什么之前的 panic 会存在？对于未修改的 XV6，永远也不会出现用户内存未 map 的情况，所以一旦出现这种情况需要 panic。但是现在我们更改了 XV6，所以我们需要去掉这里的 panic，因为之前的不可能变成了可能。

这部分内容对于下一个实验有很大的帮助，实际上这是下一个实验 3 个部分中的一个，但是很明显这部分不足以完成下一个 lazy lab。我们这里做了一些修改，但是很多地方还是有可能出错。就像有人提到的，我这里并没有检查触发 page fault 的虚拟地址是否小于*p->sz*。还有其他的可能出错的地方吗？

> 学生回答：通过 sbrk 增加的用户进程的内存数是一个整型数而不是一个无符号整型数，可能会传入负数。

是的，可能会使用负数，这意味着缩小用户内存。当我们在缩小用户内存时，我们也需要小心一些。实际上，在一个操作系统中，我们可能会在各种各样的用户场景中使用这里的 PTE，对于不同的用户场景我们或许需要稍微修改 XV6，这就是接下来的 lazy lab 的内容。你们需要完成足够多的修改，才能通过所有的测试用例。
