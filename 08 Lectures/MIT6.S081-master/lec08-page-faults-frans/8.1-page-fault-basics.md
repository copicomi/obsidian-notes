# 8.1 Page Fault Basics

今天的课程内容是 page fault，以及通过 page fault 可以实现的一系列虚拟内存功能。这里相关的功能有：

- lazy allocation，这是下一个 lab 的内容
- copy-on-write fork
- demand paging
- memory mapped files

![](<../assets/image (678).png>)

你懂的，几乎所有稍微正经的操作系统都实现了这些功能。比如 Linux 就实现了所有的这些功能。然而在 XV6 中，实话实说，一个这样的功能都没实现。在 XV6 中，一旦用户空间进程触发了 page fault，会导致进程被杀掉。这是非常保守的处理方式。

在这节课，我们将会探讨在发生 page fault 时可以做的一些有趣的事情。这节课对于代码的讲解会比较少，相应的在设计层面会有更多的内容，毕竟我们也没有代码可以讲解（因为 XV6 中没有实现）。

另一件重要的事情是，今天课程的内容对应了后面几个实验。下一个实验 lazy lab 今天会发布出来，copy-on-write fork 和 mmap 也是后续实验的内容。这些都是操作系统中非常有趣的部分，我们将会在实验中花大量时间来研究它。

在进入到具体细节之前，我们先来简单回顾一下虚拟内存。你可以认为虚拟内存有两个主要的优点：

- 第一个是 Isolation，隔离性。虚拟内存使得操作系统可以为每个应用程序提供属于它们自己的地址空间。所以一个应用程序不可能有意或者无意的修改另一个应用程序的内存数据。虚拟内存同时也提供了用户空间和内核空间的隔离性，我们在之前的课程已经谈过很多相关内容，并且你们通过 page table lab 也可以理解虚拟内存的隔离性。
- 另一个好处是 level of indirection，提供了一层抽象。处理器和所有的指令都可以使用虚拟地址，而内核会定义从虚拟地址到物理地址的映射关系。这一层抽象是我们这节课要讨论的许多有趣功能的基础。不过到目前为止，在 XV6 中内存地址的映射都比较无聊，实际上在内核中基本上是直接映射（注，也就是虚拟地址等于物理地址）。当然也有几个比较有意思的地方：
  - trampoline page，它使得内核可以将一个物理内存 page 映射到多个用户地址空间中。
  - guard page，它同时在内核空间和用户空间用来保护 Stack。

到目前为止，我们介绍的内存地址映射相对来说比较静态。不管是 user page table 还是 kernel page table，都是在最开始的时候设置好，之后就不会再做任何变动。

![](<../assets/image (783).png>)

page fault 可以让这里的地址映射关系变得动态起来。通过 page fault，内核可以更新 page table，这是一个非常强大的功能。因为现在可以动态的更新虚拟地址这一层抽象，结合 page table 和 page fault，内核将会有巨大的灵活性。我们接下来会看到各种各样利用动态变更 page table 实现的有趣的功能。

但是在那之前，首先，我们需要思考的是，什么样的信息对于 page fault 是必须的。或者说，当发生 page fault 时，内核需要什么样的信息才能够响应 page fault。

- 很明显的，我们需要出错的虚拟地址，或者是触发 page fault 的源。可以假设的是，你们在 page table lab 中已经看过一些相关的 panic，所以你们可能已经知道，当出现 page fault 的时候，XV6 内核会打印出错的虚拟地址，并且这个地址会被保存在 STVAL 寄存器中。所以，当一个用户应用程序触发了 page fault，page fault 会使用与 Robert 教授上节课介绍的相同的 trap 机制，将程序运行切换到内核，同时也会将出错的地址存放在 STVAL 寄存器中。这是我们需要知道的第一个信息。
- 我们需要知道的第二个信息是出错的原因，我们或许想要对不同场景的 page fault 有不同的响应。不同的场景是指，比如因为 load 指令触发的 page fault、因为 store 指令触发的 page fault 又或者是因为 jump 指令触发的 page fault。所以实际上如果你查看 RISC-V 的文档，在 SCAUSE（注，Supervisor cause 寄存器，保存了 trap 机制中进入到 supervisor mode 的原因）寄存器的介绍中，有多个与 page fault 相关的原因。比如，13 表示是因为 load 引起的 page fault；15 表示是因为 store 引起的 page fault；12 表示是因为指令执行引起的 page fault。所以第二个信息存在 SCAUSE 寄存器中，其中总共有 3 个类型的原因与 page fault 相关，分别是读、写和指令。ECALL 进入到 supervisor mode 对应的是 8，这是我们在上节课中应该看到的 SCAUSE 值。基本上来说，page fault 和其他的异常使用与系统调用相同的 trap 机制（注，详见 lec06）来从用户空间切换到内核空间。如果是因为 page fault 触发的 trap 机制并且进入到内核空间，STVAL 寄存器和 SCAUSE 寄存器都会有相应的值。

![](<../assets/image (702).png>)

- 我们或许想要知道的第三个信息是触发 page fault 的指令的地址。从上节课可以知道，作为 trap 处理代码的一部分，这个地址存放在 SEPC（Supervisor Exception Program Counter）寄存器中，并同时会保存在 trapframe->epc（注，详见 lec06）中。

所以，从硬件和 XV6 的角度来说，当出现了 page fault，现在有了 3 个对我们来说极其有价值的信息，分别是：

- 引起 page fault 的内存地址
- 引起 page fault 的原因类型
- 引起 page fault 时的程序计数器值，这表明了 page fault 在用户空间发生的位置

![](<../assets/image (688).png>)

我们之所以关心触发 page fault 时的程序计数器值，是因为在 page fault handler 中我们或许想要修复 page table，并重新执行对应的指令。理想情况下，修复完 page table 之后，指令就可以无错误的运行了。所以，能够恢复因为 page fault 中断的指令运行是很重要的。

接下来我们将查看不同虚拟内存功能的实现机制，来帮助我们理解如何利用 page fault handler 修复 page table 并做一些有趣的事情。
