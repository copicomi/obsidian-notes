# 8.5 Demand Paging

接下来我们将介绍 Demand paging。这是另一个非常流行的功能，许多操作系统都实现了它。

我们回到 exec，在未修改的 XV6 中，操作系统会加载程序内存的 text，data 区域，并且以 eager 的方式将这些区域加载进 page table。

![](<../assets/image (823).png>)

但是根据我们在 lazy allocation 和 zero-filled on demand 的经验，为什么我们要以 eager 的方式将程序加载到内存中？为什么不再等等，直到应用程序实际需要这些指令的时候再加载内存？程序的二进制文件可能非常的巨大，将它全部从磁盘加载到内存中将会是一个代价很高的操作。又或者 data 区域的大小远大于常见的场景所需要的大小，我们并不一定需要将整个二进制都加载到内存中。

所以对于 exec，在虚拟地址空间中，我们为 text 和 data 分配好地址段，但是相应的 PTE 并不对应任何物理内存 page。对于这些 PTE，我们只需要将 valid bit 位设置为 0 即可。

如果我们修改 XV6 使其按照上面的方式工作，我们什么时候会得到第一个 page fault 呢？或者说，用户应用程序运行的第一条指令是什么？用户应用程序在哪里启动的？

应用程序是从地址 0 开始运行。text 区域从地址 0 开始向上增长。位于地址 0 的指令是会触发第一个 page fault 的指令，因为我们还没有真正的加载内存。

![](<../assets/image (681).png>)

那么该如何处理这里的 page fault 呢？首先我们可以发现，这些 page 是 on-demand page。我们需要在某个地方记录了这些 page 对应的程序文件，我们在 page fault handler 中需要从程序文件中读取 page 数据，加载到内存中；之后将内存 page 映射到 page table；最后再重新执行指令。

![](<../assets/image (815).png>)

之后程序就可以运行了。在最坏的情况下，用户程序使用了 text 和 data 中的所有内容，那么我们将会在应用程序的每个 page 都收到一个 page fault。但是如果我们幸运的话，用户程序并没有使用所有的 text 区域或者 data 区域，那么我们一方面可以节省一些物理内存，另一方面我们可以让 exec 运行的更快（注，因为不需要为整个程序分配内存）。

前面描述的流程其实是有点问题的。我们将要读取的文件，它的 text 和 data 区域可能大于物理内存的容量。又或者多个应用程序按照 demand paging 的方式启动，它们二进制文件的和大于实际物理内存的容量。对于 demand paging 来说，假设内存已经耗尽了或者说 OOM 了，这个时候如果得到了一个 page fault，需要从文件系统拷贝中拷贝一些内容到内存中，但这时你又没有任何可用的物理内存 page，这其实回到了之前的一个问题：在 lazy allocation 中，如果内存耗尽了该如何办？

如果内存耗尽了，一个选择是撤回 page（evict page）。比如说将部分内存 page 中的内容写回到文件系统再撤回 page。一旦你撤回并释放了 page，那么你就有了一个新的空闲的 page，你可以使用这个刚刚空闲出来的 page，分配给刚刚的 page fault handler，再重新执行指令。

![](<../assets/image (650).png>)

重新运行指令稍微有些复杂，这包含了整个 userret 函数背后的机制以及将程序运行切换回用户空间等等。

以上就是常见操作系统的行为。这里的关键问题是，什么样的 page 可以被撤回？并且该使用什么样的策略来撤回 page？

> 学生回答：Least Recently Used

是的，这是最常用的策略，Least Recently Used，或者叫 LRU。除了这个策略之外，还有一些其他的小优化。如果你要撤回一个 page，你需要在 dirty page 和 non-dirty page 中做选择。dirty page 是曾经被写过的 page，而 non-dirty page 是只被读过，但是没有被写过的 page。你们会选择哪个来撤回？

> 学生回答：我会选择 dirty page，因为它在某个时间点会被重新写回到内存中。

如果 dirty page 之后再被修改，现在你或许需要对它写两次了（注，一次内存，一次文件），现实中会选择 non-dirty page。如果 non-dirty page 出现在 page table1 中，你可以将内存 page 中的内容写到文件中，之后将相应的 PTE 标记为 non-valid，这就完成了所有的工作。之后你可以在另一个 page table 重复使用这个 page。所以通常来说这里优先会选择 non-dirty page 来撤回。

> 学生提问：对于一个 cache，我们可以认为它被修改了但是还没有回写到后端存储时是 dirty 的。那么对于内存 page 来说，怎么判断 dirty？它只存在于内存中，而不存在于其他地方。那么它什么时候会变成 dirty 呢？
>
> Frans 教授：对于 memory mapped files，你将一个文件映射到内存中，然后恢复它，你就会设置内存 page 为 dirty。
>
> 学生提问：所以这只对一个不仅映射了内存，还映射了文件的 page 有效？
>
> Frans 教授：是的，完全正确。（注，这里应该是答非所问，一个 page 只要最近被写过，那么就会是 dirty 的）

如果你们再看 PTE，我们有 RSW 位，你们可以发现在 bit7，对应的就是 Dirty bit。当硬件向一个 page 写入数据，会设置 dirty bit，之后操作系统就可以发现这个 page 曾经被写入了。类似的，还有一个 Access bit，任何时候一个 page 被读或者被写了，这个 Access bit 会被设置。

![](<../assets/image (737).png>)

为什么这两个信息重要呢？它们能怎样帮助内核呢？

> 学生回答：没有被 Access 过的 page 可以直接撤回，是吗？

是的，或者说如果你想实现 LRU，你需要找到一个在一定时间内没有被访问过的 page，那么这个 page 可以被用来撤回。而被访问过的 page 不能被撤回。所以 Access bit 通常被用来实现这里的 LRU 策略。

> 学生提问：那是不是要定时的将 Access bit 恢复成 0？
>
> Frans 教授：是的，这是一个典型操作系统的行为。操作系统会扫描整个内存，这里有一些著名的算法例如 clock algorithm，就是一种实现方式。
>
> 另一个学生提问：为什么需要恢复这个 bit？
>
> Frans 教授：如果你想知道 page 最近是否被使用过，你需要定时比如每 100 毫秒或者每秒清除 Access bit，如果在下一个 100 毫秒这个 page 被访问过，那你就知道这个 page 在上一个 100 毫秒中被使用了。而 Access bit 为 0 的 page 在上 100 毫秒未被使用。这样你就可以统计每个内存 page 使用的频度，这是一个成熟的 LRU 实现的基础。（注，可以通过 Access bit 来决定内存 page 在 LRU 中的排名）
