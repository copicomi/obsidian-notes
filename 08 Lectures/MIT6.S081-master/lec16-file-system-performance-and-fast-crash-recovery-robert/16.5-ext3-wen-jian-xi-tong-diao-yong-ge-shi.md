# 16.5 ext3 文件系统调用格式

接下来我们大概过一下 Linux 中的文件系统调用，并介绍抽象上每个系统调用的结构。

在 Linux 的文件系统中，我们需要每个系统调用都声明一系列写操作的开始和结束。实际上在任何 transaction 系统中，都需要明确的表示开始和结束，这样之间的所有内容都是原子的。所以系统调用中会调用 start 函数。ext3 需要知道当前正在进行的系统调用个数，所以每个系统调用在调用了 start 函数之后，会得到一个 handle，它某种程度上唯一识别了当前系统调用。当前系统调用的所有写操作都是通过这个 handle 来识别跟踪的（注，handle 是 ext3 transaction 中的一部分数据，详见 16.3）。

![](<../assets/image (410).png>)

之后系统调用需要读写 block，它可以通过 get 获取 block 在 buffer 中的缓存，同时告诉 handle 这个 block 需要被读或者被写。如果你需要更改多个 block，类似的操作可能会执行多次。之后是修改位于缓存中的 block。

![](<../assets/image (428).png>)

当这个系统调用结束时，它会调用 stop 函数，并将 handle 作为参数传入。

![](<../assets/image (518).png>)

除非 transaction 中所有已经开始的系统调用都完成了，transaction 是不能 commit 的。因为可能有多个 transaction，文件系统需要有种方式能够记住系统调用属于哪个 transaction，这样当系统调用结束时，文件系统就知道这是哪个 transaction 正在等待的系统调用，所以 handle 需要作为参数传递给 stop 函数。

因为每个 transaction 都有一堆 block 与之关联，修改这些 block 就是 transaction 的一部分内容，所以我们将 handle 作为参数传递给 get 函数是为了告诉 logging 系统，这个 block 是 handle 对应的 transaction 的一部分。

stop 函数并不会导致 transaction 的 commit，它只是告诉 logging 系统，当前的 transaction 少了一个正在进行的系统调用。transaction 只能在所有已经开始了的系统调用都执行了 stop 之后才能 commit。所以 transaction 需要记住所有已经开始了的 handle，这样才能在系统调用结束的时候做好记录。
