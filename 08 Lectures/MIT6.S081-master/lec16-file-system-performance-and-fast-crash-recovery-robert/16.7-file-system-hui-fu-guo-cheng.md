# 16.7 ext3 file system 恢复过程

为了简化重启时恢复软件的工作，当决定释放某段 log 空间时，文件系统会更新 super block 中的指针将其指向当前最早的 transaction 的起始位置。

![](<../assets/image (501).png>)

之后如果 crash 并重启，恢复软件会读取 super block，并找到 log 的起始位置。所以如果 crash 了，内存中的所有数据都会消失，例如文件系统中记录的哪些 block 被写入到了磁盘中这些信息都会丢失，所以可以假设这时内存中没有可用的数据，唯一可用的数据存在于磁盘中。当然我们这里的讨论都是基于磁盘还是完好的，所以你可以认为只是一次电力故障，系统突然停止了运行过程，在电力恢复时，断电那一瞬间磁盘中的数据还存在。我们并没有考虑磁盘被损坏或者被摧毁的情况。

crash 或许会打断任何在进行中的 transaction，或许 transaction 正在 commit，或许 transaction 正在向文件系统写 block。让我重新画一个例子，我们在 log 中有一个 super block，之后是 transaction T6，T7，T8，在 T8 之后是一个已近被释放了 log 空间的 T5，假设 T8 已经用了 T5 的一部分空间。并且现在 super block 指向的是 T6 的起始位置，因为 T6 是最早的 transaction。

![](<../assets/image (471).png>)

现在 crash 并重启，恢复软件读取 super block 就可以知道 log 的起始位置，之后恢复软件会在 log 中一直扫描并尝试找到 log 的结束位置，现在我们需要有一种方式确定 log 的结束位置。我们知道每个 transaction 包含了一个 descriptor block，里面记录了该 transaction 中包含了多少个 data block，假设 descriptor block 记录了 17 个 block，那么恢复软件会扫描 17 个 data block，最后是 commit block。这样可以一直扫描到 T8。

![](<../assets/image (600).png>)

在扫描 T8 时有两种可能，一种可能是 T8 完成了 commit，并且包含了 commit block。这时恢复软件并不知道 T8 就是最后一个 transaction，所以它会接着看 T8 的 commit block 的下一个 block，来看看这是不是一个有效的 descriptor block。我们知道这不是一个 descriptor block，而是一个包含在 T5 内的随机 block。现在的问题是恢复软件如何可靠的区分出来呢？是的，每个 descriptor 和 commit block 都以某个魔法数字作为起始，这是一个 32bit 的数字。所以如果扫描完了 T8，下一个 block 以魔法数字作为起始，那么恢复软件就会认为这是一个 descriptor block。（注，也有可能 T5 正好完美的跟在 T8 后面，也就是说 T8 的 commit block 之后就是 T5 的 descriptor block，同时 T5 的 commit block 也存在，所以这里必然还需要一些其他的机制，我猜是用到了 transaction 的序列号）

但是，现在我们看到的 block 可能是包含了任意数据的 data block，所以它可能是文件中的一个 data block 并且也是以魔法数字作为起始。所以这里的最后一个细节是，logging 系统需要能区分一个以魔法数字作为起始的 descriptor block 和一个以魔法数字作为起始的 data block。你可以想到各种方法来实现这种区分，ext3 是这样做的，当它向 log 写一个 block 时，如果这个 block 既不是 descriptor block 也不是 commit block，但是又以魔法数字作为起始，文件系统会以 0 替换前 32bit，并在 transaction 的 descriptor block 中为该 data block 设置一个 bit。这个 bit 表示，对应的 data block 本来是以魔法数字作为起始，但是现在我们将其替换成了 0。而恢复软件会检查这个 bit 位，在将 block 写回到文件系统之前，会用魔法数字替换 0。

因此，在 log 中，除了 descriptor 和 commit block，不会有其他的 block 以这 32bit 的魔法数字作为起始。所以我们不会有模棱两可的判断，如果一个 commit block 之后的 block 以魔法数字作为起始，那么它必然是一个 descriptor block。所以恢复软件会从 super block 指向的位置开始一直扫描，直到：

- 某个 commit block 之后的一个 block 并不是 descriptor block
- 或者某个 commit block 之后是 descriptor block，但是根据 descriptor block 找到的并不是一个 commit block

这时，恢复软件会停止扫描，并认为最后一个有效的 commit block 是 log 的结束位置。或许在最后一个 commit block 之后会跟一个并没有 commit 完成的 transaction（注，上面的第二种情况），但是恢复软件会忽略未完成的 transaction，因为这个 transaction 并没有包含所有的写操作，所以它并不能原子性的恢复。之后恢复软件会回到 log 的最开始位置，并将每个 log block 写入到文件系统的实际位置，直到走到最后一个有效的 commit block。之后才是启动剩下的操作系统，并且运行普通的程序。在恢复完成之前，是不能运行任何程序的，因为这个时候文件系统并不是有效的。

> 学生提问：XV6 相比这里的 log 机制，缺少了什么呢？
>
> Robert 教授：XV6 主要缺失的是在 log 中包含多个 transaction 的能力，在 XV6 的 log 中最多只会有一个 transaction，所以在 XV6 中缺少了并发的能力。比如说当我在执行 transaction T7 的系统调用时，ext3 可以同时向磁盘提交 T6，而这在 XV6 中这是不可能的，因为 log 只保存了一个 transaction。所以我们必须先完成一个 transaction 的所有工作，之后才能开始下一个 transaction。所以 XV6 是简单且正确的，但是缺少了并发的能力。
>
> 学生提问：但是在 XV6 我还是可以有多个 transaction，只是说不能异步的执行它们，对吗？
>
> Robert 教授：这里其实有点模糊，XV6 实际上允许在一个 transaction 中包含多个系统调用（注，详见 15.8），所以 XV6 有一些并发和 batching 的能力，但是当 XV6 决定要 commit 一个 transaction 时，在完全完成这个 transaction 之前，是不能执行任何新的系统调用的。因为直到前一个 transaction 完全完成，并没有 log 空间来存放新的系统调用。所以 XV6 要么是在运行一些系统调用，要么是在 commit transaction，但是它不能同时干这两件事情，而 ext3 可以同时干这两件事情。
