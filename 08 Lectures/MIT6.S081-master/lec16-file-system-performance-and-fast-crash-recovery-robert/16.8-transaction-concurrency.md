# 16.8 为什么新 transaction 需要等前一个 transaction 中系统调用执行完成

以上就是 ext3 中相对来说直观的部分。实际上还有一些棘手的细节我想讨论一下。之前我提到过，ext3 中存在一个 open transaction，但是当 ext3 决定要关闭该 transaction 时，它需要等待该 transaction 中的所有系统调用都结束，之后才能开始新的 transaction。假设我们现在有 transaction T1，其中包含了多个系统调用。

![](<../assets/image (586).png>)

如果我们想要关闭 T1，我们需要停止接收新的系统调用，因为我们想要等待现有的系统调用结束，这样才能 commit transaction。所以直到这些系统调用都结束了，在 ext3 中不能允许开始任何新的系统调用。所以只有在 T1 中的系统调用完成之后，才能开始在接下来的 transaction T2 中接收系统调用。在这之间有一段时间，新的系统调用是被拦截的，这降低了性能，因为我们本来应该执行系统调用的但是又不被允许。

![](<../assets/image (534).png>)

这里的问题是，直到 T1 中所有的系统调用都结束之前，ext3 为什么不让 T2 中的系统调用开始执行呢？让我们来看一下没有这个限制条件可能会带来的错误的场景。我们假设 T1 只包含了一个系统调用，这是一个 create 系统调用用来创建文件 x。在 create 系统调用结束之前，文件系统决定开始一个新的 transaction T2 用来接收 create 之后的所有系统调用。我们假设 T2 在 T1 结束之前就开始了，T2 对另一个文件 y 调用了 unlink 系统调用。unlink 会释放与 y 关联的 inode。

![](<../assets/image (462).png>)

假设在下面的时间点 T2 将 inode 标记为空闲的，create 会为 x 分配 inode，或许它在之后的一个时间点分配了 inode。

![](<../assets/image (557).png>)

因为 create 在 unlink 释放 inode 之后分配的 inode，它可能会重用同一个 inode，所以 x 可能会获得 y 的 inode，假设是 inode 17。目前为止没有问题，因为 unlink 本来就是释放 inode。当 T1 中的 create 结束之后，我们会关闭 T1，在最后我们会将 T1 的所有更新都写入到磁盘的 log 中。之后 unlink 还要花点时间才能结束，但是在它结束之前计算机 crash 了。

![](<../assets/image (423).png>)

在重启并运行恢复软件时，可以发现 T1 已经 commit 了，而 T2 没有。所以恢复软件会完全忽略 T2，这意味着 T2 中的 unlink 就跟没有发生过一样，恢复软件不会执行 T2 中的 unlink，也就不会删除文件 y。所以 crash 并重启之后 y 文件仍然存在，并还在使用 inode 17。然而 T1 又完成了，x 文件使用的也是 inode 17，所以现在我们错误的有了两个文件都使用了相同的 inode，这意味着它们共享了文件内容，向一个文件写数据会神奇的出现在另一个文件中。这完全是错误的，因为我们本来想的是删除 y，并为 x 分配一个空闲的 inode，而不是一个已经在使用中的 inode。这里可以这么想，T2 中的 unlink 修改了一个 block，最终这个修改过的 block 被前一个 transaction 所使用。T2 中修改的信息，被 T1 所使用了，这意味着我们丢失了 T2 的原子性。因为 T2 的目标是 unlink 的效果要么是全发生，要么是完全不发生。但是刚刚的例子中，因为 T1 使用了 T2 中释放的 inode，这意味着 T2 中部分修改已经生效了，但是其他的修改随着 crash 又丢失了。

或许你可以想到一些修复这里问题的方法，或许 T1 可以发现 inode 是由后一个 transaction 释放的而不去使用它。而 ext3 采用了一个非常简单的方法，在前一个 transaction 中所有系统调用都结束之前，它不允许任何新的系统调用执行。所以 transaction T1 也就不可能看到之后的 transaction 包含的更新。因为直到 T1 commit 了，整个 unlink 都不被允许执行。

> 学生提问：当你关闭一个 open transaction 时，具体会发生什么呢？会对当前的缓存做一个快照吗？
>
> Robert 教授：会的，当我们关闭一个 transaction，文件系统会拷贝被 transaction 中的系统调用所修改的所有 block，之后 transaction 才会 commit 这些 block。后面的 transaction 会在真正的 block cache 上运行。当将 block 都 commit 到 log 之后，对于 block cache 的拷贝就可以丢弃了。

以上是众多 ext3 需要处理的小细节之一，因为为了支持并发，ext3 需要处理各种各样的特殊细节，但是我们没有时间讨论所有的细节。
