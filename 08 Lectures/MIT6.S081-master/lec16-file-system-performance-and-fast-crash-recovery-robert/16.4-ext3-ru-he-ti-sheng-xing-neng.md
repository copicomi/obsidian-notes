# 16.4 ext3 如何提升性能

ext3 通过 3 种方式提升了性能：

- 首先，它提供了异步的（asynchronous）系统调用，也就是说系统调用在写入到磁盘之前就返回了，系统调用只会更新缓存在内存中的 block，并不用等待写磁盘操作。不过它可能会等待读磁盘。
- 第二，它提供了批量执行（batching）的能力，可以将多个系统调用打包成一个 transaction。
- 最后，它提供了并发（concurrency）。

![](<../assets/image (508).png>)

这些基本上就是 ext3 有的，而 XV6 没有的特性。接下来我将一一介绍这里的特性。

> 学生提问：有关 batching，XV6 不是也支持多个系统调用同时执行 start_op 和 end_op，然后再一起 commit 吗？
>
> Robert 教授：是的，XV6 具备有限能力的 batching。

首先是异步的系统调用。这表示系统调用修改完位于缓存中的 block 之后就返回，并不会触发写磁盘。所以这里明显的优势就是系统调用能够快速的返回。同时它也使得 I/O 可以并行的运行，也就是说应用程序可以调用一些文件系统的系统调用，但是应用程序可以很快从系统调用中返回并继续运算，与此同时文件系统在后台会并行的完成之前的系统调用所要求的写磁盘操作。这被称为 I/O concurrency，如果没有异步系统调用，很难获得 I/O concurrency，或者说很难同时进行磁盘操作和应用程序运算，因为同步系统调用中，应用程序总是要等待磁盘操作结束才能从系统调用中返回。

另一个异步系统调用带来的好处是，它使得大量的批量执行变得容易。

异步系统调用的缺点是系统调用的返回并不能表示系统调用应该完成的工作实际完成了。举个例子，如果你创建了一个文件并写了一些数据然后关闭文件并在 console 向用户输出 done，最后你把电脑的电给断了。尽管所有的系统调用都完成了，程序也输出了 done，但是在你重启之后，你的数据并不一定存在。这意味着，在异步系统调用的世界里，如果应用程序关心可能发生的 crash，那么应用程序代码应该更加的小心。这在 XV6 并不是什么大事，因为如果 XV6 中的 write 返回了，那么数据就在磁盘上，crash 之后也还在。而 ext3 中，如果 write 返回了，你完全不能确定 crash 之后数据还在不在。所以一些应用程序的代码应该仔细编写，例如对于数据库，对于文本编辑器，我如果写了一个文件，我不想在我写文件过程断电然后再重启之后看到的是垃圾文件或者不完整的文件，我想看到的要么是旧的文件，要么是新的文件。

所以文件系统对于这类应用程序也提供了一些工具以确保在 crash 之后可以有预期的结果。这里的工具是一个系统调用，叫做 fsync，所有的 UNIX 都有这个系统调用。这个系统调用接收一个文件描述符作为参数，它会告诉文件系统去完成所有的与该文件相关的写磁盘操作，在所有的数据都确认写入到磁盘之后，fsync 才会返回。所以如果你查看数据库，文本编辑器或者一些非常关心文件数据的应用程序的源代码，你将会看到精心放置的对于 fsync 的调用。fsync 可以帮助解决异步系统调用的问题。对于大部分程序，例如编译器，如果 crash 了编译器的输出丢失了其实没什么，所以许多程序并不会调用 fsync，并且乐于获得异步系统调用带来的高性能。

> 学生提问：这是不是有时也被称为 flush，因为我之前经常听到这个单词？
>
> Robert 教授：是的，一个合理的解释 fsync 的工作的方式是，它 flush 了所有文件相关的写磁盘操作到了磁盘中，之后再返回，所以 flush 也是针对这个场景的一个合理的单词。

![](<../assets/image (514).png>)

以上就是异步系统调用，下一个 ext3 使用的技术是批量执行（batching）。在任何时候，ext3 只会有一个 open transaction。ext3 中的一个 transaction 可以包含多个不同的系统调用。所以 ext3 是这么工作的：它首先会宣告要开始一个新的 transaction，接下来的几秒所有的系统调用都是这个大的 transaction 的一部分。我认为默认情况下，ext3 每 5 秒钟都会创建一个新的 transaction，所以每个 transaction 都会包含 5 秒钟内的系统调用，这些系统调用都打包在一个 transaction 中。在 5 秒钟结束的时候，ext3 会 commit 这个包含了可能有数百个更新的大 transaction。

为什么这是个好的方案呢？

- 首先它在多个系统调用之间分摊了 transaction 带来的固有的损耗。固有的损耗包括写 transaction 的 descriptor block 和 commit block；在一个机械硬盘中需要查找 log 的位置并等待磁碟旋转，这些都是成本很高的操作，现在只需要对一批系统调用执行一次，而不用对每个系统调用执行一次这些操作，所以 batching 可以降低这些损耗带来的影响。
- 另外，它可以更容易触发 write absorption。经常会有这样的情况，你有一堆系统调用最终在反复更新相同的一组磁盘 block。举个例子，如果我创建了一些文件，我需要分配一些 inode，inode 或许都很小只有 64 个字节，一个 block 包含了很多个 inode，所以同时创建一堆文件只会影响几个 block 的数据。类似的，如果我向一个文件写一堆数据，我需要申请大量的 data block，我需要修改表示 block 空闲状态的 bitmap block 中的很多个 bit 位，如果我分配到的是相邻的 data block，它们对应的 bit 会在同一个 bitmap block 中，所以我可能只是修改一个 block 的很多个 bit 位。所以一堆系统调用可能会反复更新一组相同的磁盘 block。通过 batching，多次更新同一组 block 会先快速的在内存的 block cache 中完成，之后在 transaction 结束时，一次性的写入磁盘的 log 中。这被称为 write absorption，相比一个类似于 XV6 的同步文件系统，它可以极大的减少写磁盘的总时间。
- 最后就是 disk scheduling。假设我们要向磁盘写 1000 个 block，不论是在机械硬盘还是 SSD（机械硬盘效果会更好），一次性的向磁盘的连续位置写入 1000 个 block，要比分 1000 次每次写一个不同位置的磁盘 block 快得多。我们写 log 就是向磁盘的连续位置写 block。通过向磁盘提交大批量的写操作，可以更加的高效。这里我们不仅通过向 log 中连续位置写入大量 block 来获得更高的效率，甚至当我们向文件系统分区写入包含在一个大的 transaction 中的多个更新时，如果我们能将大量的写请求同时发送到驱动，即使它们位于磁盘的不同位置，我们也使得磁盘可以调度这些写请求，并以特定的顺序执行这些写请求，这也很有效。在一个机械硬盘上，如果一次发送大量需要更新 block 的写请求，驱动可以对这些写请求根据轨道号排序。甚至在一个固态硬盘中，通过一次发送给硬盘大量的更新操作也可以稍微提升性能。所以，只有发送给驱动大量的写操作，才有可能获得 disk scheduling。这是 batching 带来的另一个好处。

![](<../assets/image (425).png>)

ext3 使用的最后一个技术就是 concurrency，相比 XV6 这里包含了两种 concurrency。

- 首先 ext3 允许多个系统调用同时执行，所以我们可以有并行执行的多个不同的系统调用。在 ext3 决定关闭并 commit 当前的 transaction 之前，系统调用不必等待其他的系统调用完成，它可以直接修改作为 transaction 一部分的 block。许多个系统调用都可以并行的执行，并向当前 transaction 增加 block，这在一个多核计算机上尤其重要，因为我们不会想要其他的 CPU 核在等待锁。在 XV6 中，如果当前的 transaction 还没有完成，新的系统调用不能继续执行。而在 ext3 中，大多数时候多个系统调用都可以更改当前正在进行的 transaction。
- 另一种 ext3 提供的并发是，可以有多个不同状态的 transaction 同时存在。所以尽管只有一个 open transaction 可以接收系统调用，但是其他之前的 transaction 可以并行的写磁盘。这里可以并行存在的不同 transaction 状态包括了：
  - 首先是一个 open transaction
  - 若干个正在 commit 到 log 的 transaction，我们并不需要等待这些 transaction 结束。当之前的 transaction 还没有 commit 并还在写 log 的过程中，新的系统调用仍然可以在当前的 open transaction 中进行。
  - 若干个正在从 cache 中向文件系统 block 写数据的 transaction
  - 若干个正在被释放的 transaction，这个并不占用太多的工作

通常来说会有位于不同阶段的多个 transaction，新的系统调用不必等待旧的 transaction 提交到 log 或者写入到文件系统。对比之下，XV6 中新的系统调用就需要等待前一个 transaction 完全完成。

![](<../assets/image (480).png>)

> 学生提问：如果一个 block cache 正在被更新，而这个 block 又正在被写入到磁盘的过程中，会怎样呢？
>
> Robert 教授：这的确会是一个问题，这里有个潜在的困难点，因为 transaction 写入到 log 中的内容只能包含由该 transaction 中的系统调用所做的更新，而不能包含在该 transaction 之后的系统调用的更新。因为如果这么做了的话，那么可能 log 中会只包含系统调用的部分更新，而我们需要确保 transaction 包含系统调用的所有更新。所以我们不能承担 transaction 包含任何在该 transaction 之后的更新的风险。
>
> ext3 是这样解决这个问题的，当它决定结束当前的 open transaction 时，它会在内存中拷贝所有相关的 block，之后 transaction 的 commit 是基于这些 block 的拷贝进行的。所以 transaction 会有属于自己的 block 的拷贝。为了保证这里的效率，操作系统会使用 copy-on-write（注，详见 8.4）来避免不必要的拷贝，这样只有当对应的 block 在后面的 transaction 中被更新了，它在内存中才会实际被拷贝。

concurrency 之所以能帮助提升性能，是因为它可以帮助我们并行的运行系统调用，我们可以得到多核的并行能力。如果我们可以在运行应用程序和系统调用的同时，来写磁盘，我们可以得到 I/O concurrency，也就是同时运行 CPU 和磁盘 I/O。这些都能帮助我们更有效，更精细的使用硬件资源。
