# 16.2 XV6 File system logging 回顾

首先来回顾一下 XV6 的 logging 系统。我们有一个磁盘用来存储 XV6 的文件系统，你可以认为磁盘分为了两个部分：

- 首先是文件系统目录的树结构，以 root 目录为根节点，往下可能有其他的目录，我们可以认为目录结构就是一个树状的数据结构。假设 root 目录下有两个子目录 D1 和 D2，D1 目录下有两个文件 F1 和 F2，每个文件又包含了一些 block。除此之外，还有一些其他并非是树状结构的数据，比如 bitmap 表明了每一个 data block 是空闲的还是已经被分配了。inode，目录内容，bitmap block，我们将会称之为 metadata block（注，Frans 和 Robert 在这里可能有些概念不统一，对于 Frans 来说，目录内容应该也属于文件内容，目录是一种特殊的文件，详见 14.3；而对于 Robert 来说，目录内容是 metadata。），另一类就是持有了文件内容的 block，或者叫 data block。

![](<../assets/image (474).png>)

- 除了文件系统之外，XV6 在磁盘最开始的位置还有一段 log。XV6 的 log 相对来说比较简单，它有 header block，之后是一些包含了有变更的文件系统 block，这里可以是 metadata block 也可以是 data block。header block 会记录之后的每一个 log block 应该属于文件系统中哪个 block，假设第一个 log block 属于 block 17，第二个属于 block 29。

![](<../assets/image (521).png>)

在计算机上，我们会有一些用户程序调用 write/create 系统调用来修改文件系统。在内核中存在 block cache，最初 write 请求会被发到 block cache。block cache 就是磁盘中 block 在内存中的拷贝，所以最初对于文件 block 或者 inode 的更新走到了 block cache。

![](<../assets/image (495).png>)

在 write 系统调用的最后，这些更新都被拷贝到了 log 中，之后我们会更新 header block 的计数来表明当前的 transaction 已经结束了。在文件系统的代码中，任何修改了文件系统的系统调用函数中，某个位置会有 begin_op，表明马上就要进行一系列对于文件系统的更新了，不过在完成所有的更新之前，不要执行任何一个更新。在 begin_op 之后是一系列的 read/write 操作。最后是 end_op，用来告诉文件系统现在已经完成了所有 write 操作。所以在 begin_op 和 end_op 之间，所有的 write block 操作只会走到 block cache 中。当系统调用走到了 end_op 函数，文件系统会将修改过的 block cache 拷贝到 log 中。

![](<../assets/image (582).png>)

在拷贝完成之后，文件系统会将修改过的 block 数量，通过一个磁盘写操作写入到 log 的 header block，这次写入被称为 commit point。在 commit point 之前，如果发生了 crash，在重启时，整个 transaction 的所有写磁盘操作最后都不会应用。在 commit point 之后，即使立即发生了 crash，重启时恢复软件会发现在 log header 中记录的修改过的 block 数量不为 0，接下来就会将 log header 中记录的所有 block，从 log 区域写入到文件系统区域。

这里实际上使得系统调用中位于 begin_op 和 end_op 之间的所有写操作在面对 crash 时具备原子性。也就是说，要么文件系统在 crash 之前更新了 log 的 header block，这样所有的写操作都能生效；要么 crash 发生在文件系统更新 log 的 header block 之前，这样没有一个写操作能生效。

在 crash 并重启时，必须有一些恢复软件能读取 log 的 header block，并判断里面是否记录了未被应用的 block 编号，如果有的话，需要写（也有可能是重写）log block 到文件系统中对应的位置；如果没有的话，恢复软件什么也不用做。

这里有几个超级重要的点，不仅针对 XV6，对于大部分 logging 系统都适用：

- 包括 XV6 在内的所有 logging 系统，都需要遵守 write ahead rule。这里的意思是，任何时候如果一堆写操作需要具备原子性，系统需要先将所有的写操作记录在 log 中，之后才能将这些写操作应用到文件系统的实际位置。也就是说，我们需要预先在 log 中定义好所有需要具备原子性的更新，之后才能应用这些更新。write ahead rule 是 logging 能实现故障恢复的基础。write ahead rule 使得一系列的更新在面对 crash 时具备了原子性。
- 另一点是，XV6 对于不同的系统调用复用的是同一段 log 空间，但是直到 log 中所有的写操作被更新到文件系统之前，我们都不能释放或者重用 log。我将这个规则称为 freeing rule，它表明我们不能覆盖或者重用 log 空间，直到保存了 transaction 所有更新的这段 log，都已经反应在了文件系统中。

所以在 XV6 中，end_op 做了大量的工作，首先是将所有的 block 记录在 log 中，之后是更新 log header。在没有 crash 的正常情况，文件系统需要再次将所有的 block 写入到磁盘的文件系统中。磁盘中的文件系统更新完成之后，XV6 文件系统还需要删除 header block 记录的变更了的 block 数量，以表明 transaction 已经完成了，之后就可以重用 log 空间。

在向 log 写入任何新内容之前，删除 header block 中记录的 block 数量也很重要。因为你不会想要在 header block 中记录的还是前一个 transaction 的信息，而 log 中记录的又是一个新的 transaction 的数据。可以假设新的 transaction 对应的是与之前不同的 block 编号的数据，这样的话，在 crash 重启时，log 中的数据会被写入到之前记录的旧的 block 编号位置。所以我们必须要先清除 header block。

freeing rule 的意思就是，在从 log 中删除一个 transaction 之前，我们必须将所有 log 中的所有 block 都写到文件系统中。

![](<../assets/image (454).png>)

这些规则使得，就算一个文件系统更新可能会复杂且包含多个写操作，但是每次更新都是原子的，在 crash 并重启之后，要么所有的写操作都生效，要么没有写操作能生效。

要介绍 Linux 的 logging 方案，就需要了解 XV6 的 logging 有什么问题？为什么 Linux 不使用与 XV6 完全一样的 logging 方案？这里的回答简单来说就是 XV6 的 logging 太慢了。

XV6 中的任何一个例如 create/write 的系统调用，需要在整个 transaction 完成之后才能返回。所以在创建文件的系统调用返回到用户空间之前，它需要完成所有 end_op 包含的内容，这包括了：

- 将所有更新了的 block 写入到 log
- 更新 header block
- 将 log 中的所有 block 写回到文件系统分区中
- 清除 header block

之后才能从系统调用中返回。在任何一个文件系统调用的 commit 过程中，不仅是占据了大量的时间，而且其他系统调用也不能对文件系统有任何的更新。所以这里的系统调用实际上是一次一个的发生，而每个系统调用需要许多个写磁盘的操作。这里每个系统调用需要等待它包含的所有写磁盘结束，对应的技术术语被称为 synchronize。XV6 的系统调用对于写磁盘操作来说是同步的（synchronized），所以它非常非常的慢。在使用机械硬盘时，它出奇的慢，因为每个写磁盘都需要花费 10 毫秒，而每个系统调用又包含了多个写磁盘操作。所以 XV6 每秒只能完成几个更改文件系统的系统调用。如果我们在 SSD 上运行 XV6 会快一些，但是离真正的高效还差得远。

另一件需要注意的更具体的事情是，在 XV6 的 logging 方案中，每个 block 都被写了两次。第一次写入到了 log，第二次才写入到实际的位置。虽然这么做有它的原因，但是 ext3 可以一定程度上修复这个问题。
