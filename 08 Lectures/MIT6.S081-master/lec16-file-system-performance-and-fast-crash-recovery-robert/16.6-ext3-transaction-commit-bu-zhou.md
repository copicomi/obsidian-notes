# 16.6 ext3 transaction commit 步骤

基于上面的系统调用的结构，接下来我将介绍 commit transaction 完整的步骤。每隔 5 秒，文件系统都会 commit 当前的 open transaction，下面是 commit transaction 涉及到的步骤：

1. 首先需要阻止新的系统调用。当我们正在 commit 一个 transaction 时，我们不会想要有新增的系统调用，我们只会想要包含已经开始了的系统调用，所以我们需要阻止新的系统调用。这实际上会损害性能，因为在这段时间内系统调用需要等待并且不能执行。
2. 第二，需要等待包含在 transaction 中的已经开始了的系统调用们结束。所以我们需要等待 transaction 中未完成的系统调用完成，这样 transaction 能够反映所有的写操作。
3. 一旦 transaction 中的所有系统调用都完成了，也就是完成了更新 cache 中的数据，那么就可以开始一个新的 transaction，并且让在第一步中等待的系统调用继续执行。所以现在需要为后续的系统调用开始一个新的 transaction。
4. 还记得 ext3 中的 log 包含了 descriptor，data 和 commit block 吗？现在我们知道了 transaction 中包含的所有的系统调用所修改的 block，因为系统调用在调用 get 函数时都将 handle 作为参数传入，表明了 block 对应哪个 transaction。接下来我们可以更新 descriptor block，其中包含了所有在 transaction 中被修改了的 block 编号。
5. 我们还需要将被修改了的 block，从缓存中写入到磁盘的 log 中。之前有同学问过，新的 transaction 可能会修改相同的 block，所以在这个阶段，我们写入到磁盘 log 中的是 transaction 结束时，对于相关 block cache 的拷贝。所以这一阶段是将实际的 block 写入到 log 中。
6. 接下来，我们需要等待前两步中的写 log 结束。
7. 之后我们可以写入 commit block。
8. 接下来我们需要等待写 commit block 结束。结束之后，从技术上来说，当前 transaction 已经到达了 commit point，也就是说 transaction 中的写操作可以保证在面对 crash 并重启时还是可见的。如果 crash 发生在写 commit block 之前，那么 transaction 中的写操作在 crash 并重启时会丢失。
9. 接下来我们可以将 transaction 包含的 block 写入到文件系统中的实际位置。
10. 在第 9 步中的所有写操作完成之后，我们才能重用 transaction 对应的那部分 log 空间。

![](<../assets/image (451).png>)

在一个非常繁忙的系统中，log 的头指针一直追着尾指针在跑（注，也就是说一直没有新的 log 空间）。在当前最早的 transaction 的所有步骤都完成之前，或许不能开始 commit 一个新的 transaction，因为我们需要重复利用最早的 transaction 对应的 log 空间。不过人们通常会将 log 设置的足够大，让这种情况就不太可能发生。

> 学生提问：你刚刚说没有进程会等待这些步骤完成，那么这些步骤是在哪里完成的呢？
>
> Robert 教授：这些是在后台的内核线程完成的。
>
> 学生提问：我有个有关重用 log 空间的问题，假设我们使用了一段特定的 log 空间，并且这段 log 空间占据了是刚刚释放出来的所有 log 空间，但是还不够，那么文件系统会等待另一部分的 log 空间释放出来吗，还是会做点别的？
>
> Robert 教授：是的，会等待。让我画张图来确保我回答的是正确的问题。我们可以认为 log 是磁盘中的一段线性空间，假设现存的 transaction 中最早的是 T7，之后是 T8，T9，我们想要将 T10 放在 T9 之后的空闲区域。

![](<../assets/image (520).png>)

> 我们或许要等待 T7 将所有的 block 写入到文件系统对应的位置，这样我们才能释放 T7 对应的空间。这意味着 T10 中的步骤需要暂停以等待 T7 释放出来。这是你的问题吗？
>
> 同一个学生：是的，所以可能是这样，我先写入 T10 的 block 到现有的 log 空闲区域，但是如果最后 log 足够大并且我们用光了空闲区域，我们就需要等待 T7 的空间被释放出来，是吗？
>
> Robert 教授：是的，如果需要写入的数据足够多，并且 log 迅速的用光了。我们甚至都不能在释放 log 空间之前开始新的系统调用。如果你们关注细节的话，这里会有一些潜在的死锁。首先系统调用需要预声明需要多少个 block，这样 logging 系统才知道对于该 transaction 需要多少 log 空间，因为我们不会在没有足够空间来 commit transaction 时，开始一个新的 transaction（注，难道不能将不能写入到磁盘 log 中的 transaction 先缓存在内存中吗？虽然这样可能会导致堆积）。
>
> 学生提问：如果新的 transaction 需要的空间走到了 T8，那么现在就需要等待 T7，T8 结束，这是怎么工作的呢？
>
> Robert 教授：图中的 T7，T8，T9 其中的系统调用都完成了，并且都已经在 commit 到 log 中了。在上面的图中，我们会直接开始 T10，新的系统调用会写入到 transaction T10，最终当 T10 需要 commit 到 log 中，并且它大到需用用到 T8 的空间时，它需要等待 T7，T8 结束。文件系统会记录每个 transaction 的大小，这样文件系统就知道要等待多少个之前的 transaction 结束。所以这里还有不少的记录工作，这样文件系统才能理解所有旧的 transaction 的状态。

有关如何重用 log 空间，这里有个小细节。在 log 的最开始有一个 super block，所以在任何时候 log 都是由一个 super block 和一些 transaction 组成。假设 T4 是最新的 transaction，之前是 T1，T2，T3。

![](<../assets/image (533).png>)

我们是否能重用一段 log 空间，取决于相应的 transaction，例如 T2，是否已经 commit 并且写入到文件系统的实际位置中，这样在 crash 并重启时就不需要重新执行这段 transaction 了。同时也取决于 T2 之前的的所有 transaction 是否已经被释放了。所有的这些条件都满足时，我们就可以释放并重用 T2 对应的 log 空间。
