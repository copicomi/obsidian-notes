# 16.9 总结

最后我希望同学们记住的有关 logging 和 ext3 的是：

- log 是为了保证多个步骤的写磁盘操作具备原子性。在发生 crash 时，要么这些写操作都发生，要么都不发生。这是 logging 的主要作用。
- logging 的正确性由 write ahead rule 来保证。你们将会在故障恢复相关的业务中经常看到 write ahead rule 或者 write ahead log（WAL）。write ahead rule 的意思是，你必须在做任何实际修改之前，将所有的更新 commit 到 log 中。在稍后的恢复过程中完全依赖 write ahead rule。对于文件系统来说，logging 的意义在于简单的快速恢复。log 中可能包含了数百个 block，你可以在一秒中之内重新执行这数百个 block，不管你的文件系统有多大，之后又能正常使用了。
- 最后有关 ext3 的一个细节点是，它使用了批量执行和并发来获得可观的性能提升，不过同时也带来了可观的复杂性的提升。

以上就是今天的内容，接下来是问答环节：

> 学生提问：你刚刚说有一个文件系统线程会做这里所有的工作，那么只能有一个这样的线程，否则的话就会有不同步的问题了，对吗？
>
> Robert 教授：或许真的只有一个线程，我其实不知道有多少个线程，但是 1 是个不错的数字，因为 logging 的正确性取决于旧的 transaction 要在新的 transaction 之前提交。但是逻辑上来说又没有必要只有一个线程，你可以想象不同的 transaction 使用不同的线程来提交（注，只要锁加的合适多个线程应该也是没问题的）。
>
> 学生提问：当你在讨论 crash 的时候，你有一个图是 T8 正在使用之前释放的 T5 的空间，如果 T8 在 crash 的时候还没有 commit，并且 T5 的 commit block 正好在 T8 的 descriptor block 所指定的位置，这样会不会不正确的表明 T8 已经被 commit 了（注，这时 T8 有一个假的 commit block）？
>
> Robert 教授：让我尝试画出这里的场景。首先我们有一个古老的 transaction T5，因为 log 的循环特性，在顺序上 T8 位于 T5 之前。因为 T5 已经被释放了，T8 正在蚕食 T5 的 log 空间。假设 T8 没有完成 commit，但是如果完成 commit 的话，T8 的 commit block 会写到 T5 的 commit block 位置。

![](<../assets/image (526).png>)

> T8 并没有能写入 commit block，T8 前面所有的 block 都写入了，但是最后跟的是 T5 的 commit block。这里的答案是，descriptor block 和 commit block 都有 transaction 的序列号，所以 T8 的 descriptor block 里面的序列号是 8，但是 T5 的 commit block 里面的序列号是 5，所以两者不能匹配。
>
> 学生提问：我们可以在 transaction T8 开始的时候就知道它的大小吗？
>
> Robert 教授：这是个复杂的问题。当 T8 作为活跃的 transaction 开始时，系统调用会写入数据，这时文件系统并不知道 T8 有多大。当文件系统开始 commit T8 时，是知道 T8 有多大的，因为文件系统只会在 T8 中所有的系统调用都结束之后才 commit 它，而在那个时间点，文件系统知道所有的写操作，所以就知道 T8 究竟有多大。除此之外，descriptor block 里面包含了所有 block 的实际编号，所以当写入 transaction 的第一个 block，也就是 descriptor block 时，logging 系统知道 T8 会包含多少个 block。
>
> 学生提问：为什么不在 descriptor block 里面记录 commit 信息。虽然这样可能不太好，因为要回到之前的一个位置去更新之前的一个 block。
>
> Robert 教授：所以这里的提议是，与其要一个专门的 commit block，可以让 descriptor block 来实现 commit block 的功能。XV6 与这个提议非常像，我认为可以这么做，至少在 ext3 中这么做了不会牺牲性能。你需要像 XV6 一样来组织这里的结构，也就是需要在 descriptor block 包含某个数据表明这是一个已经提交过的 transaction。
>
> 这样做的话，可以节省一个 commit block 的空间，但是不能节省整个时间。Linux 文件系统的后续版本实现了你的提议，ext4 做了以下工作来更有效的写 commit block。ext4 会同时写入所有的 data block 和 commit block，它并不是等待所有的 data block 写完了之后才写的 commit block。但是这里有个问题，磁盘可以无序的执行写操作，所以磁盘可能会先写 commit block 之后再写 data block。如果中间有了 crash，那么我们有了 commit block，但是却没有全部的 data block。ext4 通过在 commit block 中增加校验和来避免这种问题。所以 commit block 写入之后发生了 crash，如果 data block 没有全写入那么校验和不能得出正确的结果，恢复软件可以据此判断出错了。ext4 可以通过这种方式在机械硬盘上写入一批 block 而避免磁碟旋转，进而提升磁盘性能。
>
> 学生提问：log 中的 data block 是怎么写入到文件系统中的？
>
> Robert 教授：这个问题有多个答案。对于 data block，ext3 有三种模式，但是我只记得两个，journaled data 和 ordered data（注，第三种是 writeback）。当你在配置 ext3 文件系统时，你需要告诉 Linux 你想要哪种模式。如果你想要的是 journaled data，文件内容就是写入到 log 中，如果你向一个文件写数据，这会导致 inode 更新，log 中会包含文件数据和更新了的 inode，也就是说任何更新了的 block 都会记录在 log 中。这种方法非常慢，因为数据需要先写在 log 中，再写到文件系统中。所以 journaled data 很直观，但是很慢。
>
> ordered data 是最流行的模式，它不会将文件数据写入到 log 中，只会将 metadata block，例如 inode，目录 block，写入到 log 中，文件的内容会直接写到文件系统的实际位置中。所以这种模式要快得多，因为你不用将文件内容写两次。但是它也会导致更多的复杂性，因为你不能随时写入文件内容。假设你执行一个写操作导致一个新的 block 被分配给一个文件，并将包含了新分配 block 编号的 inode 写入到 log 中并 commit，在实际写入文件内容至刚刚分配的 data block 之前发生 crash。在稍后的恢复流程中，你将会看到包含了新分配的 block 编号的 inode，但是对应 data block 里面的内容却属于之前使用了这个 data block 的旧的文件。如果你运行的是一个类似 Athena 的多用户系统，那么可能就是一个用户拥有一个文件，其中的内容又属于另一个用户已经删除的文件，如果我们不是非常小心的处理写入数据和 inode 的顺序就会有这样的问题。
>
> ext3 的 ordered data 通过先写入文件内容到磁盘中，再 commit 修改了的 inode 来解决这里的问题。如果你是个应用程序，你写了一个文件并导致一个新的文件系统 data block 被分配出来，文件系统会将新的文件内容写到新分配的 data block 中，之后才会 commit transaction，进而导致 inode 更新并包含新分配的 data block 编号。如果在写文件数据和更新 inode 之间发生了 crash，你也看不到其他人的旧的数据，因为这时就算有了更新了的 data block，但是也没关系，因为现在不仅 inode 没有更新，连 bitmap block 也没更新，相应的 data block 还处于空闲状态，并且可以分配给其他的程序，你并不会因此丢失 block。这里的效果就是我们写了一个 data block 但是最终并没有被任何文件所使用。
