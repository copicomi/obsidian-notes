# 11.6 XV6 线程切换 --- yield/sched 函数

回到 devintr 函数返回到 usertrap 函数中的位置。在 gdb 里面输入几次 step 走到 yield 函数的调用。yield 函数是整个线程切换的第一步，下面是 yield 函数的内容：

![](<../assets/image (663).png>)

yield 函数只做了几件事情，它首先获取了进程的锁。实际上，在锁释放之前，进程的状态会变得不一致，例如，yield 将要将进程的状态改为 RUNABLE，表明进程并没有在运行，但是实际上这个进程还在运行，代码正在当前进程的内核线程中运行。所以这里加锁的目的之一就是：即使我们将进程的状态改为了 RUNABLE，其他的 CPU 核的调度器线程也不可能看到进程的状态为 RUNABLE 并尝试运行它。否则的话，进程就会在两个 CPU 核上运行了，而一个进程只有一个栈，这意味着两个 CPU 核在同一个栈上运行代码（注，因为 XV6 中一个用户进程只有一个用户线程）。

接下来 yield 函数中将进程的状态改为 RUNABLE。这里的意思是，当前进程要出让 CPU，并切换到调度器线程。当前进程的状态是 RUNABLE 意味着它还会再次运行，因为毕竟现在是一个定时器中断打断了当前正在运行的进程。

之后 yield 函数中调用了位于 proc.c 文件中的 sched 函数。我们进入到 sched 函数中，

![](<../assets/image (516) (2) (2) (2) (1).png>)

可以看出，sched 函数基本没有干任何事情，只是做了一些合理性检查，如果发现异常就 panic。为什么会有这么多检查？因为这里的 XV6 代码已经有很多年的历史了，这些代码经历过各种各样的 bug，相应的这里就有各种各样的合理性检查和 panic 来避免可能的 bug。我将跳过所有的检查，直接走到位于底部的 swtch 函数。
