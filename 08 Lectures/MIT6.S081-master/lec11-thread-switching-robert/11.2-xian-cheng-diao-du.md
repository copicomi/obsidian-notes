# 11.2 XV6 线程调度

实现内核中的线程系统存在以下挑战：

- 第一个是如何实现线程间的切换。这里停止一个线程的运行并启动另一个线程的过程通常被称为线程调度（Scheduling）。我们将会看到 XV6 为每个 CPU 核都创建了一个线程调度器（Scheduler）。
- 第二个挑战是，当你想要实际实现从一个线程切换到另一个线程时，你需要保存并恢复线程的状态，所以需要决定线程的哪些信息是必须保存的，并且在哪保存它们。
- 最后一个挑战是如何处理运算密集型线程（compute bound thread）。对于线程切换，很多直观的实现是由线程自己自愿的保存自己的状态，再让其他的线程运行。但是如果我们有一些程序正在执行一些可能要花费数小时的长时间计算任务，这样的线程并不能自愿的出让 CPU 给其他的线程运行。所以这里需要能从长时间运行的运算密集型线程撤回对于 CPU 的控制，将其放置于一边，稍后再运行它。

![](<../assets/image (748).png>)

接下来，我将首先介绍如何处理运算密集型线程。这里的具体实现你们之前或许已经知道了，就是利用定时器中断。在每个 CPU 核上，都存在一个硬件设备，它会定时产生中断。XV6 与其他所有的操作系统一样，将这个中断传输到了内核中。所以即使我们正在用户空间计算 π 的前 100 万位，定时器中断仍然能在例如每隔 10ms 的某个时间触发，并将程序运行的控制权从用户空间代码切换到内核中的中断处理程序（注，因为中断处理程序优先级更高）。哪怕这些用户空间进程并不配合工作（注，也就是用户空间进程一直占用 CPU），内核也可以从用户空间进程获取 CPU 控制权。

位于内核的定时器中断处理程序，会自愿的将 CPU 出让（yield）给线程调度器，并告诉线程调度器说，你可以让一些其他的线程运行了。这里的出让其实也是一种线程切换，它会保存当前线程的状态，并在稍后恢复。

![](<../assets/image (686).png>)

在之前的课程中，你们已经了解过了中断处理的流程。这里的基本流程是，定时器中断将 CPU 控制权给到内核，内核再自愿的出让 CPU。

这样的处理流程被称为 pre-emptive scheduling。pre-emptive 的意思是，即使用户代码本身没有出让 CPU，定时器中断仍然会将 CPU 的控制权拿走，并出让给线程调度器。与之相反的是 voluntary scheduling。

![](<../assets/image (751).png>)

有趣的是，在 XV6 和其他的操作系统中，线程调度是这么实现的：定时器中断会强制的将 CPU 控制权从用户进程给到内核，这里是 pre-emptive scheduling，之后内核会代表用户进程（注，实际是内核中用户进程对应的内核线程会代表用户进程出让 CPU），使用 voluntary scheduling。

在执行线程调度的时候，操作系统需要能区分几类线程：

- 当前在 CPU 上运行的线程
- 一旦 CPU 有空闲时间就想要运行在 CPU 上的线程
- 以及不想运行在 CPU 上的线程，因为这些线程可能在等待 I/O 或者其他事件

这里不同的线程是由状态区分，但是实际上线程的完整状态会要复杂的多（注，线程的完整状态包含了程序计数器，寄存器，栈等等）。下面是我们将会看到的一些线程状态：

- RUNNING，线程当前正在某个 CPU 上运行
- RUNABLE，线程还没有在某个 CPU 上运行，但是一旦有空闲的 CPU 就可以运行
- SLEEPING，这节课我们不会介绍，下节课会重点介绍，这个状态意味着线程在等待一些 I/O 事件，它只会在 I/O 事件发生了之后运行

![](<../assets/image (784).png>)

今天这节课，我们主要关注 RUNNING 和 RUNABLE 这两类线程。前面介绍的定时器中断或者说 pre-emptive scheduling，实际上就是将一个 RUNNING 线程转换成一个 RUNABLE 线程。通过出让 CPU，pre-emptive scheduling 将一个正在运行的线程转换成了一个当前不在运行但随时可以再运行的线程。因为当定时器中断触发时，这个线程还在好好的运行着。

对于 RUNNING 状态下的线程，它的程序计数器和寄存器位于正在运行它的 CPU 硬件中。而 RUNABLE 线程，因为并没有 CPU 与之关联，所以对于每一个 RUNABLE 线程，当我们将它从 RUNNING 转变成 RUNABLE 时，我们需要将它还在 RUNNING 时位于 CPU 的状态拷贝到内存中的某个位置，注意这里不是从内存中的某处进行拷贝，而是从 CPU 中的寄存器拷贝。我们需要拷贝的信息就是程序计数器（Program Counter）和寄存器。

当线程调度器决定要运行一个 RUNABLE 线程时，这里涉及了很多步骤，但是其中一步是将之前保存的程序计数器和寄存器拷贝回调度器对应的 CPU 中。
