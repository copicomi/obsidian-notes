# 11.8 XV6 线程切换 --- scheduler 函数

来看一下 scheduler 的完整代码，

![](<../assets/image (565) (2).png>)

现在我们正运行在 CPU 拥有的调度器线程中，并且我们正好在之前调用 swtch 函数的返回状态。之前调度器线程调用 switch 是因为想要运行 pid 为 3 的进程，也就是刚刚被中断的 spin 程序。

虽然 pid 为 3 的 spin 进程也调用了 swtch 函数，但是那个 switch 并不是当前返回的这个 switch。spin 进程调用的 swtch 函数还没有返回，而是保存在了 pid 为 3 的栈和 context 对象中。现在返回的是之前调度器线程对于 swtch 函数的调用。

在 scheduler 函数中，因为我们已经停止了 spin 进程的运行，所以我们需要抹去对于 spin 进程的记录。我们接下来将 c->proc 设置为 0（c->proc = 0;）。因为我们现在并没有在这个 CPU 核上运行这个进程，为了不让任何人感到困惑，我们这里将 CPU 核运行的进程对象设置为 0。

之前在 yield 函数中获取了进程的锁，因为 yield 不想进程完全进入到 Sleep 状态之前，任何其他的 CPU 核的调度器线程看到这个进程并运行它。而现在我们完成了从 spin 进程切换走，所以现在可以释放锁了。这就是 release(\&p->lock)的意义。现在，我们仍然在 scheduler 函数中，但是其他的 CPU 核可以找到 spin 进程，并且因为 spin 进程是 RUNABLE 状态，其他的 CPU 可以运行它。这没有问题，因为我们已经完整的保存了 spin 进程的寄存器，并且我们不在 spin 进程的栈上运行程序，而是在当前 CPU 核的调度器线程栈上运行程序，所以其他的 CPU 核运行 spin 程序并没有问题。但是因为启动 QEMU 时我们只指定了一个核，所以在我们现在的演示中并没有其他的 CPU 核来运行 spin 程序。

接下来我将简单介绍一下 p->lock。从调度的角度来说，这里的锁完成了两件事情。

首先，出让 CPU 涉及到很多步骤，我们需要将进程的状态从 RUNNING 改成 RUNABLE，我们需要将进程的寄存器保存在 context 对象中，并且我们还需要停止使用当前进程的栈。所以这里至少有三个步骤，而这三个步骤需要花费一些时间。所以锁的第一个工作就是在这三个步骤完成之前，阻止任何一个其他核的调度器线程看到当前进程。锁这里确保了三个步骤的原子性。从 CPU 核的角度来说，三个步骤要么全发生，要么全不发生。

第二，当我们开始要运行一个进程时，p->lock 也有类似的保护功能。当我们要运行一个进程时，我们需要将进程的状态设置为 RUNNING，我们需要将进程的 context 移到 RISC-V 的寄存器中。但是，如果在这个过程中，发生了中断，从中断的角度来说进程将会处于一个奇怪的状态。比如说进程的状态是 RUNNING，但是又还没有将所有的寄存器从 context 对象拷贝到 RISC-V 寄存器中。所以，如果这时候有了一个定时器中断将会是个灾难，因为我们可能在寄存器完全恢复之前，从这个进程中切换走。而从这个进程切换走的过程中，将会保存不完整的 RISC-V 寄存器到进程的 context 对象中。所以我们希望启动一个进程的过程也具有原子性。在这种情况下，切换到一个进程的过程中，也需要获取进程的锁以确保其他的 CPU 核不能看到这个进程。同时在切换到进程的过程中，还需要关闭中断，这样可以避免定时器中断看到还在切换过程中的进程。（注，这就是为什么 468 行需要加锁的原因）

现在我们在 scheduler 函数的循环中，代码会检查所有的进程并找到一个来运行。现在我们知道还有另一个进程，因为我们之前 fork 了另一个 spin 进程。这里我跳过进程检查，直接在找到 RUNABLE 进程的位置设置一个断点。

![](<../assets/image (458).png>)

在代码的 468 行，获取了进程的锁，所以现在我们可以进行切换到进程的各种步骤。在代码的 473 行，进程的状态被设置成了 RUNNING。代码的 474 行将找到的 RUNABLE 进程记录为当前 CPU 执行的进程。代码的 475 行，又调用了 swtch 函数来保存调度器线程的寄存器，并恢复目标进程的寄存器（注，实际上恢复的是目标进程的内核线程）。我们可以打印新的进程的名字来查看新的进程。

![](<../assets/image (567).png>)

可以看到进程名还是 spin，但是 pid 已经变成了 4，而前一个进程的 pid 是 3。我们还可以查看目标进程的 context 对象，

![](<../assets/image (623).png>)

其中 ra 寄存器的内容就是我们要切换到的目标线程的代码位置。虽然我们在代码 475 行调用的是 swtch 函数，但是我们前面已经看过了 swtch 函数会返回到即将恢复的 ra 寄存器地址，所以我们真正关心的就是 ra 指向的地址。

![](<../assets/image (564).png>)

通过打印这个地址的内容，可以看到 swtch 函数会返回到 sched 函数中。这完全在意料之中，因为可以预期的是，将要切换到的进程之前是被定时器中断通过 sched 函数挂起的，并且之前在 sched 函数中又调用了 swtch 函数。

在 swtch 函数的最开始，我们仍然在调度器线程中，但是这一次是从调度器线程切换到目标进程的内核线程。所以从 swtch 函数内部将会返回到目标进程的内核线程的 sched 函数，通过打印 backtrace，

![](<../assets/image (441).png>)

我们可以看到，之前有一个 usertrap 的调用，这必然是之前因为定时器中断而出现的调用。之后在中断处理函数中还调用了 yield 和 sched 函数，正如我们之前看到的一样。但是，这里调用 yield 和 sched 函数是在 pid 为 4 的进程调用的，而不是我们刚刚看的 pid 为 3 的进程。

> 学生提问：如果不是因为定时器中断发生的切换，我们是不是可以期望 ra 寄存器指向其他位置，例如 sleep 函数？
>
> Robert 教授：是的，我们之前看到了代码执行到这里会包含一些系统调用相关的函数。你基本上回答了自己的问题，如果我们因为定时器中断之外的原因而停止了执行当前的进程，switch 会返回到一些系统调用的代码中，而不是我们这里看到 sched 函数。我记得 sleep 最后也调用了 sched 函数，虽然 bracktrace 可能看起来会不一样，但是还是会包含 sched。所以我这里只介绍了一种进程间切换的方法，也就是因为定时器中断而发生切换。但是还有其他的可能会触发进程切换，例如等待 I/O 或者等待另一个进程向 pipe 写数据。

这里有件事情需要注意，调度器线程调用了 swtch 函数，但是我们从 swtch 函数返回时，实际上是返回到了对于 switch 的另一个调用，而不是调度器线程中的调用。我们返回到的是 pid 为 4 的进程在很久之前对于 switch 的调用。这里可能会有点让人困惑，但是这就是线程切换的核心。

另一件需要注意的事情是，swtch 函数是线程切换的核心，但是 swtch 函数中只有保存寄存器，再加载寄存器的操作。线程除了寄存器以外的还有很多其他状态，它有变量，堆中的数据等等，但是所有的这些数据都在内存中，并且会保持不变。我们没有改变线程的任何栈或者堆数据。所以线程切换的过程中，处理器中的寄存器是唯一的不稳定状态，且需要保存并恢复。而所有其他在内存中的数据会保存在内存中不被改变，所以不用特意保存并恢复。我们只是保存并恢复了处理器中的寄存器，因为我们想在新的线程中也使用相同的一组寄存器。
