# 11.7 XV6 线程切换 --- switch 函数

![](<../assets/image (516) (2) (2) (2).png>)

swtch 函数会将当前的内核线程的寄存器保存到 p->context 中。swtch 函数的另一个参数 c->context，c 表示当前 CPU 的结构体。CPU 结构体中的 context 保存了当前 CPU 核的调度器线程的寄存器。所以 swtch 函数在保存完当前内核线程的内核寄存器之后，就会恢复当前 CPU 核的调度器线程的寄存器，并继续执行当前 CPU 核的调度器线程。

接下来，我们快速的看一下我们将要切换到的 context（注，也就是调度器线程的 context）。因为我们只有一个 CPU 核，这里我在 gdb 中 print cpus\[0].context

![](<../assets/image (728).png>)

这里看到的就是之前保存的当前 CPU 核的调度器线程的寄存器。在这些寄存器中，最有趣的就是 ra（Return Address）寄存器，因为 ra 寄存器保存的是当前函数的返回地址，所以调度器线程中的代码会返回到 ra 寄存器中的地址。通过查看 kernel.asm，我们可以知道这个地址的内容是什么。也可以在 gdb 中输入“x/i 0x80001f2e”进行查看。

![](<../assets/image (463).png>)

输出中包含了地址中的指令和指令所在的函数名。所以我们将要返回到 scheduler 函数中。

因为我们接下来要调用 swtch 函数，让我们来看看 swtch 函数的内容。swtch 函数位于 switch.s 文件中。

![](<../assets/image (503).png>)

首先，ra 寄存器被保存在了 a0 寄存器指向的地址。a0 寄存器对应了 swtch 函数的第一个参数，从前面可以看出这是当前线程的 context 对象地址 ；a1 寄存器对应了 swtch 函数的第二个参数，从前面可以看出这是即将要切换到的调度器线程的 context 对象地址。

所以函数中上半部分是将当前的寄存器保存在当前线程对应的 context 对象中，函数的下半部分是将调度器线程的寄存器，也就是我们将要切换到的线程的寄存器恢复到 CPU 的寄存器中。之后函数就返回了。所以调度器线程的 ra 寄存器的内容才显得有趣，因为它指向的是 swtch 函数返回的地址，也就是 scheduler 函数。

这里有个有趣的问题，或许你们已经注意到了。swtch 函数的上半部分保存了 ra，sp 等等寄存器，但是并没有保存程序计数器 pc（Program Counter），为什么会这样呢？

> 学生回答：因为程序计数器不管怎样都会随着函数调用更新。

是的，程序计数器并没有有效信息，我们现在知道我们在 swtch 函数中执行，所以保存程序计数器并没有意义。但是我们关心的是我们是从哪调用进到 swtch 函数的，因为当我们通过 switch 恢复执行当前线程并且从 swtch 函数返回时，我们希望能够从调用点继续执行。ra 寄存器保存了 swtch 函数的调用点，所以这里保存的是 ra 寄存器。我们可以打印 ra 寄存器，如你们所预期的一样，它指向了 sched 函数。

![](<../assets/image (431).png>)

另一个问题是，为什么 RISC-V 中有 32 个寄存器，但是 swtch 函数中只保存并恢复了 14 个寄存器？

> 学生回答：因为 switch 是按照一个普通函数来调用的，对于有些寄存器，swtch 函数的调用者默认 swtch 函数会做修改，所以调用者已经在自己的栈上保存了这些寄存器，当函数返回时，这些寄存器会自动恢复。所以 swtch 函数里只需要保存 Callee Saved Register 就行。（注，详见 5.4）

完全正确！因为 swtch 函数是从 C 代码调用的，所以我们知道 Caller Saved Register 会被 C 编译器保存在当前的栈上。Caller Saved Register 大概有 15-18 个，而我们在 swtch 函数中只需要处理 C 编译器不会保存，但是对于 swtch 函数又有用的一些寄存器。所以在切换线程的时候，我们只需要保存 Callee Saved Register。

最后我想看的是 sp（Stack Pointer）寄存器。

![](<../assets/image (624).png>)

从它的值很难看出它的意义是什么。它实际是当前进程的内核栈地址，它由虚拟内存系统映射在了一个高地址。

现在，我们保存了当前的寄存器，并从调度器线程的 context 对象恢复了寄存器，我直接跳到 swtch 函数的最后，也就是 ret 指令的位置。

![](<../assets/image (528).png>)

在我们实际返回之前，我们再来打印一些有趣的寄存器。首先 sp 寄存器有了一个不同的值，

![](<../assets/image (468).png>)

sp 寄存器的值现在在内存中的 stack0 区域中。这个区域实际上是在启动顺序中非常非常早的一个位置，start.s 在这个区域创建了栈，这样才可以调用第一个 C 函数。所以调度器线程运行在 CPU 对应的 bootstack 上。

其次是 ra 寄存器，

![](<../assets/image (500).png>)

现在指向了 scheduler 函数，因为我们恢复了调度器线程的 context 对象中的内容。

现在，我们其实已经在调度器线程中了，这里寄存器的值与上次打印的已经完全不一样了。虽然我们还在 swtch 函数中，但是现在我们实际上位于调度器线程调用的 swtch 函数中。调度器线程在启动过程中调用的也是 swtch 函数。接下来通过执行 ret 指令，我们就可以返回到调度器线程中。

（注，以下提问来自于课程结束部分，因为相关所以移到这里）

> 学生提问：我不知道我们使用的 RISC-V 处理器是不是有一些其他的状态？但是我知道一些 Intel 的 X86 芯片有 floating point unit state 等其他的状态，我们需要处理这些状态吗？
>
> Robert 教授：你的观点非常对。在一些其他处理器例如 X86 中，线程切换的细节略有不同，因为不同的处理器有不同的状态。所以我们这里介绍的代码非常依赖 RISC-V。其他处理器的线程切换流程可能看起来会非常的不一样，比如说可能要保存 floating point 寄存器。我不知道 RISC-V 如何处理浮点数，但是 XV6 内核并没有使用浮点数，所以不必担心。但是是的，线程切换与处理器非常相关。
>
> 学生提问：为什么 swtch 函数要用汇编来实现，而不是 C 语言？
>
> Robert 教授：C 语言中很难与寄存器交互。可以肯定的是 C 语言中没有方法能更改 sp、ra 寄存器。所以在普通的 C 语言中很难完成寄存器的存储和加载，唯一的方法就是在 C 中嵌套汇编语言。所以我们也可以在 C 函数中内嵌 switch 中的指令，但是这跟我们直接定义一个汇编函数是一样的。或者说 swtch 函数中的操作是在 C 语言的层级之下，所以并不能使用 C 语言。
