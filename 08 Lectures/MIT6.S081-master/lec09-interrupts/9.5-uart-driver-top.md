# 9.5 UART 驱动的 top 部分

接下来我想看一下如何从 Shell 程序输出提示符“$ ”到 Console。首先我们看 init.c 中的 main 函数，这是系统启动后运行的第一个进程。

![](<../assets/image (808).png>)

首先这个进程的 main 函数创建了一个代表 Console 的设备。这里通过 mknod 操作创建了 console 设备。因为这是第一个打开的文件，所以这里的文件描述符 0。之后通过 dup 创建 stdout 和 stderr。这里实际上通过复制文件描述符 0，得到了另外两个文件描述符 1，2。最终文件描述符 0，1，2 都用来代表 Console。

Shell 程序首先打开文件描述符 0，1，2。之后 Shell 向文件描述符 2 打印提示符“$ ”。

![](<../assets/image (677).png>)

尽管 Console 背后是 UART 设备，但是从应用程序来看，它就像是一个普通的文件。Shell 程序只是向文件描述符 2 写了数据，它并不知道文件描述符 2 对应的是什么。在 Unix 系统中，设备是由文件表示。我们来看一下这里的 fprintf 是如何工作的。

在 printf.c 文件中，代码只是调用了 write 系统调用，在我们的例子中，fd 对应的就是文件描述符 2，c 是字符“$”。

![](<../assets/image (661).png>)

所以由 Shell 输出的每一个字符都会触发一个 write 系统调用。之前我们已经看过了 write 系统调用最终会走到 sysfile.c 文件的 sys_write 函数。

![](<../assets/image (830).png>)

这个函数中首先对参数做了检查，然后又调用了 filewrite 函数。filewrite 函数位于 file.c 文件中。

![](<../assets/image (729).png>)

在 filewrite 函数中首先会判断文件描述符的类型。mknod 生成的文件描述符属于设备（FD_DEVICE），而对于设备类型的文件描述符，我们会为这个特定的设备执行设备相应的 write 函数。因为我们现在的设备是 Console，所以我们知道这里会调用 console.c 中的 consolewrite 函数。

![](<../assets/image (816).png>)

这里先通过 either_copyin 将字符拷入，之后调用 uartputc 函数。uartputc 函数将字符写入给 UART 设备，所以你可以认为 consolewrite 是一个 UART 驱动的 top 部分。uart.c 文件中的 uartputc 函数会实际的打印字符。

![](<../assets/image (755).png>)

uartputc 函数会稍微有趣一些。在 UART 的内部会有一个 buffer 用来发送数据，buffer 的大小是 32 个字符。同时还有一个为 consumer 提供的读指针和为 producer 提供的写指针，来构建一个环形的 buffer（注，或者可以认为是环形队列）。

![](<../assets/image (824).png>)

在我们的例子中，Shell 是 producer，所以需要调用 uartputc 函数。在函数中第一件事情是判断环形 buffer 是否已经满了。如果读写指针相同，那么 buffer 是空的，如果写指针加 1 等于读指针，那么 buffer 满了。当 buffer 是满的时候，向其写入数据是没有意义的，所以这里会 sleep 一段时间，将 CPU 出让给其他进程。当然，对于我们来说，buffer 必然不是满的，因为提示符“$”是我们送出的第一个字符。所以代码会走到 else，字符会被送到 buffer 中，更新写指针，之后再调用 uartstart 函数。

![](<../assets/image (780).png>)

uartstart 就是通知设备执行操作。首先是检查当前设备是否空闲，如果空闲的话，我们会从 buffer 中读出数据，然后将数据写入到 THR（Transmission Holding Register）发送寄存器。这里相当于告诉设备，我这里有一个字节需要你来发送。一旦数据送到了设备，系统调用会返回，用户应用程序 Shell 就可以继续执行。这里从内核返回到用户空间的机制与 lec06 的 trap 机制是一样的。

与此同时，UART 设备会将数据送出。在某个时间点，我们会收到中断，因为我们之前设置了要处理 UART 设备中断。接下来我们看一下，当发生中断时，实际会发生什么。
