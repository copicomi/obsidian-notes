# 9.8 UART 读取键盘输入

在 UART 的另一侧，会有类似的事情发生，有时 Shell 会调用 read 从键盘中读取字符。 在 read 系统调用的底层，会调用 fileread 函数。在这个函数中，如果读取的文件类型是设备，会调用相应设备的 read 函数。

![](<../assets/image (807).png>)

在我们的例子中，read 函数就是 console.c 文件中的 consoleread 函数。

![](<../assets/image (870).png>)

这里与 UART 类似，也有一个 buffer，包含了 128 个字符。其他的基本一样，也有 producer 和 consumser。但是在这个场景下 Shell 变成了 consumser，因为 Shell 是从 buffer 中读取数据。而键盘是 producer，它将数据写入到 buffer 中。

![](<../assets/image (654).png>)

从 consoleread 函数中可以看出，当读指针和写指针一样时，说明 buffer 为空，进程会 sleep。所以 Shell 在打印完“$ ”之后，如果键盘没有输入，Shell 进程会 sleep，直到键盘有一个字符输入。所以在某个时间点，假设用户通过键盘输入了“l”，这会导致“l”被发送到主板上的 UART 芯片，产生中断之后再被 PLIC 路由到某个 CPU 核，之后会触发 devintr 函数，devintr 可以发现这是一个 UART 中断，然后通过 uartgetc 函数获取到相应的字符，之后再将字符传递给 consoleintr 函数。

![](<../assets/image (811).png>)

默认情况下，字符会通过 consputc，输出到 console 上给用户查看。之后，字符被存放在 buffer 中。在遇到换行符的时候，唤醒之前 sleep 的进程，也就是 Shell，再从 buffer 中将数据读出。

所以这里也是通过 buffer 将 consumer 和 producer 之间解耦，这样它们才能按照自己的速度，独立的并行运行。如果某一个运行的过快了，那么 buffer 要么是满的要么是空的，consumer 和 producer 其中一个会 sleep 并等待另一个追上来。
