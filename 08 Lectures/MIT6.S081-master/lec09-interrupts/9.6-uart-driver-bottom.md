# 9.6 UART 驱动的 bottom 部分

在我们向 Console 输出字符时，如果发生了中断，RISC-V 会做什么操作？我们之前已经在 SSTATUS 寄存器中打开了中断，所以处理器会被中断。假设键盘生成了一个中断并且发向了 PLIC，PLIC 会将中断路由给一个特定的 CPU 核，并且如果这个 CPU 核设置了 SIE 寄存器的 E bit（注，针对外部中断的 bit 位），那么会发生以下事情：

- 首先，会清除 SIE 寄存器相应的 bit，这样可以阻止 CPU 核被其他中断打扰，该 CPU 核可以专心处理当前中断。处理完成之后，可以再次恢复 SIE 寄存器相应的 bit。
- 之后，会设置 SEPC 寄存器为当前的程序计数器。我们假设 Shell 正在用户空间运行，突然来了一个中断，那么当前 Shell 的程序计数器会被保存。
- 之后，要保存当前的 mode。在我们的例子里面，因为当前运行的是 Shell 程序，所以会记录 user mode。
- 再将 mode 设置为 Supervisor mode。
- 最后将程序计数器的值设置成 STVEC 的值。（注，STVEC 用来保存 trap 处理程序的地址，详见 lec06）在 XV6 中，STVEC 保存的要么是 uservec 或者 kernelvec 函数的地址，具体取决于发生中断时程序运行是在用户空间还是内核空间。在我们的例子中，Shell 运行在用户空间，所以 STVEC 保存的是 uservec 函数的地址。而从之前的课程我们可以知道 uservec 函数会调用 usertrap 函数。所以最终，我们在 usertrap 函数中。我们这节课不会介绍 trap 过程中的拷贝，恢复过程，因为在之前的课程中已经详细的介绍过了。

![](<../assets/image (768).png>)

接下来看一下 trap.c 文件中的 usertrap 函数，我们在 lec06 和 lec08 分别在这个函数中处理了系统调用和 page fault。今天我们将要看一下如何处理中断。

![](<../assets/image (818).png>)

在 trap.c 的 devintr 函数中，首先会通过 SCAUSE 寄存器判断当前中断是否是来自于外设的中断。如果是的话，再调用 plic_claim 函数来获取中断。

![](<../assets/image (441) (1) (1) (1) (1).png>)

plic_claim 函数位于 plic.c 文件中。在这个函数中，当前 CPU 核会告知 PLIC，自己要处理中断，PLIC_SCLAIM 会将中断号返回，对于 UART 来说，返回的中断号是 10。

![](<../assets/image (854).png>)

从 devintr 函数可以看出，如果是 UART 中断，那么会调用 uartintr 函数。位于 uart.c 文件的 uartintr 函数，会从 UART 的接受寄存器中读取数据，之后将获取到的数据传递给 consoleintr 函数。哦，不好意思，我搞错了。我们现在讨论的是向 UART 发送数据。因为我们现在还没有通过键盘输入任何数据，所以 UART 的接受寄存器现在为空。

![](<../assets/image (788).png>)

所以代码会直接运行到 uartstart 函数，这个函数会将 Shell 存储在 buffer 中的任意字符送出。实际上在提示符“$”之后，Shell还会输出一个空格字符，write系统调用可以在UART发送提示符“$”的同时，并发的将空格字符写入到 buffer 中。所以 UART 的发送中断触发时，可以发现在 buffer 中还有一个空格字符，之后会将这个空格字符送出。

这样，驱动的 top 部分和 bottom 部分就解耦开了。

> 学生提问： UART 对于键盘来说很重要，来自于键盘的字符通过 UART 走到 CPU 再到我们写的代码。但是我不太理解 UART 对于 Shell 输出字符究竟有什么作用？因为在这个场景中，并没有键盘的参与。
>
> Frans 教授：显示设备与 UART 也是相连的。所以 UART 连接了两个设备，一个是键盘，另一个是显示设备，也就是 Console。QEMU 也是通过模拟的 UART 与 Console 进行交互，而 Console 的作用就是将字符在显示器上画出来。

（注，以下问答来自课程结束部分，与本节内容时间上并不连续）

> 学生提问：uartinit 只被调用了一次，所以才导致了所有的 CPU 核都共用一个 buffer 吗？
>
> Frans 教授：因为只有一个 UART 设备，一个 buffer 只针对一个 UART 设备，而这个 buffer 会被所有的 CPU 核共享，这样运行在多个 CPU 核上的多个程序可以同时向 Console 打印输出，而驱动中是通过锁来确保多个 CPU 核上的程序串行的向 Console 打印输出。
>
> 学生提问：我们之所以需要锁是因为有多个 CPU 核，但是却只有一个 Console，对吧？
>
> Frans 教授：是的，如我们之前说的驱动的 top 和 bottom 部分可以并行的运行。所以一个 CPU 核可以执行 uartputc 函数，而另个一 CPU 核可以执行 uartintr 函数，我们需要确保它们是串行执行的，而锁确保了这一点。
>
> 学生提问：那是不是意味着，某个时间，其他所有的 CPU 核都需要等待某一个 CPU 核的处理？
>
> Frans 教授：这里并不是死锁。其他的 CPU 核还是可以在等待的时候运行别的进程。
