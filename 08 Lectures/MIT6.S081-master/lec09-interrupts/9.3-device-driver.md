# 9.3 设备驱动概述

通常来说，管理设备的代码称为驱动，所有的驱动都在内核中。我们今天要看的是 UART 设备的驱动，代码在 uart.c 文件中。如果我们查看代码的结构，我们可以发现大部分驱动都分为两个部分，bottom/top。

bottom 部分通常是 Interrupt handler。当一个中断送到了 CPU，并且 CPU 设置接收这个中断，CPU 会调用相应的 Interrupt handler。Interrupt handler 并不运行在任何特定进程的 context 中，它只是处理中断。

top 部分，是用户进程，或者内核的其他部分调用的接口。对于 UART 来说，这里有 read/write 接口，这些接口可以被更高层级的代码调用。

![](<../assets/image (866).png>)

通常情况下，驱动中会有一些队列（或者说 buffer），top 部分的代码会从队列中读写数据，而 Interrupt handler（bottom 部分）同时也会向队列中读写数据。这里的队列可以将并行运行的设备和 CPU 解耦开来。

![](<../assets/image (834).png>)

通常对于 Interrupt handler 来说存在一些限制，因为它并没有运行在任何进程的 context 中，所以进程的 page table 并不知道该从哪个地址读写数据，也就无法直接从 Interrupt handler 读写数据。驱动的 top 部分通常与用户的进程交互，并进行数据的读写。我们后面会看更多的细节，这里是一个驱动的典型架构。

在很多操作系统中，驱动代码加起来可能会比内核还要大，主要是因为，对于每个设备，你都需要一个驱动，而设备又很多。

接下来我们看一下如何对设备进行编程。通常来说，编程是通过 memory mapped I/O 完成的。在 SiFive 的手册中，设备地址出现在物理地址的特定区间内，这个区间由主板制造商决定。操作系统需要知道这些设备位于物理地址空间的具体位置，然后再通过普通的 load/store 指令对这些地址进行编程。load/store 指令实际上的工作就是读写设备的控制寄存器。例如，对网卡执行 store 指令时，CPU 会修改网卡的某个控制寄存器，进而导致网卡发送一个 packet。所以这里的 load/store 指令不会读写内存，而是会操作设备。并且你需要阅读设备的文档来弄清楚设备的寄存器和相应的行为，有的时候文档很清晰，有的时候文档不是那么清晰。

![](<../assets/image (872).png>)

下图中是 SiFive 主板中的对应设备的物理地址，

![](<../assets/image (697).png>)

例如，0x200_0000 对应 CLINT，0xC000000 对应的是 PLIC。在这个图中 UART0 对应的是 0x1001\_\_\_0000，但是在 QEMU 中，我们的 UART0 的地址略有不同，因为在 QEMU 中我们并不是完全的模拟 SiFive 主板，而是模拟与 SiFive 主板非常类似的东西。

以上就是 Memory-mapped IO。

下图是 UART 的文档。16550 是 QEMU 模拟的 UART 设备，QEMU 用这个模拟的设备来与键盘和 Console 进行交互。

![](<../assets/image (795).png>)

这是一个很简单的芯片，图中表明了芯片拥有的寄存器。例如对于控制寄存器 000，如果写它会将数据写入到寄存器中并被传输到其他地方，如果读它可以读出存储在寄存器中的内容。UART 可以让你能够通过串口发送数据 bit，在线路的另一侧会有另一个 UART 芯片，能够将数据 bit 组合成一个个 Byte。

这里还有一些其他可以控制的地方，例如控制寄存器 001，可以通过它来控制 UART 是否产生中断。实际上对于一个寄存器，其中的每个 bit 都有不同的作用。例如对于寄存器 001，也就是 IER 寄存器，bit0-bit3 分别控制了不同的中断。这个文档还有很多内容，但是对于我们这节课来说，上图就足够了。不过即使是这么简单的一个设备，它的文档也有很多页。

> 学生提问：如果你写入数据到 Transmit Holding Register，然后再次写入，那么前一个数据不会被覆盖掉吗？
>
> Frans 教授：这是我们需要注意的一件事情。我们通过 load 将数据写入到这个寄存器中，之后 UART 芯片会通过串口线将这个 Byte 送出。当完成了发送，UART 会生成一个中断给内核，这个时候才能再次写入下一个数据。所以内核和设备之间需要遵守一些协议才能确保一切工作正常。上图中的 UART 芯片会有一个容量是 16 的 FIFO，但是你还是要小心，因为如果阻塞了 16 个 Byte 之后再次写入还是会造成数据覆盖。
