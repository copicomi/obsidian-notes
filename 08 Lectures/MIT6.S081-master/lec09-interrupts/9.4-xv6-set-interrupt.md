# 9.4 在 XV6 中设置中断

当 XV6 启动时，Shell 会输出提示符“$ ”，如果我们在键盘上输入 ls，最终可以看到“$ ls”。我们接下来通过研究 Console 是如何显示出“$ ls”，来看一下设备中断是如何工作的。

实际上“$ ”和“ls”还不太一样，“$ ”是 Shell 程序的输出，而“ls”是用户通过键盘输入之后再显示出来的。

对于“$ ”来说，实际上就是设备会将字符传输给 UART 的寄存器，UART 之后会在发送完字符之后产生一个中断。在 QEMU 中，模拟的线路的另一端会有另一个 UART 芯片（模拟的），这个 UART 芯片连接到了虚拟的 Console，它会进一步将“$ ”显示在 console 上。

![](<../assets/image (822).png>)

另一方面，对于“ls”，这是用户输入的字符。键盘连接到了 UART 的输入线路，当你在键盘上按下一个按键，UART 芯片会将按键字符通过串口线发送到另一端的 UART 芯片。另一端的 UART 芯片先将数据 bit 合并成一个 Byte，之后再产生一个中断，并告诉处理器说这里有一个来自于键盘的字符。之后 Interrupt handler 会处理来自于 UART 的字符。我们接下来会深入通过这两部分来弄清楚这里是如何工作的。

![](<../assets/image (711).png>)

RISC-V 有许多与中断相关的寄存器：

- SIE（Supervisor Interrupt Enable）寄存器。这个寄存器中有一个 bit（E）专门针对例如 UART 的外部设备的中断；有一个 bit（S）专门针对软件中断，软件中断可能由一个 CPU 核触发给另一个 CPU 核；还有一个 bit（T）专门针对定时器中断。我们这节课只关注外部设备的中断。
- SSTATUS（Supervisor Status）寄存器。这个寄存器中有一个 bit 来打开或者关闭中断。每一个 CPU 核都有独立的 SIE 和 SSTATUS 寄存器，除了通过 SIE 寄存器来单独控制特定的中断，还可以通过 SSTATUS 寄存器中的一个 bit 来控制所有的中断。
- SIP（Supervisor Interrupt Pending）寄存器。当发生中断时，处理器可以通过查看这个寄存器知道当前是什么类型的中断。
- SCAUSE 寄存器，这个寄存器我们之前看过很多次。它会表明当前状态的原因是中断。
- STVEC 寄存器，它会保存当 trap，page fault 或者中断发生时，CPU 运行的用户程序的程序计数器，这样才能在稍后恢复程序的运行。

我们今天不会讨论 SCAUSE 和 STVEC 寄存器，因为在中断处理流程中，它们基本上与之前（注，lec06）的工作方式是一样的。接下来我们看看 XV6 是如何对其他寄存器进行编程，使得 CPU 处于一个能接受中断的状态。

接下来看看代码，首先是位于 start.c 的 start 函数。

![](<../assets/image (659).png>)

这里将所有的中断都设置在 Supervisor mode，然后设置 SIE 寄存器来接收 External，软件和定时器中断，之后初始化定时器。

接下来我们看一下 main 函数中是如何处理 External 中断。

![](<../assets/image (662).png>)

我们第一个外设是 console，这是我们 print 的输出位置。查看位于 console.c 的 consoleinit 函数。

![](<../assets/image (667).png>)

这里首先初始化了锁，我们现在还不关心这个锁。然后调用了 uartinit，uartinit 函数位于 uart.c 文件。这个函数实际上就是配置好 UART 芯片使其可以被使用。

![](<../assets/image (856).png>)

这里的流程是先关闭中断，之后设置波特率，设置字符长度为 8bit，重置 FIFO，最后再重新打开中断。

> 学生提问：什么是波特率？
>
> Frans 教授：这是串口线的传输速率。

以上就是 uartinit 函数，运行完这个函数之后，原则上 UART 就可以生成中断了。但是因为我们还没有对 PLIC 编程，所以中断不能被 CPU 感知。最终，在 main 函数中，需要调用 plicinit 函数。下图是 plicinit 函数。

![](<../assets/image (793).png>)

PLIC 与外设一样，也占用了一个 I/O 地址（0xC000_0000）。代码的第一行使能了 UART 的中断，这里实际上就是设置 PLIC 会接收哪些中断，进而将中断路由到 CPU。类似的，代码的第二行设置 PLIC 接收来自 IO 磁盘的中断，我们这节课不会介绍这部分内容。

main 函数中，plicinit 之后就是 plicinithart 函数。plicinit 是由 0 号 CPU 运行，之后，每个 CPU 的核都需要调用 plicinithart 函数表明对于哪些外设中断感兴趣。

![](<../assets/image (669).png>)

所以在 plicinithart 函数中，每个 CPU 的核都表明自己对来自于 UART 和 VIRTIO 的中断感兴趣。因为我们忽略中断的优先级，所以我们将优先级设置为 0。

到目前为止，我们有了生成中断的外部设备，我们有了 PLIC 可以传递中断到单个的 CPU。但是 CPU 自己还没有设置好接收中断，因为我们还没有设置好 SSTATUS 寄存器。在 main 函数的最后，程序调用了 scheduler 函数，

![](<../assets/image (777).png>)

scheduler 函数主要是运行进程。但是在实际运行进程之前，会执行 intr_on 函数来使得 CPU 能接收中断。

![](<../assets/image (839).png>)

intr_on 函数只完成一件事情，就是设置 SSTATUS 寄存器，打开中断标志位。

在这个时间点，中断被完全打开了。如果 PLIC 正好有 pending 的中断，那么这个 CPU 核会收到中断。

以上就是中断的基本设置。

> 学生提问：哪些核在 intr_on 之后打开了中断？
>
> Frans 教授：任何一个调用了 intr_on 的 CPU 核，都会接收中断。实际上所有的 CPU 核都会运行 intr_on 函数。
