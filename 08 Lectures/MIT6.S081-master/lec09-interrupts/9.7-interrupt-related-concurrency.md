# 9.7 Interrupt 相关的并发

接下来我们讨论一下与中断相关的并发，并发加大了中断编程的难度。这里的并发包括以下几个方面：

- 设备与 CPU 是并行运行的。例如当 UART 向 Console 发送字符的时候，CPU 会返回执行 Shell，而 Shell 可能会再执行一次系统调用，向 buffer 中写入另一个字符，这些都是在并行的执行。这里的并行称为 producer-consumer 并行。
- 中断会停止当前运行的程序。例如，Shell 正在运行第 212 个指令，突然来了个中断，Shell 的执行会立即停止。对于用户空间代码，这并不是一个大的问题，因为当我们从中断中返回时，我们会恢复用户空间代码，并继续执行执行停止的指令。我们已经在 trap 和 page fault 中看过了这部分内容。但是当内核被中断打断时，事情就不一样了。所以，代码运行在 kernel mode 也会被中断，这意味着即使是内核代码，也不是直接串行运行的。在两个内核指令之间，取决于中断是否打开，可能会被中断打断执行。对于一些代码来说，如果不能在执行期间被中断，这时内核需要临时关闭中断，来确保这段代码的原子性。
- 驱动的 top 和 bottom 部分是并行运行的。例如，Shell 会在传输完提示符“$”之后再调用 write 系统调用传输空格字符，代码会走到 UART 驱动的 top 部分（注，uartputc 函数），将空格写入到 buffer 中。但是同时在另一个 CPU 核，可能会收到来自于 UART 的中断，进而执行 UART 驱动的 bottom 部分，查看相同的 buffer。所以一个驱动的 top 和 bottom 部分可以并行的在不同的 CPU 上运行。这里我们通过 lock 来管理并行。因为这里有共享的数据，我们想要 buffer 在一个时间只被一个 CPU 核所操作。&#x20;

![](<../assets/image (735).png>)

这里我将会关注在第一点，也就是 producer/consumser 并发。这是驱动中的非常常见的典型现象。如你们所见的，在驱动中会有一个 buffer，在我们之前的例子中，buffer 是 32 字节大小。并且有两个指针，分别是读指针和写指针。

![](<../assets/image (819).png>)

如果两个指针相等，那么 buffer 是空的。当 Shell 调用 uartputc 函数时，会将字符，例如提示符“$”，写入到写指针的位置，并将写指针加 1。这就是 producer 对于 buffer 的操作。

![](<../assets/image (684).png>)

producer 可以一直写入数据，直到写指针 + 1 等于读指针，因为这时，buffer 已经满了。当 buffer 满了的时候，producer 必须停止运行。我们之前在 uartputc 函数中看过，如果 buffer 满了，代码会 sleep，暂时搁置 Shell 并运行其他的进程。

Interrupt handler，也就是 uartintr 函数，在这个场景下是 consumer，每当有一个中断，并且读指针落后于写指针，uartintr 函数就会从读指针中读取一个字符再通过 UART 设备发送，并且将读指针加 1。当读指针追上写指针，也就是两个指针相等的时候，buffer 为空，这时就不用做任何操作。

> 学生提问：这里的 buffer 对于所有的 CPU 核都是共享的吗？
>
> Frans 教授：这里的 buffer 存在于内存中，并且只有一份，所以，所有的 CPU 核都并行的与这一份数据交互。所以我们才需要 lock。
>
> 学生提问：对于 uartputc 中的 sleep，它怎么知道应该让 Shell 去 sleep？
>
> Frans 教授： sleep 会将当前在运行的进程存放于 sleep 数据中。它传入的参数是需要等待的信号，在这个例子中传入的是 uart_tx_r 的地址。在 uartstart 函数中，一旦 buffer 中有了空间，会调用与 sleep 对应的函数 wakeup，传入的也是 uart_tx_r 的地址。任何等待在这个地址的进程都会被唤醒。有时候这种机制被称为 conditional synchronization。

以上就是 Shell 输出提示符“$ ”的全部内容。如你们所见，过程还挺复杂的，许多代码一起工作才将这两个字符传输到了 Console。
