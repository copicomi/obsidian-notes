# 6.3 ECALL 指令之前的状态

接下来，我将切换到 gdb 的世界中。 大家可以看我共享的屏幕，我们将要跟踪一个 XV6 的系统调用，也就是 Shell 将它的提示信息通过 write 系统调用走到操作系统再输出到 console 的过程。你们可以看到，用户代码 sh.c 初始了这一切。

![](<../assets/image (324).png>)

上图中选中的行，是一个 write 系统调用，它将“$ ”写入到文件描述符 2。接下来我将打开 gdb 并启动 XV6。

![](<../assets/image (223).png>)

作为用户代码的 Shell 调用 write 时，实际上调用的是关联到 Shell 的一个库函数。你可以查看这个库函数的源代码，在 usys.s。

![](<../assets/image (216) (1) (1).png>)

上面这几行代码就是实际被调用的 write 函数的实现。这是个非常短的函数，它首先将 SYS_write 加载到 a7 寄存器，SYS_write 是常量 16。这里告诉内核，我想要运行第 16 个系统调用，而这个系统调用正好是 write。之后这个函数中执行了 ecall 指令，从这里开始代码执行跳转到了内核。内核完成它的工作之后，代码执行会返回到用户空间，继续执行 ecall 之后的指令，也就是 ret，最终返回到 Shell 中。所以 ret 从 write 库函数返回到了 Shell 中。

为了展示这里的系统调用，我会在 ecall 指令处放置一个断点，为了能放置断点，我们需要知道 ecall 指令的地址，我们可以通过查看由 XV6 编译过程产生的 sh.asm 找出这个地址。sh.asm 是带有指令地址的汇编代码（注，asm 文件 3.7 有介绍）。我这里会在 ecall 指令处放置一个断点，这条指令的地址是 0xde6。

![](<../assets/image (222).png>)

现在，我要让 XV6 开始运行。我期望的是 XV6 在 Shell 代码中正好在执行 ecall 之前就会停住。

![](<../assets/image (330).png>)

完美，从 gdb 可以看出，我们下一条要执行的指令就是 ecall。我们来检验一下我们真的在我们以为自己在的位置，让我们来打印程序计数器（Program Counter），正好我们期望在的位置 0xde6。

![](<../assets/image (259).png>)

我们还可以输入*info reg*打印全部 32 个用户寄存器，

![](<../assets/image (210).png>)

这里有一些数值我们还不知道，也不关心，但是这里的 a0，a1，a2 是 Shell 传递给 write 系统调用的参数。所以 a0 是文件描述符 2；a1 是 Shell 想要写入字符串的指针；a2 是想要写入的字符数。我们还可以通过打印 Shell 想要写入的字符串内容，来证明断点停在我们认为它应该停在的位置。

![](<../assets/image (342).png>)

可以看出，输出的确是美元符（$）和一个空格。所以，我们现在位于我们期望所在的 write 系统调用函数中。

有一件事情需要注意，上图的寄存器中，程序计数器（pc）和堆栈指针（sp）的地址现在都在距离 0 比较近的地址，这进一步印证了当前代码运行在用户空间，因为用户空间中所有的地址都比较小。但是一旦我们进入到了内核，内核会使用大得多的内存地址。

系统调用的时间点会有大量状态的变更，其中一个最重要的需要变更的状态，并且在它变更之前我们对它还有依赖的，就是是当前的 page table。我们可以查看 STAP 寄存器。

![](<../assets/image (369).png>)

这里输出的是物理内存地址，它并没有告诉我们有关 page table 中的映射关系是什么，page table 长什么样。但是幸运的是，在 QEMU 中有一个方法可以打印当前的 page table。从 QEMU 界面，输入*ctrl a + c*可以进入到 QEMU 的 console，之后输入*info mem*，QEMU 会打印完整的 page table。

![](<../assets/image (297).png>)

这是个非常小的 page table，它只包含了 6 条映射关系。这是用户程序 Shell 的 page table，而 Shell 是一个非常小的程序，这 6 条映射关系是有关 Shell 的指令和数据，以及一个无效的 page 用来作为 guard page，以防止 Shell 尝试使用过多的 stack page。我们可以看出这个 page 是无效的，因为在 attr 这一列它并没有设置 u 标志位（第三行）。attr 这一列是 PTE 的标志位，第三行的标志位是 rwx 表明这个 page 可以读，可以写，也可以执行指令。之后的是 u 标志位，它表明 PTE_u 标志位是否被设置，用户代码只能访问 u 标志位设置了的 PTE。再下一个标志位我也不记得是什么了（注，从 4.3 可以看出，这个标志位是 Global）。再下一个标志位是 a（Accessed），表明这条 PTE 是不是被使用过。再下一个标志位 d（Dirty）表明这条 PTE 是不是被写过。

现在，我们有了这个小小的 page table。顺便说一下，最后两条 PTE 的虚拟地址非常大，非常接近虚拟地址的顶端，如果你读过了 XV6 的书，你就知道这两个 page 分别是 trapframe page 和 trampoline page。你可以看到，它们都没有设置 u 标志，所以用户代码不能访问这两条 PTE。一旦我们进入到了 supervisor mode，我们就可以访问这两条 PTE 了。

对于这里 page table，有一件事情需要注意：它并没有包含任何内核部分的地址映射，这里既没有对于 kernel data 的映射，也没有对于 kernel 指令的映射。除了最后两条 PTE，这个 page table 几乎是完全为用户代码执行而创建，所以它对于在内核执行代码并没有直接特殊的作用。

> 学生提问：PTE 中 a 标志位是什么意思？
>
> Robert 教授：这表示这条 PTE 是不是被代码访问过，是不是曾经有一个被访问过的地址包含在这个 PTE 的范围内。d 标志位表明是否曾经有写指令使用过这条 PTE。这些标志位由硬件维护以方便操作系统使用。对于比 XV6 更复杂的操作系统，当物理内存吃紧的时候，可能会通过将一些内存写入到磁盘来，同时将相应的 PTE 设置成无效，来释放物理内存 page。你可以想到，这里有很多策略可以让操作系统来挑选哪些 page 可以释放。我们可以查看 a 标志位来判断这条 PTE 是否被使用过，如果它没有被使用或者最近没有被使用，那么这条 PTE 对应的 page 适合用来保存到磁盘中。类似的，d 标志位告诉内核，这个 page 最近被修改过。
>
> 不过 XV6 没有这样的策略。

接下来，我会在 Shell 中打印出 write 函数的内容。

![](<../assets/image (172).png>)

程序计数器现在指向 ecall 指令，我们接下来要执行 ecall 指令。现在我们还在用户空间，但是马上我们就要进入内核空间了。
