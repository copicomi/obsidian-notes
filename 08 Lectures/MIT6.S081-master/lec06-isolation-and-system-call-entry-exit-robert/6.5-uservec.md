# 6.5 uservec 函数

回到 XV6 和 RISC-V，现在程序位于 trampoline page 的起始，也是 uservec 函数的起始。我们现在需要做的第一件事情就是保存寄存器的内容。在 RISC-V 上，如果不能使用寄存器，基本上不能做任何事情。所以，对于保存这些寄存器，我们有什么样的选择呢？

在一些其他的机器中，我们或许直接就将 32 个寄存器中的内容写到物理内存中某些合适的位置。但是我们不能在 RISC-V 中这样做，因为在 RISC-V 中，supervisor mode 下的代码不允许直接访问物理内存。所以我们只能使用 page table 中的内容，但是从前面的输出来看，page table 中也没有多少内容。

虽然 XV6 并没有使用，但是另一种可能的操作是，直接将 SATP 寄存器指向 kernel page table，之后我们就可以直接使用所有的 kernel mapping 来帮助我们存储用户寄存器。这是合法的，因为 supervisor mode 可以更改 SATP 寄存器。但是在 trap 代码当前的位置，也就是 trap 机制的最开始，我们并不知道 kernel page table 的地址。并且更改 SATP 寄存器的指令，要求写入 SATP 寄存器的内容来自于另一个寄存器。所以，为了能执行更新 page table 的指令，我们需要一些空闲的寄存器，这样我们才能先将 page table 的地址存在这些寄存器中，然后再执行修改 SATP 寄存器的指令。

对于保存用户寄存器，XV6 在 RISC-V 上的实现包括了两个部分。第一个部分是，XV6 在每个 user page table 映射了 trapframe page，这样每个进程都有自己的 trapframe page。这个 page 包含了很多有趣的数据，但是现在最重要的数据是用来保存用户寄存器的 32 个空槽位。所以，在 trap 处理代码中，现在的好消息是，我们在 user page table 有一个之前由 kernel 设置好的映射关系，这个映射关系指向了一个可以用来存放这个进程的用户寄存器的内存位置。这个位置的虚拟地址总是 0x3ffffffe000。

如果你想查看 XV6 在 trapframe page 中存放了什么，这部分代码在 proc.h 中的 trapframe 结构体中。

![](<../assets/image (731).png>)

你可以看到很多槽位的名字都对应了特定的寄存器。在最开始还有 5 个数据，这些是内核事先存放在 trapframe 中的数据。比如第一个数据保存了 kernel page table 地址，这将会是 trap 处理代码将要加载到 SATP 寄存器的数值。

所以，如何保存用户寄存器的一半答案是，内核非常方便的将 trapframe page 映射到了每个 user page table。

另一半的答案在于我们之前提过的 SSCRATCH 寄存器。这个由 RISC-V 提供的 SSCRATCH 寄存器，就是为接下来的目的而创建的。在进入到 user space 之前，内核会将 trapframe page 的地址保存在这个寄存器中，也就是 0x3fffffe000 这个地址。更重要的是，RISC-V 有一个指令允许交换任意两个寄存器的值。而 SSCRATCH 寄存器的作用就是保存另一个寄存器的值，并将自己的值加载给另一个寄存器。如果我查看 trampoline.S 代码，

![](<../assets/image (749).png>)

第一件事情就是执行 csrrw 指令，这个指令交换了 a0 和 sscratch 两个寄存器的内容。为了看这里的实际效果，我们来打印 a0，

![](<../assets/image (847).png>)

a0 现在的值是 0x3fffffe000，这是 trapframe page 的虚拟地址。它之前保存在 SSCRATCH 寄存器中，但是我们现在交换到了 a0 中。我们也可以打印 SSCRATCH 寄存器，

![](<../assets/image (849).png>)

它现在的内容是 2，这是 a0 寄存器之前的值。a0 寄存器保存的是 write 函数的第一个参数，在这个场景下，是 Shell 传入的文件描述符 2。所以我们现在将 a0 的值保存起来了，并且我们有了指向 trapframe page 的指针。现在我们正在朝着保存用户寄存器的道路上前进。实际上，这就是 trampoline.S 中接下来 30 多个奇怪指令的工作。这些指令就是的执行 sd，将每个寄存器保存在 trapframe 的不同偏移位置。因为 a0 在交换完之后包含的是 trapframe page 地址，也就是 0x3fffffe000。所以，每个寄存器被保存在了偏移量+a0 的位置。这些存储的指令比较无聊，我就不介绍了。

> 学生提问：当与 a0 寄存器进行交换时，trapframe 的地址是怎么出现在 SSCRATCH 寄存器中的？
>
> Robert 教授：在内核前一次切换回用户空间时，内核会执行 set sscratch 指令，将这个寄存器的内容设置为 0x3fffffe000，也就是 trapframe page 的虚拟地址。所以，当我们在运行用户代码，比如运行 Shell 时，SSCRATCH 保存的就是指向 trapframe 的地址。之后，Shell 执行了 ecall 指令，跳转到了 trampoline page，这个 page 中的第一条指令会交换 a0 和 SSCRATCH 寄存器的内容。所以，SSCRATCH 中的值，也就是指向 trapframe 的指针现在存储与 a0 寄存器中。
>
> 同一个学生提问：这是发生在进程创建的过程中吗？这个 SSCRATCH 寄存器存在于哪？
>
> Robert 教授：这个寄存器存在于 CPU 上，这是 CPU 上的一个特殊寄存器。内核在什么时候设置的它呢？这有点复杂。它被设置的实际位置，我们可以看下图，

![](<../assets/image (750).png>)

> 选中的代码是内核在返回到用户空间之前执行的最后两条指令。在内核返回到用户空间时，会恢复所有的用户寄存器。之后会再次执行交换指令，csrrw。因为之前内核已经设置了 a0 保存的是 trap frame 地址，经过交换之后 SSCRATCH 仍然指向了 trapframe page 地址，而 a0 也恢复成了之前的数值。最后 sret 返回到了用户空间。
>
> 你或许会好奇，a0 是如何有 trapframe page 的地址。我们可以查看 trap.c 代码，

![](<../assets/image (699).png>)

> 这是内核返回到用户空间的最后的 C 函数。C 函数做的最后一件事情是调用 fn 函数，传递的参数是 TRAMFRAME 和 user page table。在 C 代码中，当你调用函数，第一个参数会存在 a0，这就是为什么 a0 里面的数值是指向 trapframe 的指针。fn 函数是就是刚刚我向你展示的位于 trampoline.S 中的代码。
>
> 学生提问：当你启动一个进程，之后进程在运行，之后在某个时间点进程执行了 ecall 指令，那么你是在什么时候执行上一个问题中的 fn 函数呢？因为这是进程的第一个 ecall 指令，所以这个进程之前应该没有调用过 fn 函数吧。
>
> Robert 教授：好的，或许对于这个问题的一个答案是：一台机器总是从内核开始运行的，当机器启动的时候，它就是在内核中。 任何时候，不管是进程第一次启动还是从一个系统调用返回，进入到用户空间的唯一方法是就是执行 sret 指令。sret 指令是由 RISC-V 定义的用来从 supervisor mode 转换到 user mode。所以，在任何用户代码执行之前，内核会执行 fn 函数，并设置好所有的东西，例如 SSCRATCH，STVEC 寄存器。
>
> 学生提问：当我们在汇编代码中执行 ecall 指令，是什么触发了 trampoline 代码的执行，是 CPU 中的从 user 到 supervisor 的标志位切换吗？
>
> Robert 教授：在我们的例子中，Shell 在用户空间执行了 ecall 指令。ecall 会完成几件事情，ecall 指令会设置当前为 supervisor mode，保存程序计数器到 SEPC 寄存器，并且将程序计数器设置成控制寄存器 STVEC 的内容。STVEC 是内核在进入到用户空间之前设置好的众多数据之一，内核会将其设置成 trampoline page 的起始位置。所以，当 ecall 指令执行时，ecall 会将 STVEC 拷贝到程序计数器。之后程序继续执行，但是却会在当前程序计数器所指的地址，也就是 trampoline page 的起始地址执行。
>
> 学生提问：寄存器保存在了 trapframe page，但是这些寄存器用户程序也能访问，为什么我们要使用内存中一个新的区域（指的是 trapframe page），而不是使用程序的栈？
>
> Robert 教授：好的，这里或许有两个问题。第一个是，为什么我们要保存寄存器？为什么内核要保存寄存器的原因，是因为内核即将要运行会覆盖这些寄存器的 C 代码。如果我们想正确的恢复用户程序，我们需要将这些寄存器恢复成它们在 ecall 调用之前的数值，所以我们需要将所有的寄存器都保存在 trapframe 中，这样才能在之后恢复寄存器的值。
>
> 另一个问题是，为什么这些寄存器保存在 trapframe，而不是用户代码的栈中？这个问题的答案是，我们不确定用户程序是否有栈，必然有一些编程语言没有栈，对于这些编程语言的程序，Stack Pointer 不指向任何地址。当然，也有一些编程语言有栈，但是或许它的格式很奇怪，内核并不能理解。比如，编程语言以堆中以小块来分配栈，编程语言的运行时知道如何使用这些小块的内存来作为栈，但是内核并不知道。所以，如果我们想要运行任意编程语言实现的用户程序，内核就不能假设用户内存的哪部分可以访问，哪部分有效，哪部分存在。所以内核需要自己管理这些寄存器的保存，这就是为什么内核将这些内容保存在属于内核内存的 trapframe 中，而不是用户内存。

程序现在仍然在 trampoline 的最开始，也就是 uservec 函数的最开始，我们基本上还没有执行任何内容。我在寄存器拷贝的结束位置设置了一个断点，我们在 gdb 中让代码继续执行，现在我们停在了下面这条 ld（load）指令。

![](<../assets/image (196).png>)

这条指令正在将 a0 指向的内存地址往后数的第 8 个字节开始的数据加载到 Stack Pointer 寄存器。a0 的内容现在是 trapframe page 的地址，从本节第一张图中，trapframe 的格式可以看出，第 8 个字节开始的数据是内核的 Stack Pointer（kernel_sp）。trapframe 中的 kernel_sp 是由 kernel 在进入用户空间之前就设置好的，它的值是这个进程的 kernel stack。所以这条指令的作用是初始化 Stack Pointer 指向这个进程的 kernel stack 的最顶端。指向完这条指令之后，我们打印一下当前的 Stack Pointer 寄存器，

![](<../assets/image (269).png>)

这是这个进程的 kernel stack。因为 XV6 在每个 kernel stack 下面放置一个 guard page，所以 kernel stack 的地址都比较大。

下一条指令是向 tp 寄存器写入数据。因为在 RISC-V 中，没有一个直接的方法来确认当前运行在多核处理器的哪个核上，XV6 会将 CPU 核的编号也就是 hartid 保存在 tp 寄存器。在内核中好几个地方都会使用了这个值，例如，内核可以通过这个值确定某个 CPU 核上运行了哪些进程。我们执行这条指令，并且打印 tp 寄存器。

![](<../assets/image (293).png>)

我们现在运行在 CPU 核 0，这说的通，因为我之前配置了 QEMU 只给 XV6 分配一个核，所以我们只能运行在核 0 上。

下一条指令是向 t0 寄存器写入数据。这里写入的是我们将要执行的第一个 C 函数的指针，也就是函数 usertrap 的指针。我们在后面会使用这个指针。

![](<../assets/image (287).png>)

下一条指令是向 t1 寄存器写入数据。这里写入的是 kernel page table 的地址，我们可以打印 t1 寄存器的内容。

![](<../assets/image (187).png>)

实际上严格来说，t1 的内容并不是 kernel page table 的地址，这是你需要向 SATP 寄存器写入的数据。它包含了 kernel page table 的地址，但是移位了（注，详见 4.3），并且包含了各种标志位。

下一条指令是交换 SATP 和 t1 寄存器。这条指令执行完成之后，当前程序会从 user page table 切换到 kernel page table。现在我们在 QEMU 中打印 page table，可以看出与之前的 page table 完全不一样。

![](<../assets/image (348).png>)

现在这里输出的是由内核设置好的巨大的 kernel page table。所以现在我们成功的切换了 page table，我们在这个位置进展的很好，Stack Pointer 指向了 kernel stack；我们有了 kernel page table，可以读取 kernel data。我们已经准备好了执行内核中的 C 代码了。

这里还有个问题，为什么代码没有崩溃？毕竟我们在内存中的某个位置执行代码，程序计数器保存的是虚拟地址，如果我们切换了 page table，为什么同一个虚拟地址不会通过新的 page table 寻址走到一些无关的 page 中？看起来我们现在没有崩溃并且还在执行这些指令。有人来猜一下原因吗？

> 学生回答：因为我们还在 trampoline 代码中，而 trampoline 代码在用户空间和内核空间都映射到了同一个地址。

完全正确。我不知道你们是否还记得 user page table 的内容，trampoline page 在 user page table 中的映射与 kernel page table 中的映射是完全一样的。这两个 page table 中其他所有的映射都是不同的，只有 trampoline page 的映射是一样的，因此我们在切换 page table 时，寻址的结果不会改变，我们实际上就可以继续在同一个代码序列中执行程序而不崩溃。这是 trampoline page 的特殊之处，它同时在 user page table 和 kernel page table 都有相同的映射关系。

之所以叫 trampoline page，是因为你某种程度在它上面“弹跳”了一下，然后从用户空间走到了内核空间。

最后一条指令是*jr t0*。执行了这条指令，我们就要从 trampoline 跳到内核的 C 代码中。这条指令的作用是跳转到 t0 指向的函数中。我们打印 t0 对应的一些指令，

![](<../assets/image (285).png>)

可以看到 t0 的位置对应于一个叫做 usertrap 函数的开始。接下来我们就要以 kernel stack，kernel page table 跳转到 usertrap 函数。
