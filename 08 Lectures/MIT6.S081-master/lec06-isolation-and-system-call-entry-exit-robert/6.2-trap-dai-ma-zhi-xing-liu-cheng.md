# 6.2 Trap 代码执行流程

我首先会简单介绍一下 trap 代码的执行流程，但是这节课大部分时间都会通过 gdb 来跟踪代码是如何通过 trap 进入到内核空间，这里会涉及到很多的细节。为了帮助你提前了解接下来的内容，我们会跟踪如何在 Shell 中调用 write 系统调用。从 Shell 的角度来说，这就是个 Shell 代码中的 C 函数调用，但是实际上，write 通过执行 ECALL 指令来执行系统调用。ECALL 指令会切换到具有 supervisor mode 的内核中。在这个过程中，内核中执行的第一个指令是一个由汇编语言写的函数，叫做 uservec。这个函数是内核代码 trampoline.s 文件的一部分。所以执行的第一个代码就是这个 uservec 汇编函数。

![](<../assets/image (220).png>)

之后，在这个汇编函数中，代码执行跳转到了由 C 语言实现的函数 usertrap 中，这个函数在 trap.c 中。

![](<../assets/image (235).png>)

现在代码运行在 C 中，所以代码更加容易理解。在 usertrap 这个 C 函数中，我们执行了一个叫做 syscall 的函数。

![](<../assets/image (216).png>)

这个函数会在一个表单中，根据传入的代表系统调用的数字进行查找，并在内核中执行具体实现了系统调用功能的函数。对于我们来说，这个函数就是 sys_write。

![](<../assets/image (332).png>)

sys_write 会将要显示数据输出到 console 上，当它完成了之后，它会返回给 syscall 函数。

![](<../assets/image (295).png>)

因为我们现在相当于在 ECALL 之后中断了用户代码的执行，为了用户空间的代码恢复执行，需要做一系列的事情。在 syscall 函数中，会调用一个函数叫做 usertrapret，它也位于 trap.c 中，这个函数完成了部分方便在 C 代码中实现的返回到用户空间的工作。

![](<../assets/image (273).png>)

除此之外，最终还有一些工作只能在汇编语言中完成。这部分工作通过汇编语言实现，并且存在于 trampoline.s 文件中的 userret 函数中。

![](<../assets/image (403).png>)

最终，在这个汇编函数中会调用机器指令返回到用户空间，并且恢复 ECALL 之后的用户程序的执行。

![](<../assets/image (364).png>)

对于这里的概述大家有问题吗？没有的话我要切到 gdb 了。

> 学生提问：vm.c 运行在什么 mode 下？
>
> Robert 教授：vm.c 中的所有函数都是内核的一部分，所以运行在 supervisor mode。
>
> 学生提问：为什么这些函数叫这些名字？
>
> Robert 教授：现在的函数命名比较乱，明年我会让它们变得更加合理一些。（助教说）我认为命名与寄存器的名字有关。
>
> 学生提问：难道 vm.c 里的函数不是要直接访问物理内存吗？
>
> Robert 教授：是的，这些函数能这么做的原因是，内核小心的在 page table 中设置好了各个 PTE。这样当内核收到了一个读写虚拟内存地址的请求，会通过 kernel page table 将这个虚拟内存地址翻译成与之等价物理内存地址，再完成读写。所以，一旦使用了 kernel page table，就可以非常方便的在内核中使用所有这些直接的映射关系。但是直到 trap 机制切换到内核之前，这些映射关系都不可用。直到 trap 机制将程序运行切换到内核空间之前，我们使用的仍然是没有这些方便映射关系的 user page table。
>
> 学生提问：这个问题或许并不完全相关，read 和 write 系统调用，相比内存的读写，他们的代价都高的多，因为它们需要切换模式，并来回捣腾。有没有可能当你执行打开一个文件的系统调用时， 直接得到一个 page table 映射，而不是返回一个文件描述符？这样只需要向对应于设备的特定的地址写数据，程序就能通过 page table 访问特定的设备。你可以设置好限制，就像文件描述符只允许修改特定文件一样，这样就不用像系统调用一样在用户空间和内核空间来回捣腾了。
>
> Robert 教授：这是个很好的想法。实际上很多操作系统都提供这种叫做内存映射文件（Memory-mapped file access）的机制，在这个机制里面通过 page table，可以将用户空间的虚拟地址空间，对应到文件内容，这样你就可以通过内存地址直接读写文件。实际上，你们将在 mmap 实验中完成这个机制。对于许多程序来说，这个机制的确会比直接调用 read/write 系统调用要快的多。
