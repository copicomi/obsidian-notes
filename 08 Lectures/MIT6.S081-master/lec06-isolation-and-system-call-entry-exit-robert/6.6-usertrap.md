# 6.6 usertrap 函数

usertrap 函数是位于 trap.c 文件的一个函数。

![](<../assets/image (347).png>)

既然我们已经运行在 C 代码中，接下来，我在 gdb 中输入 tui enable 打开对于 C 代码的展示。

![](<../assets/image (212).png>)

我们现在在一个更加正常的世界中，我们正在运行 C 代码，应该会更容易理解。我们仍然会读写一些有趣的控制寄存器，但是环境比起汇编语言来说会少了很多晦涩。

有很多原因都可以让程序运行进入到 usertrap 函数中来，比如系统调用，运算时除以 0，使用了一个未被映射的虚拟地址，或者是设备中断。usertrap 某种程度上存储并恢复硬件状态，但是它也需要检查触发 trap 的原因，以确定相应的处理方式，我们在接下来执行 usertrap 的过程中会同时看到这两个行为。

接下来，让我们一步步执行 usertrap 函数。

![](<../assets/image (226).png>)

它做的第一件事情是更改 STVEC 寄存器。取决于 trap 是来自于用户空间还是内核空间，实际上 XV6 处理 trap 的方法是不一样的。目前为止，我们只讨论过当 trap 是由用户空间发起时会发生什么。如果 trap 从内核空间发起，将会是一个非常不同的处理流程，因为从内核发起的话，程序已经在使用 kernel page table。所以当 trap 发生时，程序执行仍然在内核的话，很多处理都不必存在。

在内核中执行任何操作之前，usertrap 中先将 STVEC 指向了 kernelvec 变量，这是内核空间 trap 处理代码的位置，而不是用户空间 trap 处理代码的位置。

![](<../assets/image (229).png>)

出于各种原因，我们需要知道当前运行的是什么进程，我们通过调用 myproc 函数来做到这一点。myproc 函数实际上会查找一个根据当前 CPU 核的编号索引的数组，CPU 核的编号是 hartid，如果你还记得，我们之前在 uservec 函数中将它存在了 tp 寄存器。这是 myproc 函数找出当前运行进程的方法。

![](<../assets/image (394).png>)

接下来我们要保存用户程序计数器，它仍然保存在 SEPC 寄存器中，但是可能发生这种情况：当程序还在内核中执行时，我们可能切换到另一个进程，并进入到那个程序的用户空间，然后那个进程可能再调用一个系统调用进而导致 SEPC 寄存器的内容被覆盖。所以，我们需要保存当前进程的 SEPC 寄存器到一个与该进程关联的内存中，这样这个数据才不会被覆盖。这里我们使用 trapframe 来保存这个程序计数器。

![](<../assets/image (240).png>)

接下来我们需要找出我们现在会在 usertrap 函数的原因。根据触发 trap 的原因，RISC-V 的 SCAUSE 寄存器会有不同的数字。数字 8 表明，我们现在在 trap 代码中是因为系统调用。可以打印 SCAUSE 寄存器，它的确包含了数字 8，我们的确是因为系统调用才走到这里的。

![](<../assets/image (248).png>)

所以，我们可以进到这个 if 语句中。接下来第一件事情是检查是不是有其他的进程杀掉了当前进程，但是我们的 Shell 没有被杀掉，所以检查通过。

![](<../assets/image (233).png>)

在 RISC-V 中，存储在 SEPC 寄存器中的程序计数器，是用户程序中触发 trap 的指令的地址。但是当我们恢复用户程序时，我们希望在下一条指令恢复，也就是 ecall 之后的一条指令。所以对于系统调用，我们对于保存的用户程序计数器加 4，这样我们会在 ecall 的下一条指令恢复，而不是重新执行 ecall 指令。

![](<../assets/image (264).png>)

XV6 会在处理系统调用的时候使能中断，这样中断可以更快的服务，有些系统调用需要许多时间处理。中断总是会被 RISC-V 的 trap 硬件关闭，所以在这个时间点，我们需要显式的打开中断。

![](<../assets/image (180).png>)

下一行代码中，我们会调用 syscall 函数。这个函数定义在 syscall.c。

![](<../assets/image (376).png>)

它的作用是从 syscall 表单中，根据系统调用的编号查找相应的系统调用函数。如果你还记得之前的内容，Shell 调用的 write 函数将 a7 设置成了系统调用编号，对于 write 来说就是 16。所以 syscall 函数的工作就是获取由 trampoline 代码保存在 trapframe 中 a7 的数字，然后用这个数字索引实现了每个系统调用的表单。

我们可以打印 num，的确是 16。这与 Shell 调用的 write 函数写入的数字是一致的。

![](<../assets/image (381).png>)

之后查看通过 num 索引得到的函数，正是 sys_write 函数。sys_write 函数是内核对于 write 系统调用的具体实现。这里再往后的代码执行就非常复杂了，我就不具体介绍了。在这节课中，对于系统调用的实现，我只对进入和跳出内核感兴趣。这里我让代码直接执行 sys_write 函数。

这里有件有趣的事情，系统调用需要找到它们的参数。你们还记得 write 函数的参数吗？分别是文件描述符 2，写入数据缓存的指针，写入数据的长度 2。syscall 函数直接通过 trapframe 来获取这些参数，就像这里刚刚可以查看 trapframe 中的 a7 寄存器一样，我们可以查看 a0 寄存器，这是第一个参数，a1 是第二个参数，a2 是第三个参数。

![](<../assets/image (401).png>)

现在 syscall 执行了真正的系统调用，之后 sys_write 返回了。

![](<../assets/image (331).png>)

这里向 trapframe 中的 a0 赋值的原因是：所有的系统调用都有一个返回值，比如 write 会返回实际写入的字节数，而 RISC-V 上的 C 代码的习惯是函数的返回值存储于寄存器 a0，所以为了模拟函数的返回，我们将返回值存储在 trapframe 的 a0 中。之后，当我们返回到用户空间，trapframe 中的 a0 槽位的数值会写到实际的 a0 寄存器，Shell 会认为 a0 寄存器中的数值是 write 系统调用的返回值。执行完这一行代码之后，我们打印这里 trapframe 中 a0 的值，可以看到输出 2。

![](<../assets/image (740).png>)

这意味这 sys_write 的返回值是 2，符合传入的参数，这里只写入了 2 个字节。

从 syscall 函数返回之后，我们回到了 trap.c 中的 usertrap 函数。

![](<../assets/image (797).png>)

我们再次检查当前用户进程是否被杀掉了，因为我们不想恢复一个被杀掉的进程。当然，在我们的场景中，Shell 没有被杀掉。

![](<../assets/image (730).png>)

最后，usertrap 调用了一个函数 usertrapret。
