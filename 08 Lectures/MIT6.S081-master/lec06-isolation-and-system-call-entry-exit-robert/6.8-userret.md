# 6.8 userret 函数

现在程序执行又到了 trampoline 代码。

![](<../assets/image (796).png>)

第一步是切换 page table。在执行*csrw satp, a1*之前，page table 应该还是巨大的 kernel page table。这条指令会将 user page table（在 usertrapret 中作为第二个参数传递给了这里的 userret 函数，所以存在 a1 寄存器中）存储在 SATP 寄存器中。执行完这条指令之后，page table 就变成了小得多的 user page table。但是幸运的是，user page table 也映射了 trampoline page，所以程序还能继续执行而不是崩溃。（注，sfence.vma 是清空页表缓存，详见 4.4）。

![](<../assets/image (717).png>)

在 uservec 函数中，第一件事情就是交换 SSRATCH 和 a0 寄存器。而这里，我们将 SSCRATCH 寄存器恢复成保存好的用户的 a0 寄存器。在这里 a0 是 trapframe 的地址，因为 C 代码 usertrapret 函数中将 trapframe 地址作为第一个参数传递过来了。112 是 a0 寄存器在 trapframe 中的位置。（注，这里有点绕，本质就是通过当前的 a0 寄存器找出存在 trapframe 中的 a0 寄存器）我们先将这个地址里的数值保存在 t0 寄存器中，之后再将 t0 寄存器的数值保存在 SSCRATCH 寄存器中。

为止目前，所有的寄存器内容还是属于内核。

![](<../assets/image (741).png>)

接下来的这些指令将 a0 寄存器指向的 trapframe 中，之前保存的寄存器的值加载到对应的各个寄存器中。之后，我们离能真正运行用户代码就很近了。

> 学生提问：现在 trapframe 中的 a0 寄存器是我们执行系统调用的返回值吗？
>
> Robert 教授：是的，系统调用的返回值覆盖了我们保存在 trapframe 中的 a0 寄存器的值（详见 6.6）。我们希望用户程序 Shell 在 a0 寄存器中看到系统调用的返回值。所以，trapframe 中的 a0 寄存器现在是系统调用的返回值 2。相应的 SSCRATCH 寄存器中的数值也应该是 2，可以通过打印寄存器的值来验证。

![](<../assets/image (701).png>)

现在我们打印所有的寄存器，

![](<../assets/image (743).png>)

我不确定你们是否还记得，但是这些寄存器的值就是我们在最最开始看到的用户寄存器的值。例如 SP 寄存器保存的是 user stack 地址，这是一个在较小的内存地址；a1 寄存器是我们传递给 write 的 buffer 指针，a2 是我们传递给 write 函数的写入字节数。

a0 寄存器现在还是个例外，它现在仍然是指向 trapframe 的指针，而不是保存了的用户数据。

![](<../assets/image (873).png>)

接下来，在我们即将返回到用户空间之前，我们交换 SSCRATCH 寄存器和 a0 寄存器的值。前面我们看过了 SSCRATCH 现在的值是系统调用的返回值 2，a0 寄存器是 trapframe 的地址。交换完成之后，a0 持有的是系统调用的返回值，SSCRATCH 持有的是 trapframe 的地址。之后 trapframe 的地址会一直保存在 SSCRATCH 中，直到用户程序执行了另一次 trap。现在我们还在 kernel 中。

sret 是我们在 kernel 中的最后一条指令，当我执行完这条指令：

- 程序会切换回 user mode
- SEPC 寄存器的数值会被拷贝到 PC 寄存器（程序计数器）
- 重新打开中断

现在我们回到了用户空间。打印 PC 寄存器，

![](<../assets/image (715).png>)

这是一个较小的指令地址，非常像是在用户内存中。如果我们查看 sh.asm，可以看到这个地址是 write 函数的 ret 指令地址。

![](<../assets/image (645).png>)

所以，现在我们回到了用户空间，执行完 ret 指令之后我们就可以从 write 系统调用返回到 Shell 中了。或者更严格的说，是从触发了系统调用的 write 库函数中返回到 Shell 中。

> 学生提问：你可以再重复一下在 sret 过程中，中断会发生什么吗？
>
> Robert 教授：sret 打开了中断。所以在 supervisor mode 中的最后一个指令，我们会重新打开中断。用户程序可能会运行很长时间，最好是能在这段时间响应例如磁盘中断。

最后总结一下，系统调用被刻意设计的看起来像是函数调用，但是背后的 user/kernel 转换比函数调用要复杂的多。之所以这么复杂，很大一部分原因是要保持 user/kernel 之间的隔离性，内核不能信任来自用户空间的任何内容。

另一方面，XV6 实现 trap 的方式比较特殊，XV6 并不关心性能。但是通常来说，操作系统的设计人员和 CPU 设计人员非常关心如何提升 trap 的效率和速度。必然还有跟我们这里不一样的方式来实现 trap，当你在实现的时候，可以从以下几个问题出发：

- 硬件和软件需要协同工作，你可能需要重新设计 XV6，重新设计 RISC-V 来使得这里的处理流程更加简单，更加快速。
- 另一个需要时刻记住的问题是，恶意软件是否能滥用这里的机制来打破隔离性。

好的，这就是这节课的全部内容。
