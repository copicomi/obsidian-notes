# 15.4 log_write 函数

接下来让我们看一些代码来帮助我们理解这里是怎么工作的。前面我提过事务（transaction），也就是我们不应该在所有的写操作完成之前写入 commit record。这意味着文件系统操作必须表明事务的开始和结束。在 XV6 中，以创建文件的 sys_open 为例（在 sysfile.c 文件中）每个文件系统操作，都有 begin_op 和 end_op 分别表示事物的开始和结束。

![](<../assets/image (548).png>)

begin_op 表明想要开始一个事务，在最后有 end_op 表示事务的结束。并且事务中的所有写 block 操作具备原子性，这意味着这些写 block 操作要么全写入，要么全不写入。XV6 中的文件系统调用都有这样的结构，最开始是 begin_op，之后是实现系统调用的代码，最后是 end_op。在 end_op 中会实现 commit 操作。

在 begin_op 和 end_op 之间，磁盘上或者内存中的数据结构会更新。但是在 end_op 之前，并不会有实际的改变（注，也就是不会写入到实际的 block 中）。在 end_op 时，我们会将数据写入到 log 中，之后再写入 commit record 或者 log header。这里有趣的是，当文件系统调用执行写磁盘时会发生什么？

让我们看一下 fs.c 中的 ialloc，

![](<../assets/image (415).png>)

在这个函数中，并没有直接调用 bwrite，这里实际调用的是 log_write 函数。log_write 是由文件系统的 logging 实现的方法。任何一个文件系统调用的 begin_op 和 end_op 之间的写操作总是会走到 log_write。log_write 函数位于 log.c 文件，

![](<../assets/image (443).png>)

log_write 还是很简单直观的，我们已经向 block cache 中的某个 block 写入了数据。比如写 block 45，我们已经更新了 block cache 中的 block 45。接下来我们需要在内存中记录，在稍后的 commit 中，要将 block 45 写入到磁盘的 log 中。

这里的代码先获取 log header 的锁，之后再更新 log header。首先代码会查看 block 45 是否已经被 log 记录了。如果是的话，其实不用做任何事情，因为 block 45 已经会被写入了。这种忽略的行为称为 log absorbtion。如果 block 45 不在需要写入到磁盘中的 block 列表中，接下来会对 n 加 1，并将 block 45 记录在列表的最后。之后，这里会通过调用 bpin 函数将 block 45 固定在 block cache 中，我们稍后会介绍为什么要这么做（注，详见 15.8）。

以上就是 log_write 的全部工作了。任何文件系统调用，如果需要更新 block 或者说更新 block cache 中的 block，都会将 block 编号加在这个内存数据中（注，也就是 log header 在内存中的 cache），除非编号已经存在。

> 学生提问：这是不是意味着，bwrite 不能直接使用？
>
> Frans 教授：是的，可以这么认为，文件系统中的所有 bwrite 都需要被 log_write 替换。
