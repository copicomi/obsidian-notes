# 15.7 Log 写磁盘流程

我已经在 bwrite 函数中加了一个 print 语句。bwrite 函数是 block cache 中实际写磁盘的函数，所以我们将会看到实际写磁盘的记录。在上节课（Lec 14）我将 print 语句放在了 log_write 中，log_write 只能代表文件系统操作的记录，并不能代表实际写磁盘的记录。我们这里会像上节课一样执行 echo "hi" > x，并看一下实际的写磁盘过程。

![](<../assets/image (522).png>)

很明显这里的记录要比只在 log_write 中记录要长的多。之前的 log_write 只有 11 条记录（注，详见 14.5）但是可以看到实际上背后有很多个磁盘写操作，让我们来分别看一下这里的写磁盘操作：

- 首先是前 3 行的 bwrite 3，4，5。因为 block 3 是第一个 log data block，所以前 3 行是在 log 中记录了 3 个写操作。这 3 个写操作都保存在 log 中，并且会写入到磁盘中的 log 部分。
- 第 4 行的 bwrite 2。因为 block 2 是 log 的起始位置，也就是 log header，所以这条是 commit 记录。
- 第 5，6，7 行的 bwrite 33，46，32。这里实际就是将前 3 行的 log data 写入到实际的文件系统的 block 位置，这里实际是 install log。
- 第 8 行的 bwrite 2，是清除 log（注，也就是将 log header 中的 n 设置为 0）。到此为止，完成了实际上的写 block 33，46，32 这一系列的操作。第一部分是 log write，第二部分是 install log，每一部分后面还跟着一个更新 commit 记录（注，也就是 commit log 和 clean log）。

> 学生提问：可以从这里的记录找到一次文件操作的 begin_op 和 end_op 位置吗？
>
> Frans 教授：大概可以知道。我们实际上不知道 begin_op 的位置，但是所有的文件系统操作都从 begin_op 开始。更新 commit 记录必然在 end_op 中，所以我们可以找到文件系统操作的 end_op 位置，之后就是 begin_op（注，其实这里所有的操作都在 end_op 中，只需要区分每一次 end_op 的调用就可以找到 begin_op）。

所以以上就是 XV6 中文件系统的 logging 介绍，即使是这么一个简单的 logging 系统也有一定的复杂度。这里立刻可以想到的一个问题是，通过观察这些记录，这是一个很有效的实现吗？很明显不是的，因为数据被写了两次。如果我写一个大文件，我需要在磁盘中将这个大文件写两次。所以这必然不是一个高性能的实现，为了实现 Crash safety 我们将原本的性能降低了一倍。当你们去读 ext3 论文时，你们应该时刻思考如何避免这里的性能降低一倍的问题。
