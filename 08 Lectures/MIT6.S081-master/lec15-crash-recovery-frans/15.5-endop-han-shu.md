# 15.5 end_op 函数

接下来我们看看位于 log.c 中的 end_op 函数中会发生什么？

![](<../assets/image (541).png>)

可以看到，即使是这么简单的一个文件系统也有一些微秒的复杂之处，代码的最开始就是一些复杂情况的处理（注，15.8 有这部分的解释）。我直接跳到正常且简单情况的代码。在简单情况下，没有其他的文件系统操作正在处理中。这部分代码非常简单直观，首先调用了 commit 函数。让我们看一下 commit 函数的实现，

![](<../assets/image (466).png>)

commit 中有两个操作：

- 首先是 write_log。这基本上就是将所有存在于内存中的 log header 中的 block 编号对应的 block，从 block cache 写入到磁盘上的 log 区域中（注，也就是将变化先从内存拷贝到 log 中）。
- write_head 会将内存中的 log header 写入到磁盘中。

我们看一下 write_log 的实现。

![](<../assets/image (485).png>)

函数中依次遍历 log 中记录的 block，并写入到 log 中。它首先读出 log block，将 cache 中的 block 拷贝到 log block，最后再将 log block 写回到磁盘中。这样可以确保需要写入的 block 都记录在 log 中。但是在这个位置，我们还没有 commit，现在我们只是将 block 存放在了 log 中。如果我们在这个位置也就是在 write_head 之前 crash 了，那么最终的表现就像是 transaction 从来没有发生过。

接下来看一下 write_head 函数，我之前将 write_head 称为 commit point。

![](<../assets/image (628).png>)

函数也比较直观，首先读取 log 的 header block。将 n 拷贝到 block 中，将所有的 block 编号拷贝到 header 的列表中。最后再将 header block 写回到磁盘。函数中的倒数第 2 行，bwrite 是实际的 commit point 吗？如果 crash 发生在这个 bwrite 之前，会发生什么？

这时虽然我们写了 log 的 header block，但是数据并没有落盘。所以 crash 并重启恢复时，并不会发生任何事情。那 crash 发生在 bwrite 之后会发生什么呢？

这时 header 会写入到磁盘中，当重启恢复相应的文件系统操作会被恢复。在恢复过程的某个时间点，恢复程序可以读到 log header 并发现比如说有 5 个 log 还没有 install，恢复程序可以将这 5 个 log 拷贝到实际的位置。所以这里的 bwrite 就是实际的 commit point。在 commit point 之前，transaction 并没有发生，在 commit point 之后，只要恢复程序正确运行，transaction 必然可以完成。

回到 commit 函数，在 commit point 之后，就会实际应用 transaction。这里很直观，就是读取 log block 再查看 header 这个 block 属于文件系统中的哪个 block，最后再将 log block 写入到文件系统相应的位置。让我们看一下 install_trans 函数，

![](<../assets/image (562).png>)

这里先读取 log block，再读取文件系统对应的 block。将数据从 log 拷贝到文件系统，最后将文件系统 block 缓存落盘。这里实际上就是将 block 数据从 log 中拷贝到了实际的文件系统 block 中。当然，可能在这里代码的某个位置会出现问题，但是这应该也没问题，因为在恢复的时候，我们会从最开始重新执行过。

在 commit 函数中，install 结束之后，会将 log header 中的 n 设置为 0，再将 log header 写回到磁盘中。将 n 设置为 0 的效果就是清除 log。

> 学生提问：install_trans 函数在写 block 的时候，先写的缓存。可不可以优化一下直接写磁盘而不写缓存让代码运行的更快一些？
>
> Frans 教授：这里的接口是不太好。你可能会想问反正都要写入新数据，为什么要先读出目标 block 来。这里的代码肯定还有很多优化空间，但是为了看起来简单我们并没有这么做。

以上就是 commit 内容。
