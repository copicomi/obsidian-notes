# 15.8 File system challenges

前面说到 XV6 的文件系统有一定的复杂性，接下来我将介绍一下三个复杂的地方或者也可以认为是三个挑战。

第一个是 cache eviction。假设 transaction 还在进行中，我们刚刚更新了 block 45，正要更新下一个 block，而整个 buffer cache 都满了并且决定撤回 block 45。在 buffer cache 中撤回 block 45 意味着我们需要将其写入到磁盘的 block 45 位置，这里会不会有问题？如果我们这么做了的话，会破坏什么规则吗？是的，如果将 block 45 写入到磁盘之后发生了 crash，就会破坏 transaction 的原子性。这里也破坏了前面说过的 write ahead rule，write ahead rule 的含义是，你需要先将所有的 block 写入到 log 中，之后才能实际的更新文件系统 block。所以 buffer cache 不能撤回任何还位于 log 的 block。

前面在介绍 log_write 函数时，其中调用了一个叫做 bpin 的函数，这个函数的作用就如它的名字一样，将 block 固定在 buffer cache 中。它是通过给 block cache 增加引用计数来避免 cache 撤回对应的 block。在之前（注，详见 14.6）我们看过，如果引用计数不为 0，那么 buffer cache 是不会撤回 block cache 的。相应的在将来的某个时间，所有的数据都写入到了 log 中，我们可以在 cache 中 unpin block（注，在 15.5 中的 install_trans 函数中会有 unpin，因为这时 block 已经写入到了 log 中）。所以这是第一个复杂的地方，我们需要 pin/unpin buffer cache 中的 block。

![](<../assets/image (539).png>)

第二个挑战是，文件系统操作必须适配 log 的大小。在 XV6 中，总共有 30 个 log block（注，详见 14.3）。当然我们可以提升 log 的尺寸，在真实的文件系统中会有大得多的 log 空间。但是无所谓啦，不管 log 多大，文件系统操作必须能放在 log 空间中。如果一个文件系统操作尝试写入超过 30 个 block，那么意味着部分内容需要直接写到文件系统区域，而这是不被允许的，因为这违背了 write ahead rule。所以所有的文件系统操作都必须适配 log 的大小。

为什么 XV6 的 log 大小是 30？因为 30 比任何一个文件系统操作涉及的写操作数都大，Robert 和我看了一下所有的文件系统操作，发现都远小于 30，所以就将 XV6 的 log 大小设为 30。我们目前看过的一些文件系统操作，例如创建一个文件只包含了写 5 个 block。实际上大部分文件系统操作只会写几个 block。你们可以想到什么样的文件系统操作会写很多很多个 block 吗？是的，写一个大文件。如果我们调用 write 系统调用并传入 1M 字节的数据，这对应了写 1000 个 block，这看起来会有很严重的问题，因为这破坏了我们刚刚说的“文件系统操作必须适配 log 的大小”这条规则。

让我们看一下 file.c 文件中的 file_write 函数。

![](<../assets/image (584).png>)

从这段代码可以看出，如果写入的 block 数超过了 30，那么一个写操作会被分割成多个小一些的写操作。这里整个写操作不是原子的，但是这还好啦，因为 write 系统调用的语义并不要求所有 1000 个 block 都是原子的写入，它只要求我们不要损坏文件系统。所以 XV6 会将一个大的写操作分割成多个小的写操作，每一个小的写操作通过独立的 transaction 写入。这样文件系统本身不会陷入不正确的状态中。

这里还需要注意，因为 block 在落盘之前需要在 cache 中 pin 住，所以 buffer cache 的尺寸也要大于 log 的尺寸。

![](<../assets/image (511).png>)

最后一个要讨论的挑战是并发文件系统调用。让我先来解释一下这里会有什么问题，再看对应的解决方案。假设我们有一段 log，和两个并发的执行的 transaction，其中 transaction t0 在 log 的前半段记录，transaction t1 在 log 的后半段记录。可能我们用完了 log 空间，但是任何一个 transaction 都还没完成。

![](<../assets/image (479).png>)

现在我们能提交任何一个 transaction 吗？我们不能，因为这样的话我们就提交了一个部分完成的 transaction，这违背了 write ahead rule，log 本身也没有起到应该的作用。所以必须要保证多个并发 transaction 加在一起也适配 log 的大小。所以当我们还没有完成一个文件系统操作时，我们必须在确保可能写入的总的 log 数小于 log 区域的大小的前提下，才允许另一个文件系统操作开始。

XV6 通过限制并发文件系统操作的个数来实现这一点。在 begin_op 中，我们会检查当前有多少个文件系统操作正在进行。如果有太多正在进行的文件系统操作，我们会通过 sleep 停止当前文件系统操作的运行，并等待所有其他所有的文件系统操作都执行完并 commit 之后再唤醒。这里的其他所有文件系统操作都会一起 commit。有的时候这被称为 group commit，因为这里将多个操作像一个大的 transaction 一样提交了，这里的多个操作要么全部发生了，要么全部没有发生。

![](<../assets/image (409).png>)

> 学生提问：group commit 有必要吗？不能当一个文件系统操作结束的时候就 commit 掉，然后再 commit 其他的操作吗？
>
> Frans 教授：如果这样的话你需要非常非常小心。因为有一点我没有说得很清楚，我们需要保证 write 系统调用的顺序。如果一个 read 看到了一个 write，再执行了一次 write，那么第二个 write 必须要发生在第一个 write 之后。在 log 中的顺序，本身就反应了 write 系统调用的顺序，你不能改变 log 中 write 系统调用的执行顺序，因为这可能会导致对用户程序可见的奇怪的行为。所以必须以 transaction 发生的顺序 commit 它们，而一次性提交所有的操作总是比较安全的，这可以保证文件系统处于一个好的状态。

最后我们再回到最开始，看一下 begin_op，

![](<../assets/image (581).png>)

首先，如果 log 正在 commit 过程中，那么就等到 log 提交完成，因为我们不能在 install log 的过程中写 log；其次，如果当前操作是允许并发的操作个数的后一个，那么当前操作可能会超过 log 区域的大小，我们也需要 sleep 并等待所有之前的操作结束；最后，如果当前操作可以继续执行，需要将 log 的 outstanding 字段加 1，最后再退出函数并执行文件系统操作。

再次看一下 end_op 函数，

![](<../assets/image (482).png>)

在最开始首先会对 log 的 outstanding 字段减 1，因为一个 transaction 正在结束；其次检查 committing 状态，当前不可能在 committing 状态，所以如果是的话会触发 panic；如果当前操作是整个并发操作的最后一个的话（log.outstanding == 0），接下来立刻就会执行 commit；如果当前操作不是整个并发操作的最后一个的话，我们需要唤醒在 begin_op 中 sleep 的操作，让它们检查是不是能运行。

（注，这里的 outstanding 有点迷，它表示的是当前正在并发执行的文件系统操作的个数，MAXOPBLOCKS 定义了一个操作最大可能涉及的 block 数量。在 begin_op 中，只要 log 空间还足够，就可以一直增加并发执行的文件系统操作。所以 XV6 是通过设定了 MAXOPBLOCKS，再间接的限定支持的并发文件系统操作的个数）

所以，即使是 XV6 中这样一个简单的文件系统，也有一些复杂性和挑战。

最后让我总结一下：

这节课讨论的是使用 logging 来解决 crash safety 或者说多个步骤的文件系统操作的安全性。这种方式对于安全性来说没有问题，但是性能不咋地。

> 学生提问：前面说到 cache size 至少要跟 log size 一样大，如果它们一样大的话，并且 log pin 了 30 个 block，其他操作就不能再进行了，因为 buffer 中没有额外的空间了。
>
> Frans 教授：如果 buffer cache 中没有空间了，XV6 会直接 panic。这并不理想，实际上有点恐怖。所以我们在挑选 buffer cache size 的时候希望用一个不太可能导致这里问题的数字。这里为什么不能直接返回错误，而是要 panic？因为很多文件系统操作都是多个步骤的操作，假设我们执行了两个 write 操作，但是第三个 write 操作找不到可用的 cache 空间，那么第三个操作无法完成，我们不能就直接返回错误，因为我们可能已经更新了一个目录的某个部分，为了保证文件系统的正确性，我们需要撤回之前的更新。所以如果 log pin 了 30 个 block，并且 buffer cache 没有额外的空间了，会直接 panic。当然这种情况不太会发生，只有一些极端情况才会发生。
