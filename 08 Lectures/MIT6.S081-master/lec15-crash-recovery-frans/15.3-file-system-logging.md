# 15.3 File system logging

我们这节课要讨论的针对文件系统 crash 之后的问题的解决方案，其实就是 logging。这是来自于数据库的一种解决方案。它有一些好的属性：

- 首先，它可以确保文件系统的系统调用是原子性的。比如你调用 create/write 系统调用，这些系统调用的效果是要么完全出现，要么完全不出现，这样就避免了一个系统调用只有部分写磁盘操作出现在磁盘上。
- 其次，它支持快速恢复（Fast Recovery）。在重启之后，我们不需要做大量的工作来修复文件系统，只需要非常小的工作量。这里的快速是相比另一个解决方案来说，在另一个解决方案中，你可能需要读取文件系统的所有 block，读取 inode，bitmap block，并检查文件系统是否还在一个正确的状态，再来修复。而 logging 可以有快速恢复的属性。
- 最后，原则上来说，它可以非常的高效，尽管我们在 XV6 中看到的实现不是很高效。

我们会在下节课看一下，如何构建一个 logging 系统，并同时具有原子性的系统调用，快速恢复和高性能，而今天，我们只会关注前两点。

![](<../assets/image (411).png>)

logging 的基本思想还是很直观的。首先，你将磁盘分割成两个部分，其中一个部分是 log，另一个部分是文件系统，文件系统可能会比 log 大得多。

（log write）当需要更新文件系统时，我们并不是更新文件系统本身。假设我们在内存中缓存了 bitmap block，也就是 block 45。当需要更新 bitmap 时，我们并不是直接写 block 45，而是将数据写入到 log 中，并记录这个更新应该写入到 block 45。对于所有的写 block 都会有相同的操作，例如更新 inode，也会记录一条写 block 33 的 log。

![](<../assets/image (611).png>)

所以基本上，任何一次写操作都是先写入到 log，我们并不是直接写入到 block 所在的位置，而总是先将写操作写入到 log 中。

（commit op）之后在某个时间，当文件系统的操作结束了，比如说我们前一节看到的 4-5 个写 block 操作都结束，并且都存在于 log 中，我们会 commit 文件系统的操作。这意味着我们需要在 log 的某个位置记录属于同一个文件系统的操作的个数，例如 5。

（install log）当我们在 log 中存储了所有写 block 的内容时，如果我们要真正执行这些操作，只需要将 block 从 log 分区移到文件系统分区。我们知道第一个操作该写入到 block 45，我们会直接将数据从 log 写到 block45，第二个操作该写入到 block 33，我们会将它写入到 block 33，依次类推。

（clean log）一旦完成了，就可以清除 log。清除 log 实际上就是将属于同一个文件系统的操作的个数设置为 0。

![](<../assets/image (481).png>)

以上就是 log 的基本工作方式。为什么这样的工作方式是好的呢？假设我们 crash 并重启了。在重启的时候，文件系统会查看 log 的 commit 记录值，如果是 0 的话，那么什么也不做。如果大于 0 的话，我们就知道 log 中存储的 block 需要被写入到文件系统中，很明显我们在 crash 的时候并不一定完成了 install log，我们可能是在 commit 之后，clean log 之前 crash 的。所以这个时候我们需要做的就是 reinstall（注，也就是将 log 中的 block 再次写入到文件系统），再 clean log。

![](<../assets/image (435).png>)

这里的方法之所以能起作用，是因为可以确保当发生 crash（并重启之后），我们要么将写操作所有相关的 block 都在文件系统中更新了，要么没有更新任何一个 block，我们永远也不会只写了一部分 block。为什么可以确保呢？我们考虑 crash 的几种可能情况。

- 在第 1 步和第 2 步之间 crash 会发生什么？在重启的时候什么也不会做，就像系统调用从没有发生过一样，也像 crash 是在文件系统调用之前发生的一样。这完全可以，并且也是可接受的。
- 在第 2 步和第 3 步之间 crash 会发生什么？在这个时间点，所有的 log block 都落盘了，因为有 commit 记录，所以完整的文件系统操作必然已经完成了。我们可以将 log block 写入到文件系统中相应的位置，这样也不会破坏文件系统。所以这种情况就像系统调用正好在 crash 之前就完成了。
- 在 install（第 3 步）过程中和第 4 步之前这段时间 crash 会发生什么？在下次重启的时候，我们会 redo log，我们或许会再次将 log block 中的数据再次拷贝到文件系统。这样也是没问题的，因为 log 中的数据是固定的，我们就算重复写了文件系统，每次写入的数据也是不变的。重复写入并没有任何坏处，因为我们写入的数据可能本来就在文件系统中，所以多次 install log 完全没问题。当然在这个时间点，我们不能执行任何文件系统的系统调用。我们应该在重启文件系统之前，在重启或者恢复的过程中完成这里的恢复操作。换句话说，install log 是幂等操作（注，idempotence，表示执行多次和执行一次效果一样），你可以执行任意多次，最后的效果都是一样的。

> 学生提问：因为这里的接口只有 read/write，但是如果我们做 append 操作，就不再安全了，对吧？
>
> Frans 教授：某种程度来说，append 是文件系统层面的操作，在这个层面，我们可以使用上面介绍的 logging 机制确保其原子性（注，append 也可以拆解成底层的 read/write）。
>
> 学生提问：当正在 commit log 的时候 crash 了会发生什么？比如说你想执行多个写操作，但是只 commit 了一半。
>
> Frans 教授：在上面的第 2 步，执行 commit 操作时，你只会在记录了所有的 write 操作之后，才会执行 commit 操作。所以在执行 commit 时，所有的 write 操作必然都在 log 中。而 commit 操作本身也有个有趣的问题，它究竟会发生什么？如我在前面指出的，commit 操作本身只会写一个 block。文件系统通常可以这么假设，单个 block 或者单个 sector 的 write 是原子操作（注，有关 block 和 sector 的区别详见 14.3）。这里的意思是，如果你执行写操作，要么整个 sector 都会被写入，要么 sector 完全不会被修改。所以 sector 本身永远也不会被部分写入，并且 commit 的目标 sector 总是包含了有效的数据。而 commit 操作本身只是写 log 的 header，如果它成功了只是在 commit header 中写入 log 的长度，例如 5，这样我们就知道 log 的长度为 5。这时 crash 并重启，我们就知道需要重新 install 5 个 block 的 log。如果 commit header 没能成功写入磁盘，那这里的数值会是 0。我们会认为这一次事务并没有发生过。这里本质上是 write ahead rule，它表示 logging 系统在所有的写操作都记录在 log 中之前，不能 install log。

Logging 的实现方式有很多，我这里展示的指示一种非常简单的方案，这个方案中 clean log 和 install log 都被推迟了。接下来我会运行这种非常简单的实现方式，之后在下节课我们会看到更加复杂的 logging 协议。不过所有的这些协议都遵循了 write ahead rule，也就是说在写入 commit 记录之前，你需要确保所有的写操作都在 log 中。在这个范围内，还有大量设计上的灵活性可以用来设计特定的 logging 协议。

在 XV6 中，我们会看到数据有两种状态，是在磁盘上还是在内存中。内存中的数据会在 crash 或者电力故障之后丢失。

![](<../assets/image (437).png>)

XV6 的 log 结构如往常一样也是极其的简单。我们在最开始有一个 header block，也就是我们的 commit record，里面包含了：

- 数字 n 代表有效的 log block 的数量
- 每个 log block 的实际对应的 block 编号

![](<../assets/image (544).png>)

之后就是 log 的数据，也就是每个 block 的数据，依次为 bn0 对应的 block 的数据，bn1 对应的 block 的数据以此类推。这就是 log 中的内容，并且 log 也不包含其他内容。

![](<../assets/image (625).png>)

当文件系统在运行时，在内存中也有 header block 的一份拷贝，拷贝中也包含了 n 和 block 编号的数组。这里的 block 编号数组就是 log 数据对应的实际 block 编号，并且相应的 block 也会缓存在 block cache 中，这个在 Lec14 有介绍过。与前一节课对应，log 中第一个 block 编号是 45，那么在 block cache 的某个位置，也会有 block 45 的 cache。

![](<../assets/image (417).png>)

以上就是内存中的文件系统和磁盘上的文件系统的结构。
