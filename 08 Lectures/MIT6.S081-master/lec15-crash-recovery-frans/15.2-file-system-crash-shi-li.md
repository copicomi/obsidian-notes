# 15.2 File system crash 示例

为了更清晰的理解这里的风险，让我们看一些基于 XV6 的例子，并看一下哪里可能出错。我们在上节课介绍了 XV6 有一个非常简单的文件系统和磁盘数据的排布方式。

![](<../assets/image (405).png>)

在 super block 之后就是 log block，我们今天主要介绍的就是 log block。log block 之后是 inode block，每个 block 可能包含了多个 inode。之后是 bitmap block，它记录了哪个 data block 是空闲的。最后是 data block，这里包含了文件系统的实际数据。

在上节课中，我们看了一下在创建文件时，操作系统与磁盘 block 的交互过程（注，详见 14.5）：

![](<../assets/image (554).png>)

从上面可以看出，创建一个文件涉及到了多个操作：

- 首先是分配 inode，因为首先写的是 block 33
- 之后 inode 被初始化，然后又写了一次 block 33
- 之后是写 block 46，是将文件 x 的 inode 编号写入到 x 所在目录的 inode 的 data block 中
- 之后是更新 root inode，因为文件 x 创建在根目录，所以需要更新根目录的 inode 的 size 字段，以包含这里新创建的文件 x
- 最后再次更新了文件 x 的 inode

现在我们想知道，哪里可能出错。假设我们在下面这个位置出现了电力故障或者内核崩溃。

![](<../assets/image (549).png>)

在出现电力故障之后，因为内存数据保存在 RAM 中，所有的内存数据都丢失了。所有的进程数据，所有的文件描述符，内存中所有的缓存都没有了，因为内存数据不是持久化的。我们唯一剩下的就是磁盘上的数据，因为磁盘的介质是持久化的，所以只有磁盘上的数据能够在电力故障之后存活。基于这些事实，如果我们在上面的位置出现故障，并且没有额外的机制，没有 logging，会有多糟糕呢？我们这里会有什么风险？

在这个位置，我们先写了 block 33 表明 inode 已被使用，之后出现了电力故障，然后计算机又重启了。这时，我们丢失了刚刚分配给文件 x 的 inode。这个 inode 虽然被标记为已被分配，但是它并没有放到任何目录中，所以也就没有出现在任何目录中，因此我们也就没办法删除这个 inode。所以在这个位置发生电力故障会导致我们丢失 inode。

你或许会认为，我们应该改一改代码，将写 block 的顺序调整一下，这样就不会丢失 inode 了。所以我们可以先写 block 46 来更新目录内容，之后再写 block 32 来更新目录的 size 字段，最后再将 block 33 中的 inode 标记为已被分配。

![](<../assets/image (406).png>)

这里的效果是一样的，只是顺序略有不同。并且这样我们应该可以避免丢失 inode 的问题。那么问题来了，这里可以工作吗？我们应该问问自己，如果在下面的位置发生了电力故障会怎样？

![](<../assets/image (543).png>)

在这个位置，目录被更新了，但是还没有在磁盘上分配 inode（有个问题，如果 inode 没分配的话，write 46 的时候写的是啥）。电力故障之后机器重启，文件系统会是一个什么状态？或者说，如果我们读取根目录下的文件 x，会发生什么，因为现在在根目录的 data block 已经有了文件 x 的记录？

是的，我们会读取一个未被分配的 inode，因为 inode 在 crash 之前还未被标记成被分配。更糟糕的是，如果 inode 之后被分配给一个不同的文件，这样会导致有两个应该完全不同的文件共享了同一个 inode。如果这两个文件分别属于用户 1 和用户 2，那么用户 1 就可以读到用户 2 的文件了。所以上面的解决方案也不好。

所以调整写磁盘的顺序并不能彻底解决我们的问题，我们只是从一个问题换到了一个新的问题。

让我们再看一个例子，这个例子中会向文件 x 写入“hi”（注，也就是 14.5 介绍的第二个部分）

![](<../assets/image (603).png>)

一旦成功的创建了文件 x，之后会调用 write 系统调用，我们在上节课看到了 write 系统调用也执行了多个写磁盘的操作。

- 首先会从 bitmap block，也就是 block 45 中，分配 data block，通过从 bitmap 中分配一个 bit，来表明一个 data block 已被分配。
- 上一步分配的 data block 是 block 595，这里将字符“h”写入到 block 595。
- 将字符“i”写入到 block 595。
- 最后更新文件夹 x 的 inode 来更新 size 字段。

这里我们也可以问自己一个问题，我们在下面的位置 crash 了会怎样？

![](<../assets/image (515).png>)

这里我们从 bitmap block 中分配了一个 data block，但是又还没有更新到文件 x 的 inode 中。当我们重启之后，磁盘处于一个特殊的状态，这里的风险是什么？是的，我们这里丢失了 data block，因为这个 data block 被分配了，但是却没有出现在任何文件中，因为它还没有被记录在任何 inode 中。

你或许会想，是因为这里的顺序不对才会导致丢失 data block 的问题。我们应该先写 block 33 来更新 inode 来包含 data block 595（同样的问题，这个时候 data block 都还没有分配怎么知道是 595），之后才通过写 block 45 将 data block 595 标记为已被分配。

![](<../assets/image (604).png>)

所以，为了避免丢失 data block，我们将写 block 的顺序改成这样。现在我们考虑一下，如果故障发生在这两个操作中间会怎样？

![](<../assets/image (619).png>)

这时 inode 会认为 data block 595 属于文件 x，但是在磁盘上它还被标记为未被分配的。之后如果另一个文件被创建了，block 595 可能会被另一个文件所使用。所以现在两个文件都会在自己的 inode 中记录 block 595。如果两个文件属于两个用户，那么两个用户就可以读写彼此的数据了。很明显，我们不想这样，文件系统应该确保每一个 data block 要么属于且只属于一个文件，要么是空闲的。所以这里的修改会导致磁盘 block 在多个文件之间共享的安全问题，这明显是错误的。

所以这里的问题并不在于操作的顺序，而在于我们这里有多个写磁盘的操作，这些操作必须作为一个原子操作出现在磁盘上。
