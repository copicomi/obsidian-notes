# 4.8 walk 函数

> 学生提问：我对于 walk 函数有个问题，从代码看它返回了最高级 page table 的 PTE，但是它是怎么工作的呢？（注，应该是学生理解有误，walk 函数模拟了 MMU，返回的是 va 对应的最低级 page table 的 PTE）

![](<../assets/image (213).png>)

> Frans 教授：这个函数会返回 page table 的 PTE，而内核可以读写 PTE。我来画个图，首先我们有一个 page directory，这个 page directory 有 512 个 PTE。最下面是 0，最上面是 511。

![](<../assets/image (313).png>)

> 这个函数的作用是返回某一个 PTE 的指针。

![](<../assets/image (296).png>)

> 这是个虚拟地址，它指向了这个 PTE。之后内核可以通过向这个地址写数据来操纵这条 PTE 执行的物理 page。当 page table 被加载到 SATP 寄存器，这里的更改就会生效。
>
> 从代码看，这个函数从 level2 走到 level1 然后到 level0，如果参数 alloc 不为 0，且某一个 level 的 page table 不存在，这个函数会创建一个临时的 page table，将内容初始化为 0，并继续运行。所以最后总是返回的是最低一级的 page directory 的 PTE。
>
> 如果参数 alloc 没有设置，那么在第一个 PTE 对应的下一级 page table 不存在时就会返回。
>
> 学生提问：对于 walk 函数，我有一个比较困惑的地方，在写完 SATP 寄存器之后，内核还能直接访问物理地址吗？在代码里面看起来像是通过 page table 将虚拟地址翻译成了物理地址，但是这个时候 SATP 已经被设置了，得到的物理地址不会被认为是虚拟地址吗？
>
> Frans 教授：让我们来看 kvminithart 函数，这里的 kernel_page_table 是一个物理地址，并写入到 SATP 寄存器中。从那以后，我们的代码运行在一个我们构建出来的地址空间中。在之前的 kvminit 函数中，kvmmap 会对每个地址或者每个 page 调用 walk 函数。所以你的问题是什么？
>
> 学生：我想知道，在 SATP 寄存器设置完之后，walk 是不是还是按照相同的方式工作？
>
> Frans：是的。它还能工作的原因是，内核设置了虚拟地址等于物理地址的映射关系，这里很重要，因为很多地方能工作的原因都是因为内核设置的地址映射关系是相同的。
>
> 学生：每一个进程的 SATP 寄存器存在哪？
>
> Frans：每个 CPU 核只有一个 SATP 寄存器，但是在每个 proc 结构体，如果你查看 proc.h，里面有一个指向 page table 的指针，这对应了进程的根 page table 物理内存地址。

![](<../assets/image (333).png>)

> 学生提问：为什么通过 3 级 page table 会比一个超大的 page table 更好呢？
>
> Frans 教授：这是个好问题，这的原因是，3 级 page table 中，大量的 PTE 都可以不存储。比如，对于最高级的 page table 里面，如果一个 PTE 为空，那么你就完全不用创建它对应的中间级和最底层 page table，以及里面的 PTE。所以，这就是像是在整个虚拟地址空间中的一大段地址完全不需要有映射一样。
>
> 学生：所以 3 级 page table 就像是按需分配这些映射块。
>
> Frans 教授：是的，就像前面（4.6）介绍的一样。最开始你只有 3 个 page table，一个是最高级，一个是中间级，一个是最低级的。随着代码的运行，我们会创建更多的 page table diretory。
