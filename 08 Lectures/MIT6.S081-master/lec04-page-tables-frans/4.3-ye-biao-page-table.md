# 4.3 页表（Page Table）

我们如何能够实现地址空间呢？或者说如何在一个物理内存上，创建不同的地址空间？

最常见的方法，同时也是非常灵活的一种方法就是使用页表（Page Tables）。页表是在硬件中通过处理器和内存管理单元（Memory Management Unit）实现。所以，在你们的脑海中，应该有这么一张图：CPU 正在执行指令，例如*sd $7, (a0)。*

![](<../assets/image (301).png>)

对于任何一条带有地址的指令，其中的地址应该认为是虚拟内存地址而不是物理地址。假设寄存器 a0 中是地址 0x1000，那么这是一个虚拟内存地址。虚拟内存地址会被转到内存管理单元（MMU，Memory Management Unit）

![](<../assets/image (241).png>)

内存管理单元会将虚拟地址翻译成物理地址。之后这个物理地址会被用来索引物理内存，并从物理内存加载，或者向物理内存存储数据。

![](<../assets/image (398).png>)

从 CPU 的角度来说，一旦 MMU 打开了，它执行的每条指令中的地址都是虚拟内存地址。

为了能够完成虚拟内存地址到物理内存地址的翻译，MMU 会有一个表单，表单中，一边是虚拟内存地址，另一边是物理内存地址。举个例子，虚拟内存地址 0x1000 对应了一个我随口说的物理内存地址 0xFFF0。这样的表单可以非常灵活。

![](<../assets/image (274).png>)

通常来说，内存地址对应关系的表单也保存在内存中。所以 CPU 中需要有一些寄存器用来存放表单在物理内存中的地址。现在，在内存的某个位置保存了地址关系表单，我们假设这个位置的物理内存地址是 0x10。那么在 RISC-V 上一个叫做 SATP 的寄存器会保存地址 0x10。

![](<../assets/image (355).png>)

这样，CPU 就可以告诉 MMU，可以从哪找到将虚拟内存地址翻译成物理内存地址的表单。

> 学生提问：所以 MMU 并不会保存 page table，它只会从内存中读取 page table，然后完成翻译，是吗？
>
> Frans 教授：是的，这就是你们应该记住的。page table 保存在内存中，MMU 只是会去查看 page table，我们接下来会看到，page table 比我们这里画的要稍微复杂一些。

这里的基本想法是每个应用程序都有自己独立的表单，并且这个表单定义了应用程序的地址空间。所以当操作系统将 CPU 从一个应用程序切换到另一个应用程序时，同时也需要切换 SATP 寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单。这样的话，cat 程序和 Shell 程序中相同的虚拟内存地址，就可以翻译到不同的物理内存地址，因为每个应用程序都有属于自己的不同的地址对应表单。这样说得通吗？

> 学生提问：刚刚说到 SATP 寄存器会根据进程而修改，我猜每个进程对应的 SATP 值是由内核保存的？
>
> Frans 教授：是的。内核会写 SATP 寄存器，写 SATP 寄存器是一条特殊权限指令。所以，用户应用程序不能通过更新这个寄存器来更换一个地址对应表单，否则的话就会破坏隔离性。所以，只有运行在 kernel mode 的代码可以更新这个寄存器。

前面都是最基本的介绍，我们在前面画的图还有做的解释都比较初级且存在明显不合理的地方。有一件事情我刚刚没有提到，这里的表单是如何工作的？从刚刚画的图看来，对于每个虚拟地址，在表单中都有一个条目，如果我们真的这么做，表单会有多大？原则上说，在 RISC-V 上会有多少地址，或者一个寄存器可以保存多少个地址？寄存器是 64bit 的，所以有多少个地址呢？是的，2^64 个地址，所以如果我们以地址为粒度来管理，表单会变得非常巨大。实际上，所有的内存都会被这里的表单耗尽，所以这一点也不合理。

所以，实际情况不可能是一个虚拟内存地址对应 page table 中的一个条目。接下来我将分两步介绍 RISC-V 中是如何工作的。

第一步：不要为每个地址创建一条表单条目，而是为每个 page 创建一条表单条目，所以每一次地址翻译都是针对一个 page。而 RISC-V 中，一个 page 是 4KB，也就是 4096Bytes。这个大小非常常见，几乎所有的处理器都使用 4KB 大小的 page 或者支持 4KB 大小的 page。

现在，内存地址的翻译方式略微的不同了。首先对于虚拟内存地址，我们将它划分为两个部分，index 和 offset，index 用来查找 page，offset 对应的是一个 page 中的哪个字节。

![](<../assets/image (183).png>)

当 MMU 在做地址翻译的时候，通过读取虚拟内存地址中的 index 可以知道物理内存中的 page 号，这个 page 号对应了物理内存中的 4096 个字节。之后虚拟内存地址中的 offset 指向了 page 中的 4096 个字节中的某一个，假设 offset 是 12，那么 page 中的第 12 个字节被使用了。将 offset 加上 page 的起始地址，就可以得到物理内存地址。

![](<../assets/image (224).png>)

有关 RISC-V 的一件有意思的事情是，虚拟内存地址都是 64bit，这也说的通，因为 RISC-V 的寄存器是 64bit 的。但是实际上，在我们使用的 RSIC-V 处理器上，并不是所有的 64bit 都被使用了，也就是说高 25bit 并没有被使用。这样的结果是限制了虚拟内存地址的数量，虚拟内存地址的数量现在只有 2^39 个，大概是 512GB。当然，如果必要的话，最新的处理器或许可以支持更大的地址空间，只需要将未使用的 25bit 拿出来做为虚拟内存地址的一部分即可。

在剩下的 39bit 中，有 27bit 被用来当做 index，12bit 被用来当做 offset。offset 必须是 12bit，因为对应了一个 page 的 4096 个字节。

![](<../assets/image (204).png>)

在 RISC-V 中，物理内存地址是 56bit。所以物理内存可以大于单个虚拟内存地址空间，但是也最多到 2^56。大多数主板还不支持 2^56 这么大的物理内存，但是原则上，如果你能造出这样的主板，那么最多可以支持 2^56 字节的物理内存。

物理内存地址是 56bit，其中 44bit 是物理 page 号（PPN，Physical Page Number），剩下 12bit 是 offset 完全继承自虚拟内存地址（也就是地址转换时，只需要将虚拟内存中的 27bit 翻译成物理内存中的 44bit 的 page 号，剩下的 12bitoffset 直接拷贝过来即可）。

![](<../assets/image (225).png>)

这里有什么问题吗？这些的内容还挺重要的，你们需要掌握这的内容才能做出下一个 page table lab。

> 学生提问：我想知道 4096 字节作为一个 page，这在物理内存中是连续的吗？
>
> Frans 教授：是的，在物理内存中，这是连续的 4096 个字节。所以物理内存是以 4096 为粒度使用的。
>
> 同一个学生：所以 offset 才是 12bit，这样就足够覆盖 4096 个字节？
>
> Frans 教授：是的，page 中的每个字节都可以被 offset 索引到。
>
> 同一个学生：图中的 56bit 又是根据什么确定的？
>
> Frans 教授：这是由硬件设计人员决定的。所以 RISC-V 的设计人员认为 56bit 的物理内存地址是个不错的选择。可以假定，他们是通过技术发展的趋势得到这里的数字。比如说，设计是为了满足 5 年的需求，可以预测物理内存在 5 年内不可能超过 2^56 这么大。或许，他们预测是的一个小得多的数字，但是为了防止预测错误，他们选择了像 2^56 这么大的数字。这里说的通吗？很多同学都问了这个问题。
>
> 学生提问：如果虚拟内存最多是 2^27（注，最多应该是 2^39），而物理内存最多是 2^56，这样我们可以有多个进程都用光了他们的虚拟内存，但是物理内存还有剩余，对吗？
>
> Frans 教授：是的，完全正确。
>
> 学生提问：因为这是一个 64bit 的机器，为什么硬件设计人员本可以用 64bit 但是却用了 56bit？
>
> Frans 教授：选择 56bit 而不是 64bit 是因为在主板上只需要 56 根线。
>
> 学生提问：我们从 CPU 到 MMU 之后到了内存，但是不同的进程之间的怎么区别？比如说 Shell 进程在地址 0x1000 存了一些数据，ls 进程也在地址 0x1000 也存了一些数据，我们需要怎么将它们翻译成不同的物理内存地址。
>
> Frans 教授：SATP 寄存器包含了需要使用的地址转换表的内存地址。所以 ls 有自己的地址转换表，cat 也有自己的地址转换表。每个进程都有完全属于自己的地址转换表。

通过前面的第一步，我们现在使得地址转换表是以 page 为粒度，而不是以单个内存地址为粒度，现在这个地址转换表已经可以被称为 page table 了。但是目前的设计还不能满足实际的需求。

如果每个进程都有自己的 page table，那么每个 page table 表会有多大呢？

![](<../assets/image (344).png>)

这个 page table 最多会有 2^27 个条目（虚拟内存地址中的 index 长度为 27），这是个非常大的数字。如果每个进程都使用这么大的 page table，进程需要为 page table 消耗大量的内存，并且很快物理内存就会耗尽。

所以实际上，硬件并不是按照这里的方式来存储 page table。从概念上来说，你可以认为 page table 是从 0 到 2^27，但是实际上并不是这样。实际中，page table 是一个多级的结构。下图是一个真正的 RISC-V page table 结构和硬件实现。

![](<../assets/image (254).png>)

我们之前提到的虚拟内存地址中的 27bit 的 index，实际上是由 3 个 9bit 的数字组成（L2，L1，L0）。前 9 个 bit 被用来索引最高级的 page directory（注：通常 page directory 是用来索引 page table 或者其他 page directory 物理地址的表单，但是在课程中，page table，page directory， page directory table 区分并不明显，可以都认为是有相同结构的地址对应表单）。

![](<../assets/image (309).png>)

一个 directory 是 4096Bytes，就跟 page 的大小是一样的。Directory 中的一个条目被称为 PTE（Page Table Entry）是 64bits，就像寄存器的大小一样，也就是 8Bytes。所以一个 Directory page 有 512 个条目。

![](<../assets/image (325).png>)

所以实际上，SATP 寄存器会指向最高一级的 page directory 的物理内存地址，之后我们用虚拟内存中 index 的高 9bit 用来索引最高一级的 page directory(注，2^9 = 512，正好可以索引到一条 PTE)，这样我们就能得到一个 PPN，也就是物理 page 号。这个 PPN 指向了中间级的 page directory。

当我们在使用中间级的 page directory 时，我们通过虚拟内存地址中的 L1 部分完成索引。接下来会走到最低级的 page directory，我们通过虚拟内存地址中的 L0 部分完成索引。在最低级的 page directory 中，我们可以得到对应于虚拟内存地址的物理内存地址。

![](<../assets/image (170).png>)

从某种程度上来说，与之前一种方案还是很相似的，除了实际的索引是由 3 步，而不是 1 步完成。这种方式的主要优点是，如果地址空间中大部分地址都没有使用，你不必为每一个 index 准备一个条目。举个例子，如果你的地址空间只使用了一个 page，4096Bytes。

![](<../assets/image (400).png>)

除此之外，你没有使用任何其他的地址。现在，你需要多少个 page table entry，或者 page table directory 来映射这一个 page？

在最高级，你需要一个 page directory。在这个 page directory 中，你需要一个数字是 0 的 PTE，指向中间级 page directory。所以在中间级，你也需要一个 page directory，里面也是一个数字 0 的 PTE，指向最低级 page directory。所以这里总共需要 3 个 page directory（也就是 3 \* 512 个条目）。

![](<../assets/image (383).png>)

而在前一个方案中，虽然我们只使用了一个 page，还是需要 2^27 个 PTE（注，约 1GB 内存）。这个方案中，我们只需要 3 \* 512 个 PTE（注，12KB 内存）。所需的空间大大减少了。这是实际上硬件采用这种层次化的 3 级 page directory 结构的主要原因。这里有什么问题吗？这部分还是很重要的。

> 学生提问：既然每个物理 page 的 PPN 是 44bit，而物理地址是 56bit，我们从哪得到缺失的 12bit？（注，这个学生嘟囔了半天，我猜他是要问这个。其实 12bit 直接从虚拟地址的 12bit offset 继承就可以了，但是可能这个问题太简单了，Frans 教授似乎理解错了问题。）
>
> Frans 教授：所有的 page directory 传递的都是 PPN，对应的物理地址是 44bit 的 PPN 加上 12bit 的 0（注，也就是 page 的起始地址，因为每个 page directory 都使用一个完整的 page，所以直接从 page 起始地址开始使用就行）。如果我们查看这里的 PTE 条目，它们都有相同的格式，其中 44bit 是 PPN，但是寄存器是 64bit 的，所有有一些 bit 是留空的。实际上，支持 page 的硬件在低 10bit 存了一些标志位用来控制地址权限。

![](<../assets/image (352).png>)

> 如果你把 44bit 的 PPN 和 10bit 的 Flags 相加是 54bit，也就是说还有 10bit 未被使用，这 10bit 被用来作为未来扩展。比如说某一天你有了一个新的 RISC-V 处理器，它的 page table 可能略有不同，或许有超过 44bit 的 PPN。如果你看下面这张图，你可以看到，这里有 10bit 是作为保留字段存在的。

![](<../assets/image (391).png>)

接下来，让我们看看 PTE 中的 Flag，因为它也很重要。每个 PTE 的低 10bit 是一堆标志位：

- 第一个标志位是 Valid。如果 Valid bit 位为 1，那么表明这是一条合法的 PTE，你可以用它来做地址翻译。对于刚刚举得那个小例子（注，应用程序只用了 1 个 page 的例子），我们只使用了 3 个 page directory，每个 page directory 中只有第 0 个 PTE 被使用了，所以只有第 0 个 PTE 的 Valid bit 位会被设置成 1，其他的 511 个 PTE 的 Valid bit 为 0。这个标志位告诉 MMU，你不能使用这条 PTE，因为这条 PTE 并不包含有用的信息。
- 下两个标志位分别是 Readable 和 Writable。表明你是否可以读/写这个 page。
- Executable 表明你可以从这个 page 执行指令。
- User 表明这个 page 可以被运行在用户空间的进程访问。
- 其他标志位并不是那么重要，他们偶尔会出现，前面 5 个是重要的标志位。

> 学生提问：我对于这里的 3 个 page table 有个问题。PPN 是如何合并成最终的物理内存地址？
>
> Frans 教授：我之前或许没有很直接的说这部分（其实是有介绍的）。在最高级的 page directory 中的 PPN，包含了下一级 page directory 的物理内存地址，依次类推。在最低级 page directory，我们还是可以得到 44bit 的 PPN，这里包含了我们实际上想要翻译的物理 page 地址，然后再加上虚拟内存地址的 12bit offset，就得到了 56bit 物理内存地址。
>
> Frans 教授：让我来问自己的一个有趣的问题，为什么是 PPN 存在这些 page directory 中？为什么不是一个虚拟内存地址？
>
> 某学生回答：因为我们需要在物理内存中查找下一个 page directory 的地址。
>
> Frans 教授：是的，我们不能让我们的地址翻译依赖于另一个翻译，否则我们可能会陷入递归的无限循环中。所以 page directory 必须存物理地址。那 SATP 呢？它存的是物理地址还是虚拟地址？
>
> 某学生回答：还是物理地址，因为最高级的 page directory 还是存在物理内存中，对吧。
>
> Frans 教授：是的，这里必须是物理地址，因为我们要用它来完成地址翻译，而不是对它进行地址翻译。所以 SATP 需要知道最高一级的 page directory 的物理地址是什么。
>
> 学生提问： 这里有层次化的 3 个 page table，每个 page table 都由虚拟地址的 9 个 bit 来索引，所以是由虚拟地址中的 3 个 9bit 来分别索引 3 个 page table，对吗？
>
> Frans 教授：是的，最高的 9 个 bit 用来索引最高一级的 page directory，第二个 9bit 用来索引中间级的 page directory，第三个 9bit 用来索引最低级的 page directory。
>
> 学生提问：当一个进程请求一个虚拟内存地址时，CPU 会查看 SATP 寄存器得到对应的最高一级 page table，这级 page table 会使用虚拟内存地址中 27bit index 的最高 9bit 来完成索引，如果索引的结果为空，MMU 会自动创建一个 page table 吗？
>
> Frans 教授：不会的，MMU 会告诉操作系统或者处理器，抱歉我不能翻译这个地址，最终这会变成一个 page fault。如果一个地址不能被翻译，那就不翻译。就像你在运算时除以 0 一样，处理器会拒绝那样做。
>
> 学生提问：我想知道我们是怎么计算 page table 的物理地址，是不是这样，我们从最高级的 page table 得到 44bit 的 PPN，然后再加上虚拟地址中的 12bit offset，就得到了完整的 56bit page table 物理地址？
>
> Frans 教授：我们不会加上虚拟地址中的 offset，这里只是使用了 12bit 的 0。所以我们用 44bit 的 PPN，再加上 12bit 的 0，这样就得到了下一级 page directory 的 56bit 物理地址。这里要求每个 page directory 都与物理 page 对齐（也就是 page directory 的起始地址就是某个 page 的起始地址，所以低 12bit 都为 0）。

这些都是很好的问题，你们在 page table 实验中都会遇到这些问题，现在问出来很好。
