# 4.6 kvminit 函数

接下来，让我们看一看代码，我认为很多东西都会因此变得更加清晰。

首先，我们来做一个的常规操作，启动我们的 XV6，这里 QEMU 实现了主板，同时我们打开 gdb。

![](<../assets/image (209).png>)

上一次我们看了 boot 的流程，我们跟到了 main 函数。main 函数中调用的一个函数是 kvminit（注，详见 3.9），这个函数会设置好 kernel 的地址空间。kvminit 的代码如下图所示：

![](<../assets/image (356).png>)

我们在前一部分看了 kernel 的地址空间长成什么样，这里我们来看一下代码是如何将它设置好的。首先在 kvminit 中设置一个断点，之后运行代码到断点位置。在 gdb 中执行 layout split，可以看到（从上面的代码也可以看出）函数的第一步是为最高一级 page directory 分配物理 page（注，调用 kalloc 就是分配物理 page）。下一行将这段内存初始化为 0。

![](<../assets/image (197).png>)

之后，通过 kvmmap 函数，将每一个 I/O 设备映射到内核。例如，下图中高亮的行将 UART0 映射到内核的地址空间。

![](<../assets/image (261).png>)

我们可以查看一个文件叫做 memlayout.h，它将 4.5 中的文档翻译成了一堆常量。在这个文件里面可以看到，UART0 对应了地址 0x10000000（注，4.5 中的文档是真正 SiFive RISC-V 的文档，而下图是 QEMU 的地址，所以 4.5 中的文档地址与这里的不符）。

![](<../assets/image (265).png>)

所以，通过 kvmmap 可以将物理地址映射到相同的虚拟地址（注，因为 kvmmap 的前两个参数一致）。

在 page table 实验中，第一个练习是实现 vmprint，这个函数会打印当前的 kernel page table。我们现在跳过这个函数，看一下执行完第一个 kvmmap 时的 kernel page table。

![](<../assets/image (328).png>)

我们来看一下这里的输出。第一行是最高一级 page directory 的地址，这就是存在 SATP 或者将会存在 SATP 中的地址。第二行可以看到最高一级 page directory 只有一条 PTE 序号为 0，它包含了中间级 page directory 的物理地址。第三行可以看到中间级的 page directory 只有一条 PTE 序号为 128，它指向了最低级 page directory 的物理地址。第四行可以看到最低级的 page directory 包含了 PTE 指向物理地址。你们可以看到最低一级 page directory 中 PTE 的物理地址就是 0x10000000，对应了 UART0。

前面是物理地址，我们可以从虚拟地址的角度来验证这里符合预期。我们将地址 0x10000000 向右移位 12bit，这样可以得到虚拟地址的高 27bit（index 部分）。之后我们再对这部分右移位 9bit，并打印成 10 进制数，可以得到 128，这就是中间级 page directory 中 PTE 的序号。这与之前（4.4）介绍的内容是符合的。

![](<../assets/image (353).png>)

从标志位来看（fl 部分），最低一级 page directory 中的 PTE 有读写标志位，并且 Valid 标志位也设置了（4.3 底部有标志位的介绍）。

内核会持续的按照这种方式，调用 kvmmap 来设置地址空间。之后会对 VIRTIO0、CLINT、PLIC、kernel text、kernel data、最后是 TRAMPOLINE 进行地址映射。最后我们还会调用 vmprint 打印完整的 kernel page directory，可以看出已经设置了很多 PTE。

![](<../assets/image (320).png>)

这里就不过细节了，但是这些 PTE 构成了我们在 4.5 中看到的地址空间对应关系。

（下面问答来自课程结束部分，因为内容相关就移到这里。）

> 学生：下面这两行内存不会越界吗？

![](<../assets/image (377).png>)

> Frans：不会。这里 KERNBASE 是 0x80000000，这是内存开始的地址。kvmmap 的第三个参数是 size，etext 是 kernel text 的最后一个地址，etext - KERNBASE 会返回 kernel text 的字节数，我不确定这块有多大，大概是 60-90 个 page，这部分是 kernel 的 text 部分。PHYSTOP 是物理内存的最大位置，PHYSTOP-text 是 kernel 的 data 部分。会有足够的 DRAM 来完成这里的映射。
