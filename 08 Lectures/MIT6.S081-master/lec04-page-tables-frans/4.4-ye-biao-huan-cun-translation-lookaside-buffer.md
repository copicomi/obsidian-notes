# 4.4 页表缓存（Translation Lookaside Buffer）

如果我们回想一下 page table 的结构，你可以发现，当处理器从内存加载或者存储数据时，基本上都要做 3 次内存查找，第一次在最高级的 page directory，第二次在中间级的 page directory，最后一次在最低级的 page directory。所以对于一个虚拟内存地址的寻址，需要读三次内存，这里代价有点高。所以实际中，几乎所有的处理器都会对于最近使用过的虚拟地址的翻译结果有缓存。这个缓存被称为：Translation Lookside Buffer（通常翻译成页表缓存）。你会经常看到它的缩写 TLB。基本上来说，这就是 Page Table Entry 的缓存，也就是 PTE 的缓存。

当处理器第一次查找一个虚拟地址时，硬件通过 3 级 page table 得到最终的 PPN，TLB 会保存虚拟地址到物理地址的映射关系。这样下一次当你访问同一个虚拟地址时，处理器可以查看 TLB，TLB 会直接返回物理地址，而不需要通过 page table 得到结果。

![](<../assets/image (402).png>)

> 学生提问：前面说 TLB 会保存虚拟地址到物理地址的对应关系，如果在 page 级别做 cache 是不是更加高效？
>
> Frans 教授：有很多种方法都可以实现 TLB，对于你们来说最重要的是知道 TLB 是存在的。TLB 实现的具体细节不是我们要深入讨论的内容。这是处理器中的一些逻辑，对于操作系统来说是不可见的，操作系统也不需要知道 TLB 是如何工作的。你们需要知道 TLB 存在的唯一原因是，如果你切换了 page table，操作系统需要告诉处理器当前正在切换 page table，处理器会清空 TLB。因为本质上来说，如果你切换了 page table，TLB 中的缓存将不再有用，它们需要被清空，否则地址翻译可能会出错。所以操作系统知道 TLB 是存在的，但只会时不时的告诉操作系统，现在的 TLB 不能用了，因为要切换 page table 了。在 RISC-V 中，清空 TLB 的指令是 sfence_vma。

![](<../assets/image (181).png>)

> 学生提问：3 级的 page table 是由操作系统实现的还是由硬件自己实现的？
>
> Frans 教授：这是由硬件实现的，所以 3 级 page table 的查找都发生在硬件中。MMU 是硬件的一部分而不是操作系统的一部分。在 XV6 中，有一个函数也实现了 page table 的查找，因为时不时的 XV6 也需要完成硬件的工作，所以 XV6 有这个叫做 walk 的函数，它在软件中实现了 MMU 硬件相同的功能。
>
> 学生提问：在这个机制中，TLB 发生在哪一步，是在地址翻译之前还是之后？
>
> Frans 教授：整个 CPU 和 MMU 都在处理器芯片中，所以在一个 RISC-V 芯片中，有多个 CPU 核，MMU 和 TLB 存在于每一个 CPU 核里面。RISC-V 处理器有 L1 cache，L2 Cache，有些 cache 是根据物理地址索引的，有些 cache 是根据虚拟地址索引的，由虚拟地址索引的 cache 位于 MMU 之前，由物理地址索引的 cache 位于 MMU 之后。
>
> 学生提问：之前提到，硬件会完成 3 级 page table 的查找，那为什么我们要在 XV6 中有一个 walk 函数来完成同样的工作？
>
> Frans 教授：非常好的问题。这里有几个原因，首先 XV6 中的 walk 函数设置了最初的 page table，它需要对 3 级 page table 进行编程所以它首先需要能模拟 3 级 page table。另一个原因或许你们已经在 syscall 实验中遇到了，在 XV6 中，内核有它自己的 page table，用户进程也有自己的 page table，用户进程指向 sys_info 结构体的指针存在于用户空间的 page table，但是内核需要将这个指针翻译成一个自己可以读写的物理地址。如果你查看 copy_in，copy_out，你可以发现内核会通过用户进程的 page table，将用户的虚拟地址翻译得到物理地址，这样内核可以读写相应的物理内存地址。这就是为什么在 XV6 中需要有 walk 函数的一些原因。
>
> 学生提问：为什么硬件不开发类似于 walk 函数的接口？这样我们就不用在 XV6 中用软件实现自己的接口，自己实现还容易有 bug。为什么没有一个特殊权限指令，接收虚拟内存地址，并返回物理内存地址？
>
> Frans 教授：其实这就跟你向一个虚拟内存地址写数据，硬件会自动帮你完成工作一样（工作是指翻译成物理地址，并完成数据写入）。你们在 page table 实验中会完成相同的工作。我们接下来在看 XV6 的实现的时候会看到更多的内容。

在我们介绍 XV6 之前，有关 page table 我还想说一点。用时髦的话说，page table 提供了一层抽象（[level of indirection](https://en.wikipedia.org/wiki/Indirection)）。我这里说的抽象就是指从虚拟地址到物理地址的映射。这里的映射关系完全由操作系统控制。

![](<../assets/image (184).png>)

因为操作系统对于这里的地址翻译有完全的控制，它可以实现各种各样的功能。比如，当一个 PTE 是无效的，硬件会返回一个 page fault，对于这个 page fault，操作系统可以更新 page table 并再次尝试指令。所以，通过操纵 page table，在运行时有各种各样可以做的事情。我们在之后有一节课专门会讲，当出现 page fault 的时候，操作系统可以做哪些有意思的事情。现在只需要记住，page table 是一个无比强大的机制，它为操作系统提供了非常大的灵活性。这就是为什么 page table 如此流行的一个原因。
