# 19.7 Dune: Safe User-level Access to Privileged CPU Features

今天要讨论的[论文](https://pdos.csail.mit.edu/6.828/2020/readings/belay-dune.pdf)利用了上一节介绍的硬件对于虚拟机的支持，但是却将其用作其他的用途，这是这篇论文的有趣之处，它利用了这种完全是为了虚拟机而设计的硬件，但是却用来做一些与虚拟机完全无关的事情。从一个全局的视角来看这篇论文的内容，它想要实现的是普通的进程。所以现在我们的场景是在一个 Linux 而不是 VMM 中，但是我们又用到了硬件中的 VT-x。我们将会在 Linux 中加载 Dune 可加载模块，所以 Dune 作为 kernel 的一部分运行在 Supervisor mode（注，又或者叫做 kernel mode），除此之外，内核的大部分还是原本的 Linux。

因为这里运行的是 Linux 进程，所以我们期望 Dune 可以支持进程，以及包括系统调用在内的各种 Linux 进程可以做的事情。不过现在我们想要使用 VT-x 硬件来使得普通的 Linux 进程可以做一些额外的事情。Dune 会运行一些进程，或者说允许一个进程切换到 Dune 模式，这意味着，之前的进程只是被 Page Table 保护和隔离，现在这个进程完全被 VT-x 机制隔离开了。现在进程有了一套完整的虚拟控制寄存器，例如 CR3 寄存器，并且这些进程可以运行在 non-root Supervisor mode，所以它可以在 VT-x 管理的虚拟状态信息上直接执行所有的 privileged 指令。

基于上面的描述，Dune 管理的进程可以通过属于自己的 CR3 寄存器，设置好属于自己的 Page Table。当然 Dune 也会控制属于这个进程的 EPT，EPT 会被设置的只包含这个进程相关的内存 Page。所以进程可以向 CR3 寄存器写入任意的 Page Table 地址，但是因为 MMU 会在翻译完正常的 Page Table 之后再将地址送到 EPT 去翻译，所以进程不能从分配给它的内存中逃逸。所以进程并不能修改其他进程或者 kernel 的内存，它只是有了一种更灵活的设置自己内存的方式。

![](<../assets/image (492).png>)

Dune 管理的进程也可以拥有 Guest Supervisor mode 和 Guest User mode，就像一个小的虚拟机一样，并且可以保护运行在 Supervisor mode 的代码，不受运行在 User mode 的代码影响。

![](<../assets/image (606).png>)

论文中提到了可以基于 Dune 做的两件事情：

首先，Dune 能够在硬件层面支持进程同时拥有 Guest Supervisor mode 和 Guest User mode，这样进程可以在自己的 User mode 中运行未被信任的插件代码。这里的主进程或许是一个网页浏览器，你可以为浏览器下载并运行各种各样的插件，或许是一个新的视频解码器，一个新的广告拦截插件等等。但是我们并不能完全信任这个插件，所以我们希望能够在权限受控的前提下运行它。虽然一个普通的 Linux 也可以达到这个目的，但是会比较麻烦。通过 Dune，我们可以在 Guest User mode 下运行插件，同时让网页浏览器运行在进程的 Guest Supervisor mode 下。因为现在可以修改 CR3 寄存器，所以可以为 Guest User mode 配置一个不同的 Page Table。这样，即使插件是恶意的，进程也可以安全的运行这里的未被信任的插件代码，因为插件代码现在不能任意的读写主浏览器的内存，只能访问网页浏览器指定的某些内存 Page。进程的 Guest User 代码可能会执行系统调用，但是这些系统调用会通过 trap 走到进程的 Guest Supervisor mode，而不是 Linux 内核，所以这里的插件代码或许会认为自己调用了 fork/read/write 等系统调用，但是实际上这里尝试运行的系统调用通过 trap 走到了进程对应的网页浏览器，而网页浏览器可以做任意的事情，它可以选择执行或者不执行系统调用。所以现在网页浏览器对于插件代码有了完全的控制能力。

公平的说，这里提到的隔离效果可以通过 Linux 中一些非常不一样的技术来实现，但是 Dune 通过使用 VT-x 硬件，为你可以提供一个特别优雅且有效的实现方式。

进程可以做的另一个事情是：通过 Dune，进程的垃圾回收（Garbage Collect，GC）变得更快了。在这个场景中，没有了 Guest Supervisor mode 和 Guest User mode。假设我们在运行任意一种带有 GC 的编程语言，比如说 Java 或者 Python。GC 可能会很慢，并且本身有着非常非常多的技术可以使得 GC 变快。许多 GC 都会扫描并找到位于内存中仍然在使用的对象，扫描会从寄存器中保存的对象指针开始，依次找到所有正在使用对象的所有指针。如果在扫描之后没能找到某个对象，那说明这个对象不被任何指针引用，那么它就可以被释放了。许多 GC 会同时在主程序的一个线程中运行，所以 GC 会从寄存器中保存的指针开始，根据指针之间的树或者图的关系，扫描一个个的对象。

![](<../assets/image (467).png>)

但是因为 GC 与程序本身是并行的在运行，所以程序可能会修改 GC 已经扫描过的对象，这很糟糕，因为这样的话，GC 在扫描完成之后确定的要释放和不能释放的对象清单可能就不再正确了。Dune 使用了 Page Table Entry 中的一个特性来帮助 GC 检测这样的修改。Dune 管理的进程首先会设置好由 VT-x 提供的虚拟 CR3 寄存器，指向属于自己的 Page Table，其中的 PTE 都是有效的。每一条 PTE 的 dirty 位，表明对于对应的 Page 存在写操作。所以如果程序在 GC 的过程中修改了某些对象，那么对应 PTE 的 dirty 位会被设置为 1。当 GC 查找完所有的对象之后，它会查看所有 PTE 中的 dirty 位，找到包含了可能修改过的对象的内存 Page，然后再重新扫描这些对象。

实际中，获取 PTE dirty 位的过程在普通的 Linux 中既困难又慢，我甚至都不确定 Linux 是否支持这个操作，在一些其他操作系统中你可以通过系统调用来查询 PTE 的 dirty 位。但是如果你使用 Dune 和\
VT-x，进程可以很快的使用普通的 load 和 store 指令获取 PTE，进而获取 dirty 位。所以这里，Dune 使得某些需要频繁触发 GC 的程序明显变得更快。

> 学生提问：如果 Guest User mode 中的插件程序想要运行自己的 GC 会怎样？
>
> Robert 教授：现在我们使用了 Dune，并且有一个进程是被 Dune 管理的。这个进程通过 VT-x 实现了 Supervisor mode 和 User mode，我们在 User mode 运行了一个插件，并且插件也是由带 GC 的编程语言写的，所以它有属于自己的 Page Table，并且其中的 PTE 也包含了 dirty 位。但是刚刚说的 GC 加速在这不能工作，因为 Dune 会将插件运行在 Guest User mode，而就像普通的 User mode 一样，Guest User mode 不允许使用 CR3 寄存器。所以在 Guest User mode，我们不能快速的访问 PTE 的 dirty 位。只有在 Guest Supervisor mode，才能通过 CR3 寄存器访问 Page Table。所以，并不能同时使用以上 Dune 提供的两种功能。

![](<../assets/image (598).png>)

> 学生提问：如果某人基于 Dune 写了个浏览器，那么对于不支持 Dune 的计算机来说就很难使用这样的浏览器，对吗？就像很难直接让 Chrome 使用 Dune，因为不是所有的计算机都有这个内核模块。
>
> Robert 教授：首先，这里提到的内容需要运行在支持 VT-x 的计算机上，也就是说底层的计算机必须支持 VT-x，所以需要 VT-x 来运行 Dune。其次 Dune 需要被加载来运行浏览器以利用前面说到的特性。所以是的，你需要将所有的东西都设置好。并且 Dune 是一个研究项目，它的目标是使得人们去思考可以部署在真实世界，并且有足够的价值的一些东西。就像 Linux 一样，Linux 有成千上万个功能，如果某人决定将 Dune 添加到 Linux 中作为一个标准功能，那么我们就可以依赖这个功能，并且 Chrome 也可以直接用它了。
>
> 学生提问：所以从整体来看，这里就像是创建了一个 VM，但是实际上运行的又是一个进程？
>
> Robert 教授：你可以这么描述。这里主要是对进程进行抽象，但是这里没有用 Page Table 硬件来时先进程间的隔离（注，其实也使用了，但是主要不依赖 Page Table 硬件），这里使用的是 CPU 上的硬件来支持进程，这里说的 CPU 上的硬件就是 VT-x，它包含了一些额外的功能，例如设置好属于进程的 Page Table。

> 学生提问：论文里提到了，如果 Dune 管理的一个进程 fork 了，那就会变成一个不被 Dune 管理的进程，这不会是一个安全漏洞吗？比如说你通过 Dune 运行了一个进程，并且认为它现在是安全的。但是 fork 之后的进程因为不被管理所以可能会逃逸。
>
> Robert 教授：Dune 管理的进程的 Guest Supervisor mode 中，不存在安全的问题。这部分代码已经拥有了相应的权限，通过 fork 也不会获得更多的权限。但是另一方面，Dune 的 Guest User mode 代码中，我们有未被信任的代码，如果让它在没有 Dune 管理的情况下运行会有一定的风险。所以这部分代码不能 fork，如果它尝试执行 fork 系统调用，会通过 trap 走到进程的 Guest Supervisor mode。

![](<../assets/image (626).png>)

> 假设进程的 Guest Supervisor mode 部分代码写的非常的小心，并且不会被欺骗，那么它不会执行 fork，所以这时 fork 不能工作。如果 Supervisor mode 的代码允许 fork，它会调用 Linux 的 fork 系统调用，并得到一个 fork 进程包含了与原进程有相同的内存镜像，所以我们在新进程中包含可能是恶意的插件代码。如果新进程没有意识到 Dune 已经被关闭了，那么原来的 Supervisor mode 中的 privileged 指令会是非法的。所以我们需要假设 Dune 管理的进程里面的 Supervisor mode 部分代码能够足够的小心且足够的聪明，来阻止 User mode 中的插件代码执行 fork。
>
> 学生：被 Dune 管理的进程拥有 Supervisor mode 并没有不安全，因为它实际上是 non-root mode 下的 Supervisor mode，就像是 Guest 操作系统中的 Supervisor mode 一样，你可以让它做任何事情，因为 VT-x 的存在，进程就像是一个虚拟机一样，并不能伤害到真正的操作系统。
>
> Robert 教授：是的，进程不能逃逸出来，因为存在 EPT，而 EPT 会限制进程的地址空间。
>
> 学生提问：在 VT-x 的方案中，当我们访问 Page Table 时，因为我们需要通过 EPT 进行第二层翻译，将 Guest 物理内存地址翻译到 Host 物理内存地址，这样从 Page Table 返回的延时是不是增加了？
>
> Robert 教授：这里可能会花费更多的时间让硬件 MMU 来翻译内存地址。在最坏的情况下，比如在 RISC-V 中，会有多层 Page Table，MMU 需要一层一层的去查找 PTE，x86 下同样也有多层 Page Table，所以在 x86 中首先会查找主 Page Table，如果要访问更多的内存地址，每一次内存地址的访问都需要再次走到 EPT，而 EPT 也是一个多层的 Page Table。所以我并不知道最差情况下需要访问 Page Table 多少次才能完成翻译，但是很明显在 VT-x 下会比普通情况下差得多。不过实际中会有 cache 所以通常不会走到最坏的情况。

> 学生提问：今天的虚拟机还是普遍会更慢吗？如果是的话，AWS 是怎么工作的，因为看起来还挺快的，并且工作的也很好。
>
> Robert 教授：我认为他们使用了硬件上的 VT-x 支持，并且使用了我们讨论过的一些功能，这样使得 AWS 虚拟机比较快，或者并不比真实的计算机慢多少。
>
> 学生提问：我对于 Trap and Emulate 中的 Shadow Page Table 有个问题，每次都会创建 Shadow Page Table 吗？难道不能记住上次的 Shadow Page Table 吗？
>
> Robert 教授：VMM 需要创建新的 Shadow Page Table 以供真实的硬件使用。当然在很多时候都可以增加缓存，对于一个聪明的 VMM，它可以注意到 Guest 更新了一个 PTE，VMM 可以做相应的有限的工作来更新 Shadow Page Table。如果机器是在多个虚拟机上分时复用的，VMM 会为还在运行的虚拟机保存 Shadow Page Table，这样这些虚拟机可以在恢复时直接重用。
>
> 学生提问：这难道不是意味着 VMM 为每个虚拟机中的每个进程都保存了 Shadow Page Table 的拷贝？
>
> Robert 教授：是的，虚拟机里面有很多很多个 Page Table，所以维护 Shadow Page Table 需要大量的工作。而类似于 VT-x 的硬件支持使得这部分工作更加的容易了，因为 EPT 表示你不用构建 Shadow Page Table 了。
>
> 学生提问：我有个问题有关 GC 的，如果有 dirty 位的话需要重新扫描对象，那么有没有可能会无限扫描？
>
> Robert 教授：是的，这有个问题，如果一直有对象在更新，扫描能正常结束吗？实际中，GC 会先扫描一次，之后它会冻结除了 GC 线程以外的其他线程，所以这期间不可能再发生任何其他的变更。之后 GC 才会查看所有 PTE 的 dirty 位，但是因为其他所有线程都冻结了，所以不可能会有更多的 dirty 位了，所以 GC 查看了所有的 dirty 位，之后结束 GC 会结束扫描并创建需要释放对象的列表，最后再恢复所有之前冻结的线程的执行。GC 是一个复杂的流程，Dune 的论文中并没有足够的篇幅讨论它。
