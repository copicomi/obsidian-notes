# 19.4 Trap-and-Emulate --- Page Table

有关 Trap and Emulate 的实现还有两个重要的部分，一个是 Page Table，另一个是外部设备。

Page Table 包含了两个部分，第一个部分是 Guest 操作系统在很多时候会修改 SATP 寄存器（注，SATP 寄存器是物理内存中包含了 Page Table 的地址，详见 4.3），当然这会变成一个 trap 走到 VMM，之后 VMM 可以接管。但是我们不想让 VMM 只是简单的替 Guest 设置真实的 SATP 寄存器，因为这样的话 Guest 就可以访问任意的内存地址，而不只是 VMM 分配给它的内存地址，所以我们不能让 Guest 操作系统简单的设置 SATP 寄存器。

但是我们的确又需要为 SATP 寄存器做点什么，因为我们需要让 Guest 操作系统觉得 Page Table 被更新了。此外，当 Guest 上的软件运行了 load 或者 store 指令时，或者获取程序指令来执行时，我们需要数据或者指令来自于内存的正确位置，也就是 Guest 操作系统认为其 PTE 指向的内存位置。所以当 Guest 设置 SATP 寄存器时，真实的过程是，我们不能直接使用 Guest 操作系统的 Page Table，VMM 会生成一个新的 Page Table 来模拟 Guest 操作系统想要的 Page Table。

所以现在的 Page Table 翻译过程略微有点不一样，首先是 Guest kernel 包含了 Page Table，但是这里是将 Guest 中的虚拟内存地址（注，下图中 gva）映射到了 Guest 的物理内存地址（注，下图中 gpa）。Guest 物理地址是 VMM 分配给 Guest 的地址空间，例如 32GB。并且 VMM 会告诉 Guest 这段内存地址从 0 开始，并一直上涨到 32GB。但是在真实硬件上，这部分内存并不是连续的。所以我们不能直接使用 Guest 物理地址，因为它们不对应真实的物理内存地址。

相应的，VMM 会为每个虚拟机维护一个映射表，将 Guest 物理内存地址映射到真实的物理内存地址，我们称之为主机物理内存地址（注，下图中的 hpa）。这个映射表与 Page Table 类似，对于每个 VMM 分配给 Guest 的 Guest 物理内存 Page，都有一条记录表明真实的物理内存 Page 是什么。

![](<../assets/image (432).png>)

当 Guest 向 SATP 寄存器写了一个新的 Page Table 时，在对应的 trap handler 中，VMM 会创建一个 Shadow Page Table，Shadow Page Table 的地址将会是 VMM 向真实 SATP 寄存器写入的值。Shadow Page Table 由上面两个 Page Table 组合而成，所以它将 gva 映射到了 hpa。Shadow Page Table 是这么构建的：

- 从 Guest Page Table 中取出每一条记录，查看 gpa。
- 使用 VMM 中的映射关系，将 gpa 翻译成 hpa。
- 再将 gva 和 hpa 存放于 Shadow Page Table。

在创建完之后，VMM 会将 Shadow Page Table 设置到真实的 SATP 寄存器中，再返回到 Guest 内核中（注，这样的效果是，Guest 里面看到的 Page Table 就是一个正常的 Page Table，而 Guest 通过 SATP 寄存器指向的 Page Table，将虚拟内存地址翻译得到的又是真实的物理内存地址）。

![](<../assets/image (577).png>)

所以，Guest kernel 认为自己使用的是一个正常的 Page Table，但是实际的硬件使用的是 Shadow Page Table。这种方式可以阻止 Guest 从被允许使用的内存中逃逸。Shadow Page Table 只能包含 VMM 分配给虚拟机的主机物理内存地址。Guest 不能向 Page Table 写入任何 VMM 未分配给 Guest 的内存地址。这是 VMM 实现隔离的一个关键部分。

> 学生提问：如果 Guest 操作系统想要为一个进程创建一个新的 Page Table，会发生什么呢？
>
> Robert 教授：Guest 会完全按照 Linux 或者 XV6 的行为来执行。首先是格式化 Page Table Entries 以构造一个 Page Table。之后执行指令将 Page Table 的地址写入到 SATP 寄存器，这就是 Guest 操作系统的行为。但是它又不能设置实际的 SATP 寄存器，因为这是一个 privileged 操作，所以设置 SATP 寄存器会触发 trap 并走到 VMM。VMM 会查看 trap 对应的指令，并发现 Guest 要尝试设置 SATP 寄存器，之后 VMM 会创建一个新的 Shadow Page Table。VMM 会查看 Guest 尝试要设置的 Page Table 的每一条记录，通过 gpa->hpa 的映射关系，将 gva 和 hpa 的对应关系翻译出来。如果 Guest 尝试使用一个不被允许的物理地址，VMM 会生成一个真实的 Page Fault。之后 VMM 会将 Shadow Page Table 设置到真实的 SATP 寄存器中，并返回到 Guest 中。

Shadow Page Table 是实现 VMM 时一个比较麻烦的地方。除了设置 SATP 寄存器，Guest 操作系统还有另一种方式可以与 Page Table 进行交互。XV6 有时候会直接修改属于自己的 Page Table Entry，或者读取 PTE 中的 dirty bit。如果你读了 RISC-V 的文档，你可以发现在 RISC-V 上，如果软件更改了 PTE，RISC-V 不会做任何事情。如果你修改了 PTE，RISC-V 并不承诺可以立即观察到对于 PTE 的修改，在修改那一瞬间，你完全是不知道 PTE 被修改了（注，这里主要对比的是 privileged 指令，因为如果在用户空间执行了 privileged 指令，会立刻触发 trap，而这里修改 PTE 不会有任何的额外的动作）。相应的，文档是这么说的，如果你修改 PTE 并且希望 MMU 可以看到这个改动，你需要执行 sfence.vma 指令，这个指令会使得硬件注意到你对 Page Table 的修改。所以如果你要自己写一个 VMM，你在 RISC-V 上的 VMM 会完全忽略 Guest 对于 PTE 的修改，但是你知道 Guest 在修改完 PTE 之后将会执行 sfence.vma 指令，并且这是一个 privileged 指令，因为它以 s 开头，所以这条指令会通过 trap 走到 VMM，VMM 就可以知道 sfence.vma 指令被执行了。之后 VMM 会重新扫描 Guest 的当前 Page Table，查找更新了的 Page Table Entry。如果修改合法的话，VMM 会将修改体现在 Shadow Page Table 中，并执行真实的 sfence.vma 指令来使得真实的硬件注意到 Shadow Page Table 的改动。最后再会返回到 Guest 操作系统中。

> 学生提问：所以 MMU 只使用了一个 Page Table，也就是 Shadow Page Table，对吧？这里并没有使用 EPT（Extended Page Table），对吧？
>
> Robert 教授：这里还没有 EPT。
>
> 学生提问：所以 Guest 认为它自己有一个 Page Table，也就是 gva->gpa，但是这里并没有做任何的翻译工作。VMM 通过两个映射关系构建了属于自己的 Page Table。
>
> Robert 教授：是的。这里澄清一下，EPT 是一种非常不一样的虚拟机实现方式，并且需要硬件的支持。我们这里假设除了对 privileged 指令触发 trap 以外，不需要使用任何特殊的硬件支持来构建一个虚拟机。
>
> 学生提问：这里会弄乱 direct mapping 吗？
>
> Robert 教授：这里不会有 direct map。Guest 会认为自己有一个 direct mapping，但这只是在虚拟的世界里的一个 direct mapping，在真实的机器上这不是 direct mapping。但是这没有关系，因为我们这里欺骗了 Guest 使得看起来像是 direct mapping。
>
> 学生提问：我们刚刚说过性能的损耗，如果我们使用 VMM，对于这里的 trap 机制看起来也会有大量的性能损耗。
>
> Robert 教授：是的。如果你的操作系统执行了大量的 privileged 指令，那么你也会有大量的 trap，这会对性能有大的损耗。这里的损耗是现代硬件增加对虚拟机支持的动机。今天要讨论的论文使用的就是现在硬件对于虚拟机的支持，Intel 和 AMD 在硬件上支持更加有效的 trap，或者说对于虚拟机方案，会有少得多的 trap。所以是的，性能很重要。但是上面介绍的方案，人们也使用了很多年，它能工作并且也很成功，尽管它会慢的多，但是还没有慢到让人们讨厌的程度，人们其实很喜欢这个方案。
