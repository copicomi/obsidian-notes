# 19.2 Trap-and-Emulate --- Trap

我们该如何构建我们自己的 VMM 呢？一种实现方式是完全通过软件来实现，你可以想象写一个类似 QEMU 的软件，这个软件读取包含了 XV6 内核指令的文件，查看每一条指令并模拟 RISC-V 的状态，这里的状态包括了通过软件模拟 32 个寄存器。你的软件读取每条指令，确定指令类型，再将指令应用到通过软件模拟的 32 个寄存器和控制寄存器中。实际中有的方案就是这么做的，虽然说考虑到细节还需要做很多工作，但是这种方案从概念上来说很简单直观。

但是纯软件解析的虚拟机方案应用的并不广泛，因为它们很慢。如果你按照这种方式实现虚拟机，那么 Guest 应用程序的运行速度将远低于运行在硬件上，因为你的 VMM 在解析每一条 Guest 指令的时候，都可能要转换成几十条实际的机器指令，所以这个方案中的 Guest 的运行速度比一个真实的计算机要慢几个数量级。在云计算中，这种实现方式非常不实用。所以人们并不会通过软件解析来在生产环境中构建虚拟机。

相应的，一种广泛使用的策略是在真实的 CPU 上运行 Guest 指令。所以如果我们要在 VMM 之上运行 XV6，我们需要先将 XV6 的指令加载到内存中，之后再跳转到 XV6 的第一条指令，这样你的计算机硬件就能直接运行 XV6 的指令。当然，这要求你的计算机拥有 XV6 期望的处理器（注，也就是 RISC-V）。

但是实际中你又不能直接这么做，因为当你的 Guest 操作系统执行了一个 privileged 指令（注，也就是在普通操作系统中只能在 kernel mode 中执行的指令，详见 3.4）之后，就会出现问题。现在我们在虚拟机里面运行了操作系统内核，而内核会执行需要 privileged 权限指令，比如说加载一个新的 Page Table 到 RISC-V 的 SATP 寄存器中，而这时就会出现问题。

前面说过，我们将 Guest kernel 按照一个 Linux 中的普通用户进程来运行，所以 Guest kernel 现在运行在 User mode，而在 User mode 加载 SATP 寄存器是个非法的操作，这会导致我们的程序（注，也就是虚拟机）crash。但是如果我们蠢到将 Guest kernel 运行在宿主机的 Supervisor mode（注，也就是 kernel mode），那么我们的 Guest kernel 不仅能够修改真实的 Page Table，同时也可以从虚拟机中逃逸，因为它现在可以控制 PTE（Page Table Entry）的内容，并且读写任意的内存内容。所以我们不能直接简单的在真实的 CPU 上运行 Guest kernel。

相应的，这里会使用一些技巧。

首先将 Guest kernel 运行在宿主机的 User mode，这是最基本的策略。这意味着，当我们自己写了一个 VMM，然后通过 VMM 启动了一个 XV6 系统，VMM 会将 XV6 的 kernel 指令加载到内存的某处，再设置好合适的 Page Table 使得 XV6 看起来自己的内存是从地址 0 开始向高地址走。之后 VMM 会使用 trap 或者 sret 指令（注，详见 6.8）来跳转到位于 User mode 的 Guest 操作系统的第一条指令，这样不论拥有多少条指令，Guest 操作系统就可以一直执行下去。

![](<../assets/image (575).png>)

一旦 Guest 操作系统需要使用 privileged 指令，因为它当前运行在 User mode 而不是 Supervisor mode，会使得它触发 trap 并走回到我们的 VMM 中（注，在一个正常操作系统中，如果在 User mode 执行 privileged 指令，会通过 trap 走到内核，但是现在 VMM 替代了内核），之后我们就可以获得控制权。所以当 Guest 操作系统尝试修改 SATP 寄存器，RISC-V 处理器会通过 trap 走回到我们的 VMM 中，之后我们的 VMM 就可以获得控制权。并且我们的 VMM 也可以查看是什么指令引起的 trap，并做适当的处理。这里核心的点在于 Guest 操作系统并没有实际的设置 SATP 寄存器。

![](<../assets/image (727) (1).png>)

> 学生提问：VMM 改如何截获 Guest 操作系统的指令？它应该要设置好一个 trap handler 对吧，但这不是一个拥有 privileged 权限的进程才能做的事情吗？而 VMM 又是个宿主机上的用户程序，是吧？
>
> Robert 教授：我这里假设 VMM 运行在 Supervisor mode。所以在这里的图中，VMM 就是宿主机的 kernel。这里我们不是启动类似 Linux 的操作系统，而是启动 VMM（注，类似 VMware 的 ESXi）。VMM 以 privileged 权限运行，并拥有硬件的完整控制权限，这样我们就可以在 VMM 里面设置各种硬件寄存器。有一些 VMM 就是这么运行的，你在硬件上启动它们，并且只有 VMM 运行在 Supervisor mode。实际上还有很多很多其他的虚拟机方案，比如说在硬件上启动 Linux，之后要么 Linux 自带一个 VMM，要么通过可加载的内核模块将 VMM 加载至 Linux 内核中，这样 VMM 可以在 Linux 内核中以 Supervisor mode 运行。今天我们要讨论的论文就是采用后者。
>
> 这里主要的点在于，我们自己写的可信赖的 VMM 运行在 Supervisor mode，而我们将不可信赖的 Guest kernel 运行在 User mode，通过一系列的处理使得 Guest kernel 看起来好像自己是运行在 Supervisor mode。

在 RISC-V 上，如果在 User mode 尝试运行任何一个需要 Supervisor 权限的指令都会触发 trap。这里需要 Supervisor 权限的指令并不包括与 Page Table 相关的指令，我们稍后会介绍相关的内容。所以每当 Guest 操作系统尝试执行类似于读取 SCAUSE 寄存器，读写 STVEC 寄存器，都会触发一个 trap，并走到 VMM，之后我们就可以获得控制权。
