# 19.5 Trap-and-Emulate --- Devices

接下来我们来看 Trap and Emulate 的最后一个部分，也就是虚拟机的外部设备。外部设备是指，一个普通的操作系统期望能有一个磁盘用来存储文件系统，或者是期望有一个网卡，甚至对于 XV6 来说期望有一个 UART 设备来与 console 交互，或者期望有一张声卡，一个显卡，键盘鼠标等等各种各样的东西。所以我们我们的虚拟机方案，需要能够至少使得 Guest 认为所有它需要的外部设备是存在的。

这里人们通常会使用三种策略。

第一种是，模拟一些需要用到的并且使用非常广泛的设备，例如磁盘。也就是说，Guest 并不是拥有一个真正的磁盘设备，只是 VMM 使得与 Guest 交互的磁盘看起来好像真的存在一样。这里的实现方式是，Guest 操作系统仍然会像与真实硬件设备交互一样，通过 Memory Map 控制寄存器与设备进行交互。通常来说，操作系统会假设硬件已经将自己的控制寄存器映射到了内核地址空间的某个地址上。在 VMM 中不会映射这些内存地址对应的 Page，相应的会将这些 Page 设置成无效。这样当 Guest 操作系统尝试使用 UART 或者其他硬件时，一访问这些地址就会通过 trap 走到 VMM。VMM 查看指令并发现 Guest 正在尝试在 UART 发送字符或者从磁盘中读取数据。VMM 中会对磁盘或者串口设备有一些模拟，通过这些模拟，VMM 知道如何响应 Guest 的指令，之后再恢复 Guest 的执行。这就是我们之前基于 QEMU 介绍 XV6 时，QEMU 实现 UART 的方式。在之前的介绍中，并没有 UART 硬件的存在，但是 QEMU 模拟了一个 UART 来使得 XV6 正常工作。这是一种常见的实现方式，但是这种方式可能会非常的低效，因为每一次 Guest 与外设硬件的交互，都会触发一个 trap。但是对于一些低速场景，这种方式工作的较好。如果你的目标就是能启动操作系统并使得它们完全不知道自己运行在虚拟机上，你只能使用这种策略。

![](<../assets/image (489).png>)

在现代的世界中，操作系统在最底层是知道自己运行在虚拟机之上的。所以第二种策略是提供虚拟设备，而不是模拟一个真实的设备。通过在 VMM 中构建特殊的设备接口，可以使得 Guest 中的设备驱动与 VMM 内支持的设备进行高效交互。现在的 Guest 设备驱动中可能没有 Memory Mapped 寄存器了，但是相应的在内存中会有一个命令队列，Guest 操作系统将读写设备的命令写到队列中。在 XV6 中也使用了一个这种方式的设备驱动，在 XV6 的 virtio_disk.c 文件中，你可以看到一个设备驱动尝试与 QEMU 实现的虚拟磁盘设备交互。在这个驱动里面要么只使用了很少的，要么没有使用 Memory Mapped 寄存器，所以它基本不依赖 trap，相应的它在内存中格式化了一个命令队列。之后 QEMU 会从内存中读取这些命令，但是并不会将它们应用到磁盘中，而是将它们应用到一个文件，对于 XV6 来说就是 fs.image。这种方式比直接模拟硬件设备性能要更高，因为你可以在 VMM 中设计设备接口使得并不需要太多的 trap。

![](<../assets/image (550).png>)

第三个策略是对于真实设备的 pass-through，这里典型的例子就是网卡。现代的网卡具备硬件的支持，可以与 VMM 运行的多个 Guest 操作系统交互。你可以配置你的网卡，使得它表现的就像多个独立的子网卡，每个 Guest 操作系统拥有其中一个子网卡。经过 VMM 的配置，Guest 操作系统可以直接与它在网卡上那一部分子网卡进行交互，并且效率非常的高。所以这是现代的高性能方法。在这种方式中，Guest 操作系统驱动可以知道它们正在与这种特别的网卡交互。

![](<../assets/image (552).png>)

以上就是实现外部设备的各种策略。我认为在实现一个 VMM 时，主要的困难就在于构建外部设备和设备驱动，并使得它们能正确的与 Guest 操作系统配合工作。这里或许是实现 VMM 的主要工作，尤其是当你使用第一种策略时。

> 学生提问：我并没有太理解策略一 emulation 和策略二 virtual device 的区别。
>
> Robert 教授：它们是类似的。可以这么想，如果你启动了一个完全不知道虚拟机的操作系统，它或许包含了很多磁盘驱动，但是所有的驱动都是为真实硬件提供的。如果你想要在虚拟机中启动这样一个操作系统，你需要选择其中一种真实的硬件，并且以一种非常准确的方式来模拟该硬件。这种方式并没有问题，只是大部分情况下硬件接口并没有考虑 Trap and Emulate VMM 下的性能。所以真实的设备驱动需要你频繁的读写它的控制寄存器，而 VMM 需要为每一次写控制寄存器都获取控制权，因为它需要模拟真实的硬件。这意味着每一次写控制寄存器都会触发一次 trap 走到 VMM，并消耗数百个 CPU cycles。所以策略一非常的慢且低效。
>
> 策略二并没有卑微地模仿真实的设备，某些设计人员提出了一种设备驱动，这种设备驱动并不对接任何真实的硬件设备，而是只对接由 VMM 实现的虚拟设备。这种驱动设计的并不需要很多 trap，并且这种驱动与对应的虚拟设备是解耦的，并不需要立即的交互。
>
> 从功能层面上来说，使用策略一的话，你可以启动任何操作系统，使用策略二的话，如果你想要使用虚拟设备，你只能启动知道虚拟设备的操作系统。实际中，策略二是一种标准，并且很多虚拟机的实现方案都能提供。虽然我们并没有在除了 QEMU 以外的其他场景测试过，XV6 中的 virtio_disk.c 稍作修改或许也可以在其他虚拟机方案上运行。
>
> 学生提问：所以对于每一种主板，取决于不同的磁盘，编译 XV6 都需要不同的磁盘驱动，是吗？
>
> Robert 教授：是的。我认为或许你可以买到支持 virtio_disk 驱动的真实硬件，但是大部分的磁盘硬件还不支持这个驱动，这时你需要为真实的硬件实现一种新的驱动。
