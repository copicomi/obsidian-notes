# 19.6 硬件对虚拟机的支持

接下来我将讨论硬件对于虚拟机的支持，这里特指的就是 Intel 的 VT-x。为什么 Intel 和其他的硬件厂商会为虚拟机提供直接的硬件支持呢？

- 首先虚拟机应用的非常广泛，硬件厂商的大量客户都在使用虚拟机
- 其次，我们刚刚描述的 Trap and Emulate 虚拟机方案中，经常会涉及到大量高成本的 trap，所以这种方案性能并不特别好。
- 第三个原因或许就没那么有趣了。RISC-V 非常适合 Trap and Emulate 虚拟机方案，但是 Intel 的 x86 处理器的一些具体实现使得它可以支持虚拟化，但是又没那么容易。所以 Intel 也有动力来修复这里的问题，因为它的很多客户想要在 x86 上运行 VMM。

![](<../assets/image (478).png>)

这里硬件上的支持，是为了让人们能够更容易地构建运行更快的虚拟机。它已经存在了 10 年左右了，并且现在在构建虚拟机时使用的非常非常广泛。在 Trap and Emulate 方案中，VMM 会为每个 Guest 在软件中保存一份虚拟状态信息，而现在，这些虚拟状态信息会保存在硬件中。这样 Guest 中的软件可以直接执行 privileged 指令来修改保存在硬件中的虚拟寄存器，而不是通过 trap 走到 VMM 来修改 VMM 中保存在软件中的虚拟寄存器。所以这里的目标是 Guest 可以在不触发 trap 的前提下，执行 privileged 指令。

我们还是有一个 VMM 在内核空间，并且 Guest 运行在用户空间。当我们使用这种新的硬件支持的方案时，我们的 VMM 会使用真实的控制寄存器，而当 VMM 通知硬件切换到 Guest mode 时，硬件里还会有一套完全独立，专门为 Guest mode 下使用的虚拟控制寄存器。在 Guest mode 下可以直接读写控制寄存器，但是读写的是寄存器保存在硬件中的拷贝，而不是真实的寄存器。

![](<../assets/image (98).png>)

硬件会对 Guest 操作系统的行为做一些额外的操作，以确保 Guest 不会滥用这些寄存器并从虚拟机中逃逸。在这种硬件支持的虚拟机方案中，存在一些技术术语，至少 Intel 是这么叫的，Guest mode 被称为 non-root mode，Host mode 中会使用真实的寄存器，被称为 root mode。所以，硬件中保存的寄存器的拷贝，或者叫做虚拟寄存器是为了在 non-root mode 下使用，真实寄存器是为了在 root mode 下使用。

![](<../assets/image (460).png>)

现在，当我们运行在 Guest kernel 时，可以在不触发任何 trap 的前提下执行任何 privileged 指令。比如说如果想读写 STVEC 寄存器，硬件允许我们直接读写 STVEC 寄存器的 non-root 拷贝。这样，privileged 指令可以全速运行，而不用通过 trap 走到 VMM。这对于需要触发大量 trap 的代码，可以运行的快得多。

现在当 VMM 想要创建一个新的虚拟机时，VMM 需要配置硬件。在 VMM 的内存中，通过一个结构体与 VT-x 硬件进行交互。这个结构体称为 VMCS（注，Intel 的术语，全称是 Virtual Machine Control Structure）。当 VMM 要创建一个新的虚拟机时，它会先在内存中创建这样一个结构体，并填入一些配置信息和所有寄存器的初始值，之后 VMM 会告诉 VT-x 硬件说我想要运行一个新的虚拟机，并且虚拟机的初始状态存在于 VMCS 中。Intel 通过一些新增的指令来实现这里的交互。

- VMLAUNCH，这条指令会创建一个新的虚拟机。你可以将一个 VMCS 结构体的地址作为参数传给这条指令，再开始运行 Guest kernel。
- VMRESUME。在某些时候，Guest kernel 会通过 trap 走到 VMM，然后需要 VMM 中需要通过执行 VMRESUME 指令恢复代码运行至 Guest kernel。
- VMCALL，这条新指令在 non-root 模式下使用，它会使得代码从 non-root mode 中退出，并通过 trap 走到 VMM。

![](<../assets/image (455).png>)

通过硬件的支持，Guest 现在可以在不触发 trap 的前提下，直接执行普通的 privileged 指令。但是还是有一些原因需要让代码执行从 Guest 进入到 VMM 中，其中一个原因是调用 VMCALL 指令，另一个原因是设备中断，例如定时器中断会使得代码执行从 non-root 模式通过 trap 走到 VMM。所以通常情况下设备驱动还是会使得 Guest 通过 trap 走回到 VMM。这表示着 Guest 操作系统不能持续占有 CPU，每一次触发定时器中断，VMM 都会获取控制权。如果有多个 Guest 同时运行，它们可以通过定时器中断来分时共享 CPU（注，类似于线程通过定时器中断分时共享 CPU 一样）。

VT-x 机制中的另外一大部分是对于 Page Table 的支持。当我们在 Guest 中运行操作系统时，我们仍然需要使用 Page Table。首先 Guest kernel 还是需要属于自己的 Page Table，并且会想要能够加载 CR3 寄存器，这是 Intel 中类似于 SATP 的寄存器。VT-x 使得 Guest 可以加载任何想要的值到 CR3 寄存器，进而设置 Page Table。而硬件也会执行 Guest 的这些指令，这很好，因为现在 Guest kernel 可以在不用通过 trap 走到 VMM 再来加载 Page Table。

![](<../assets/image (446).png>)

但是我们也不能让 Guest 任意的修改它的 Page Table，因为如果这样的话，Guest 就可以读写任意的内存地址。所以 VT-x 的方案中，还存在另一个重要的寄存器：EPT（Extended Page Table）。EPT 会指向一个 Page Table。当 VMM 启动一个 Guest kernel 时，VMM 会为 Guest kernel 设置好 EPT，并告诉硬件这个 EPT 是为了即将运行的虚拟机准备的。

之后，当计算机上的 MMU 在翻译 Guest 的虚拟内存地址时，它会先根据 Guest 设置好的 Page Table，将 Guest 虚拟地址（gva）翻译到 Guest 物理地址（gha）。之后再通过 EPT，将 Guest 物理地址（gha）翻译成主机物理地址（hpa）。硬件会为每一个 Guest 的每一个内存地址都自动完成这里的两次翻译。EPT 使得 VMM 可以控制 Guest 可以使用哪些内存地址。Guest 可以非常高效的设置任何想要的 Page Table，因为它现在可以直接执行 privileged 指令。但是 Guest 能够使用的内存地址仍然被 EPT 所限制，而 EPT 由 VMM 所配置，所以 Guest 只能使用 VMM 允许其使用的物理内存 Page（注，EPT 类似于 19.4 中的 Shadow Page Table）。

![](<../assets/image (632).png>)

> 学生提问：我对于硬件中保存的虚拟寄存器有问题，如果你有两个 CPU 核，然后你想要运行两个虚拟机，你会得到多少虚拟寄存器？
>
> Robert 教授：每一个 CPU 核都有一套独立的 VT-x 硬件。所以每一个 CPU 核都有属于自己的 32 个通用寄存器，属于自己的真实的控制寄存器，属于自己的用在 Guest mode 下的虚拟控制寄存器，属于自己的 EPT，所以你可以在两个 CPU 核上运行两个不同的虚拟机，它们不会共用任何寄存器，每个 CPU 核都有属于自己的寄存器。
>
> 学生提问：那也需要一个新的 VMM 吗？
>
> Robert 教授：VMM 可以像一个普通的操作系统一样。XV6 可以支持多个进程，并且为每个进程配备一个 proc 结构体。而我们的 VMM 也会为每个虚拟机配备一个 vm 结构体，用来跟踪 Guest 的信息。并且，如我之前所说的，如果你只有一个 CPU 核，但是有 3 个 Guest，可以通过定时器中断结合 VMM 在 3 个 Guest 之间切换。
