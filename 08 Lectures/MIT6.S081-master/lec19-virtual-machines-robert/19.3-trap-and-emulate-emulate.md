# 19.3 Trap-and-Emulate --- Emulate

VMM 会为每一个 Guest 维护一套虚拟状态信息。所以 VMM 里面会维护虚拟的 STVEC 寄存器，虚拟的 SEPC 寄存器以及其他所有的 privileged 寄存器。当 Guest 操作系统运行指令需要读取某个 privileged 寄存器时，首先会通过 trap 走到 VMM，因为在用户空间读取 privileged 寄存器是非法的。之后 VMM 会检查这条指令并发现这是一个比如说读取 SEPC 寄存器的指令，之后 VMM 会模拟这条指令，并将自己维护的虚拟 SEPC 寄存器，拷贝到 trapframe 的用户寄存器中（注，有关 trapframe 详见 Lec06，这里假设 Guest 操作系统通过类似“sread a0, sepc”的指令想要将 spec 读取到用户寄存器 a0）。之后，VMM 会将 trapframe 中保存的用户寄存器拷贝回真正的用户寄存器，通过 sret 指令，使得 Guest 从 trap 中返回。这时，用户寄存器 a0 里面保存的就是 SEPC 寄存器的值了，之后 Guest 操作系统会继续执行指令。最终，Guest 读到了 VMM 替自己保管的虚拟 SEPC 寄存器。

![](<../assets/image (505).png>)

> 学生提问：VMM 是怎么区分不同的 Guest？
>
> Robert 教授：VMM 会为每个 Guest 保存一份虚拟状态信息，然后它就像 XV6 知道是哪个进程一样，VMM 也知道是哪个 Guest 通过 trap 走到 VMM 的。XV6 有一个针对每个 CPU 的变量表明当前运行的是哪个进程，类似的 VMM 也有一个针对每个 CPU 的变量表明当前是哪个虚拟机在运行，进而查看对应的虚拟状态信息。
>
> 学生提问：VMM 可以给一个 Guest 分配多个 CPU 核吗？
>
> Robert 教授：稍微复杂点的 VMM 都可以实现。
>
> 学生提问：在实际的硬件中会有对应寄存器，那么为什么我们不直接使用硬件中的寄存器，而是使用虚拟的寄存器？
>
> Robert 教授：这里的原因是，VMM 需要使用真实的寄存器。举个例子，想象一下 SCAUSE 寄存器，当 Guest 操作系统尝试做任何 privileged 操作时（注，也就是读写 privileged 寄存器），会发生 trap。硬件会将硬件中真实的 SCAUSE 寄存器设置成引起 trap 的原因，这里的原因是因为权限不够。但是假设 Guest 操作系统只是从 Guest 用户进程执行了一个系统调用，Guest 操作系统需要看到 SCAUSE 的值是系统调用。也就是说 Guest 操作系统在自己的 trap handler 中处理来自 Guest 用户进程的系统调用时，需要 SCAUSE 的值表明是系统调用。

![](<../assets/image (465).png>)

> 而实际的 SCAUSE 寄存器的值却表明是因为指令违反了 privilege 规则才走到的 trap。通常情况下，VMM 需要看到真实寄存器的值，而 Guest 操作系统需要能看到符合自己视角的寄存器的值。（注，在 Guest 操作系统中，可能有两种情况会触发 trap，一种是 Guest 用户空间进程的系统调用，也就是正常操作系统中正常的 trap 流程，另一种是 Guest 内核空间读取 privileged 寄存器时，因为 Guest 内核空间实际上也是在宿主机的用户空间，导致这是个非法操作并触发 trap。Robert 这边举的例子的流程应该是这样，Guest 用户进程执行系统调用，在这一个瞬间 SCAUSE 寄存器的值是 ECALL，也就是 8，详见 6.6。但是稍后在 Guest 系统内核的 trap handler 中需要读取 SCAUSE 的值，以确定在 Guest 中引起 trap 的原因，但是这就触发了第二种 trap，SCAUSE 的值会变成 Illegal Access。我们不能让 Guest 系统内核看到这个值，所以 VMM 这里将它变成 ECALL 并返回。）

在这种虚拟机的实现中，Guest 整个运行在用户空间，任何时候它想要执行需要 privilege 权限的指令时，会通过 trap 走到 VMM，VMM 可以模拟这些指令。这种实现风格叫做 Trap and Emulate。你可以完全通过软件实现这种 VMM，也就是说你可以只通过修改软件就将 XV6 变成一个可以运行在 RISC-V 上的 VMM，然后再在之上运行 XV6 虚拟机。当然，与常规的 XV6 一样，VMM 需要运行在 Supervisor mode。

所有以 S 开头的寄存器，也就是所有的 Supervisor 控制寄存器都必须保存在虚拟状态信息中。同时还有一些信息并不能直接通过这些控制寄存器体现，但是又必须保存在这个虚拟状态信息中。其中一个信息就是 mode。VMM 需要知道虚拟机是运行在 Guest user mode 还是 Guest Supervisor mode。例如，Guest 中的用户代码尝试执行 privileged 指令，比如读取 SCAUSE 寄存器，这也会导致 trap 并走到 VMM。但是这种情况下 VMM 不应该模拟指令并返回，因为这并不是一个 User mode 中的合法指令。所以 VMM 需要跟踪 Guest 当前是运行在 User mode 还是 Supervisor mode，所以在虚拟状态信息里面也会保存 mode。

![](<../assets/image (457).png>)

VMM 怎么知道 Guest 当前的 mode 呢？当 Guest 从 Supervisor mode 返回到 User mode 时会执行 sret 指令，而 sret 指令又是一个 privileged 指令，所以会通过 trap 走到 VMM，进而 VMM 可以看到 Guest 正在执行 sret 指令，并将自己维护的 mode 从 Supervisor 变到 User。

虚拟状态信息中保存的另外一个信息是 hartid，它代表了 CPU 核的编号。即使通过 privileged 指令，也不能直接获取这个信息，VMM 需要跟踪当前模拟的是哪个 CPU。

![](<../assets/image (542).png>)

实际中，在不同类型的 CPU 上实现 Trap and Emulate 虚拟机会有不同的难度。不过 RISC-V 特别适合实现 Trap and Emulate 虚拟机，因为 RISC-V 的设计人员在设计指令集的时候就考虑了 Trap and Emulate 虚拟机的需求。举个例子，设计人员确保了每个在 Supervisor mode 下才能执行的 privileged 指令，如果在 User mode 执行都会触发 trap。你可以通过这种机制来确保 VMM 针对 Guest 中的每个 privileged 指令，都能看到一个 trap。

> 学生提问：Guest 操作系统内核中会实际运行任何东西吗？还是说它总是会通过 trap 走到 VMM？
>
> Robert 教授：如果你只是执行一个 ADD 指令，这条指令会直接在硬件上以硬件速度执行。如果你执行一个普通的函数调用，代码的执行也没有任何特殊的地方。所有 User 代码中合法的指令，以及内核代码中的 non-priviledged 指令，都是直接以全速在硬件上执行。
>
> 学生提问：在 Guest 操作系统中是不是也有类似的 User mode 和 Kernel mode？
>
> Robert 教授：有的。Guest 操作系统就是一个未被修改的普通操作系统，所以我们在 Guest 中运行的就是 Linux 内核或者 XV6 内核。而 XV6 内核知道自己运行在 Supervisor mode，从代码的角度来说，内核代码会认为自己运行在 Supervisor mode，并执行各种 privileged 指令，并期望这些指令能工作。当 Guest 操作系统执行 sret 指令时，它也知道自己将要进入到 User 空间。不过在宿主机上，Guest 操作系统是运行在 User mode，VMM 也确保了这里能正常工作。但是从 Guest 角度来说，自己的内核看起来像是运行在 Supervisor mode，自己的用户程序看起来像是运行在 User mode。

&#x20;所以，当 Guest 执行 sret 指令从 Supervisor mode 进入到 User mode，因为 sret 是 privileged 指令，会通过 trap 进入到 VMM。VMM 会更新虚拟状态信息中的 mode 为 User mode，尽管当前的真实 mode 还是 Supervisor mode，因为我们还在执行 VMM 中的代码。在 VMM 从 trap 中返回之前，VMM 会将真实的 SEPC 寄存器设置成自己保存在虚拟状态信息中的虚拟 SEPC 寄存器。因为当 VMM 使用自己的 sret 指令返回到 Guest 时，它需要将真实的程序计数器设置成 Guest 操作系统想要的程序计数器值（注，因为稍后 Guest 代码会在硬件上执行，因此依赖硬件上的程序计数器）。所以在一个非常短的时间内，真实的 SEPC 寄存器与虚拟的 SEPC 寄存器值是一样的。同时，当 VMM 返回到虚拟机时，还需要切换 Page table，这个我们稍后会介绍。

Guest 中的用户代码，如果是普通的指令，就直接在硬件上执行。当 Guest 中的用户代码需要执行系统调用时，会通过执行 ECALL 指令（注，详见 6.3，6.4）触发 trap，而这个 trap 会走到 VMM 中（注，因为 ECALL 也是个 privileged 指令）。VMM 可以发现当前在虚拟状态信息中记录的 mode 是 User mode，并且发现当前执行的指令是 ECALL，之后 VMM 会更新虚拟状态信息以模拟一个真实的系统调用的 trap 状态。比如说，它将设置虚拟的 SEPC 为 ECALL 指令所在的程序地址（注，执行 sret 指令时，会将程序计数器的值设置为 SEPC 寄存器的值。这样，当 Guest 执行 sret 指令时，可以从虚拟的 SEPC 中读到正确的值）；将虚拟的 mode 更新成 Supervisor；将虚拟的 SCAUSE 设置为系统调用；将真实的 SEPC 设置成虚拟的 STVEC 寄存器（注，STVEC 保存的是 trap 函数的地址，将真实的 SEPC 设置成 STVEC 这样当 VMM 执行 sret 指令返回到 Guest 时，可以返回到 Guest 的 trap handler。Guest 执行系统调用以为自己通过 trap 走到了 Guest 内核，但是实际上却走到了 VMM，这时 VMM 需要做一些处理，让 Guest 以及之后 Guest 的所有 privileged 指令都看起来好像是 Guest 真的走到了 Guest 内核）；之后调用 sret 指令跳转到 Guest 操作系统的 trap handler，也就是 STVEC 指向的地址。
