# 5.5 Stack

接下来我们讨论一下栈，stack。栈之所以很重要的原因是，它使得我们的函数变得有组织，且能够正常返回。

下面是一个非常简单的栈的结构图，其中每一个区域都是一个 Stack Frame，每执行一次函数调用就会产生一个 Stack Frame。

![](<../assets/image (867).png>)

每一次我们调用一个函数，函数都会为自己创建一个 Stack Frame，并且只给自己用。函数通过移动 Stack Pointer 来完成 Stack Frame 的空间分配。

对于 Stack 来说，是从高地址开始向低地址使用。所以栈总是向下增长。当我们想要创建一个新的 Stack Frame 的时候，总是对当前的 Stack Pointer 做减法。一个函数的 Stack Frame 包含了保存的寄存器，本地变量，并且，如果函数的参数多于 8 个，额外的参数会出现在 Stack 中。所以 Stack Frame 大小并不总是一样，即使在这个图里面看起来是一样大的。不同的函数有不同数量的本地变量，不同的寄存器，所以 Stack Frame 的大小是不一样的。但是有关 Stack Frame 有两件事情是确定的：

- Return address 总是会出现在 Stack Frame 的第一位
- 指向前一个 Stack Frame 的指针也会出现在栈中的固定位置

有关 Stack Frame 中有两个重要的寄存器，第一个是 SP（Stack Pointer），它指向 Stack 的底部并代表了当前 Stack Frame 的位置。第二个是 FP（Frame Pointer），它指向当前 Stack Frame 的顶部。因为 Return address 和指向前一个 Stack Frame 的的指针都在当前 Stack Frame 的固定位置，所以可以通过当前的 FP 寄存器寻址到这两个数据。

我们保存前一个 Stack Frame 的指针的原因是为了让我们能跳转回去。所以当前函数返回时，我们可以将前一个 Frame Pointer 存储到 FP 寄存器中。所以我们使用 Frame Pointer 来操纵我们的 Stack Frames，并确保我们总是指向正确的函数。

Stack Frame 必须要被汇编代码创建，所以是编译器生成了汇编代码，进而创建了 Stack Frame。所以通常，在汇编代码中，函数的最开始你们可以看到 Function prologue，之后是函数的本体，最后是 Epilogue。这就是一个汇编函数通常的样子。

![](<../assets/image (708).png>)

我们从汇编代码中来看一下这里的操作。

![](<../assets/image (827).png>)

在我们之前的 sum_to 函数中，只有函数主体，并没有 Stack Frame 的内容。它这里能正常工作的原因是它足够简单，并且它是一个 leaf 函数。leaf 函数是指不调用别的函数的函数，它的特别之处在于它不用担心保存自己的 Return address 或者任何其他的 Caller Saved 寄存器，因为它不会调用别的函数。

而另一个函数 sum_then_double 就不是一个 leaf 函数了，这里你可以看到它调用了 sum_to。

![](<../assets/image (843).png>)

所以在这个函数中，需要包含 prologue。

![](<../assets/image (682).png>)

这里我们对 Stack Pointer 减 16，这样我们为新的 Stack Frame 创建了 16 字节的空间。之后我们将 Return address 保存在 Stack Pointer 位置。

之后就是调用 sum_to 并对结果乘以 2。最后是 Epilogue，

![](<../assets/image (781).png>)

这里首先将 Return address 加载回 ra 寄存器，通过对 Stack Pointer 加 16 来删除刚刚创建的 Stack Frame，最后 ret 从函数中退出。

这里我替大家问一个问题，如果我们删除掉 Prologue 和 Epilogue，然后只剩下函数主体会发生什么？有人可以猜一下吗？

> 学生回答：sum_then_double 将不知道它应该返回的 Return address。所以调用 sum_to 的时候，Return address 被覆盖了，最终 sum_to 函数不能返回到它原本的调用位置。

是的，完全正确，我们可以看一下具体会发生什么。先在修改过的 sum_then_double 设置断点，然后执行 sum_then_double。

![](<../assets/image (865).png>)

我们可以看到现在的 ra 寄存器是 0x80006392，它指向 demo2 函数，也就是 sum_then_double 的调用函数。之后我们执行代码，调用了 sum_to。

![](<../assets/image (862).png>)

我们可以看到 ra 寄存器的值被 sum_to 重写成了 0x800065f4，指向 sum_then_double，这也合理，符合我们的预期。我们在函数 sum_then_double 中调用了 sum_to，那么 sum_to 就应该要返回到 sum_then_double。

之后执行代码直到 sum_then_double 返回。如前面那位同学说的，因为没有恢复 sum_then_double 自己的 Return address，现在的 Return address 仍然是 sum_to 对应的值，现在我们就会进入到一个无限循环中。

我认为这是一个很好的例子用来展示为什么跟踪 Caller 和 Callee 寄存器是重要的。

> 学生提问，为什在最开始要对 sp 寄存器减 16？
>
> TA：是为了 Stack Frame 创建空间。减 16 相当于内存地址向前移 16，这样对于我们自己的 Stack Frame 就有了空间，我们可以在那个空间存数据。我们并不想覆盖原来在 Stack Pointer 位置的数据。
>
> 学生提问：为什么不减 4 呢？
>
> TA：我认为我们不需要减 16 那么多，但是 4 个也太少了，你至少需要减 8，因为接下来要存的 ra 寄存器是 64bit（8 字节）。这里的习惯是用 16 字节，因为我们要存 Return address 和指向上一个 Stack Frame 的地址，只不过我们这里没有存指向上一个 Stack Frame 的地址。如果你看 kernel.asm，你可以发现 16 个字节通常就是编译器的给的值。

接下来我们来看一些 C 代码。

![](<../assets/image (857).png>)

demo4 函数里面调用了 dummymain 函数。我们在 dummymain 函数中设置一个断点，

![](<../assets/image (809).png>)

现在我们在 dummymain 函数中。如果我们在 gdb 中输入 info frame，可以看到有关当前 Stack Frame 许多有用的信息。

![](<../assets/image (720).png>)

- Stack level 0，表明这是调用栈的最底层
- pc，当前的程序计数器
- saved pc，demo4 的位置，表明当前函数要返回的位置
- source language c，表明这是 C 代码
- Arglist at，表明参数的起始地址。当前的参数都在寄存器中，可以看到 argc=3，argv 是一个地址

如果输入 backtrace（简写 bt）可以看到从当前调用栈开始的所有 Stack Frame。

![](<../assets/image (753).png>)

如果对某一个 Stack Frame 感兴趣，可以先定位到那个 frame 再输入 info frame，假设对 syscall 的 Stack Frame 感兴趣。

![](<../assets/image (789).png>)

在这个 Stack Frame 中有更多的信息，有一堆的 Saved Registers，有一些本地变量等等。这些信息对于调试代码来说超级重要。

> 学生提问：为什么有的时候编译器会优化掉 argc 或者 argv？这个以前发生过。
>
> TA：这意味着编译器发现了一种更有效的方法，不使用这些变量，而是通过寄存器来完成所有的操作。如果一个变量不是百分百必要的话，这种优化还是很有常见的。我们并没有给你编译器的控制能力，但是在你们的日常使用中，你可以尝试设置编译器的 optimization flag 为 0，不过就算这样，编译器也会做某些程度的优化。

（1:04:08 - 1:09:46 在介绍一些 gdb 技巧，conditional breakpoint，watchpoint 等，与课程内容无关，故跳过）
