# 5.1 C 程序到汇编程序的转换

（00:00 - 05:25 在讨论 syscall lab，没有什么实质内容故跳过）

今天的课程，我们会稍微讨论 C 语言转换到汇编语言的过程，以及处理器相关的内容。今天的课程更多偏向的是实际应用，或者至少我们的目标是这样。所以这节课的目标是让你们熟悉 RISC-V 处理器，汇编语言，以及 RISC-V 的 calling convention。对于 page table 来说这些内容不太重要，但是对于这周要发布的 traps lab 来说，这些内容至关重要，因为在这个实验中你们将会频繁用到 trapframe（注，XV6 中用来实现 trap 的一个内存 page，lecture 6 有详细内容）和栈。这些就是今天这节课的主要内容。

![](../assets/image5.1-01.png)

我们首先来简单看一下 C 语言是如何转换成汇编语言的。这部分内容有点像是对你们之前学过的 6.004 或者任意其他计算机架构课程的简单回顾。

通常来说，我们的 C 语言程序会有一个 main 函数，假设在这个函数内你执行了一些打印然后退出了。

![](<../assets/image (689).png>)

目前看起来都还不错。但是如果你学过了 6.004 的话，你应该知道，处理器并不能理解 C 语言。处理器能够理解的是汇编语言，或者更具体的说，处理器能够理解的是二进制编码之后的汇编代码。

在下面这张图中，我从一个 SiFive（注，一家基于 RISC-V 处理器的厂商）主板上圈出了一个实际的 RISC-V 处理器。

![](<../assets/image (687).png>)

当我们说到一个 RISC-V 处理器时，意味着这个处理器能够理解 RISC-V 的指令集。所以，任何一个处理器都有一个关联的 ISA（Instruction Sets Architecture），ISA 就是处理器能够理解的指令集。每一条指令都有一个对应的二进制编码或者一个 Opcode。当处理器在运行时，如果看见了这些编码，那么处理器就知道该做什么样的操作。上图中的处理器正好能理解 RISC-V 汇编语言。

所以通常来说，要让 C 语言能够运行在你的处理器之上。我们首先要写出 C 程序，之后这个 C 程序需要被编译成汇编语言。这个过程中有一些链接和其他的步骤，但是因为这门课不是一个编译器的课程，所以我们忽略这些步骤。之后汇编语言会被翻译成二进制文件也就是.obj 或者.o 文件。

![](<../assets/image (716).png>)

如果你们曾经注意过你们的 lab 目录，在运行完*make qemu*之后你会看到一些.o 文件，这些就是处理器能够理解的文件。虽然你还没有写任何汇编程序，你们也可以在目录中看到一些.asm 文件，这是由 C 语言编译生成的。如果你们学过了 6.004，那么你们必然已经看过一些汇编语言。

汇编语言不具备 C 语言的组织结构，在汇编语言中你只能看到一行行的指令，比如 add，mult 等等。汇编语言中没有很好的控制流程，没有循环（注，但是有基于 lable 的跳转），虽然有函数但是与你们知道的 C 语言函数不太一样，汇编语言中的函数是以 label 的形式存在而不是真正的函数定义。汇编语言是一门非常底层的语言，许多其他语言，比如 C++，都会编译成汇编语言。运行任何编译型语言之前都需要先生成汇编语言。

以上就是让计算机能够理解我们的 C 代码的基本流程。
