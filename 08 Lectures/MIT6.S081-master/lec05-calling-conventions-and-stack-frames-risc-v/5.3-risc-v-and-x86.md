# RISC-V 和 X86

你可能注意到了，在课程中我们一直都有提到 RISC-V 汇编以及 RISC-V 处理器。这很重要，因为汇编语言的种类有很多，所以对于你们个人来说，你们是不太可能用到 RISC-V 的，你们不太可能会在 RISC-V 处理器上运行 Linux。

事实上绝大多数现代计算机都运行在 x86 处理器上（有时候你们看到的是 x86-64）。这是一个不同于 RISC-V 的指令集架构，它看起来和 RISC-V 十分相似，但这才是你们自己的个人电脑上最常见到的指令集（如果你们用 intel 的话）。intel 的 cpu 实现了 x86 指令集，amd 的 cpu 也实现了 x86 指令集。

x86 与 RISC-V 并没有它们乍一看起来那么相似，它们之间的区别相对来说还比较重要。RISC-V 中的 RISC 表示精简指令集（Reduced Instruction Set）。x86-64 则被称为 CISC，或者说是复杂指令集。在它们之间有一系列的差别，其中一点就是 x86-64 中指令的数量与 RISC-V 对比非常之多。Intel 的手册中指令数量过多是创造 RISC-V 的一个主要动机。x86-64 的参考手册是三本厚书，那里面包含了整个 x86-64 指令集。有统计资料表明，自 x86-64 于 70 年代发布以来，intel 一直以每月 3 条指令的速度向 x86-64 指令集中添加指令。我估计 x86-64 指令集大概有 15000 条指令。而另一方面，就 RISC-V 来讲，仅仅两份文档就涵盖了 RISC-V 指令的所有内容。

![image02](../assets/lec05/image5.3-01.png)

在这门课程中，我们并不期望你们能记住每一条 RISC-V 指令。但如果你对这些指令感兴趣的话，或者对某个指令感到迷惑，你可以到课程网站上：

![image03](../assets/lec05/image5.3-02.png)

在 references 标签下可以看到我们在 RISC-V 段落下放了几个链接，包括了特殊权限指令（只能在 kernel mode 执行的指令）的链接和普通权限指令（user mode 可以执行的指令）的链接。这些文档可以给你提供一系列关于指令集架构的信息，不过请注意这个文档是 240 页，而另一个文档是 135 页。比起 x86-64 指令集的手册，这两份文档明显小很多。

RISC-V 的这个特点非常棒，在 RISC-V 中，有比 x86 更少的指令，这些指令也更简单。我之所以这么说是因为 x86-64 中的指令实在太多了，x86-64 中大量的指令集完成不止一件任务，它们执行了一系列复杂的操作并给出结果，而在 RISC-V 中就不是这样，RISC-V 指令倾向于拥有更少的职责，所以运行每条指令消耗的 CPU cycle 也比 x86-64 更少。

x86-64 和 RISC-V 的差别只是设计师所做出的一种权衡。事实上并没有真正意义上的精简指令集或是复杂指令集哪个更好的说法，两种指令集都有它们各自的用途。RISC-V 还有一个很酷的优点，与 x86 不同的是，RISC-V 是开源的，它是市面上仅有的开源指令集之一，所以这意味着任何人都能用 RISC-V 开发处理器。

RISC 诞生于 uc berkeley 的一个项目，uc berkeley 是其发源地。从那时起就有许多公司使用并赞助 RISC-V，你可以在网上找到名单。我记得最近 SiFive（大概是 RISC-V 处理器的主板制造商）发布了一则公告宣称他们将发布用于个人 PC 的 RISC-V 主板，那是一个为个人 PC 设计的 RISC-V 处理器。如果你们上完 6.s081 之后想用一用 RISC-V，到时候就有一个能让你们在自己的电脑上运行 Linux 的 RISC-V 处理器了。

在你们的日常生活中，你们可能在没有意识到的情况下已经使用了精简指令集，比如 arm 汇编，arm 也是一个精简指令集，高通的骁龙系列处理器就是 arm 架构的处理器。所以如果你有一个安卓手机，你很有可能在使用精简指令集。即使你用的是 iOS 也一样，苹果公司也在它们的处理器中使用了某些版本的 arm 架构。iPad，iPhone 以及大多数苹果设备都运行在那个处理器上，精简指令集可谓到处都是。如果你想在现实中而非 qemu 中找到 RISC-V 来使用，你可以在诸如嵌入式设备（intergrated devices）这样的设备上找到它，它并不像 x86-64 那样随处可见。但是我记得这两年苹果正在将 macs（指 mac 系列 PC）迁移到 arm 架构，可以肯定地说，因为有 intel 笨重的 CPU 的前车之鉴，苹果正朝着精简指令集发展。

![image5.3-03.png](../assets/lec05/image5.3-03.png)

intel 指令集架构如此庞大的根源在于他们非常关心向后兼容性，因此即使是三四十年前的 intel 代码也可以在现代 intel 处理器上运行。intel 并没有删除任何指令，所以他们的 cpu 可以保持向后兼容性。而 RISC-V 则更为现代化，所以不用担心 RISC-V 会存在这些历史遗留问题。

（瞎扯中）如果处理器有 15000 条指令，我们几乎不可能有效地在流水线上传送指令（pipeline them）。我们为啥需要这么多？我的意思是这么多指令只是为了向后兼容性，是否使用完全取决于你自己是否觉得向后兼容性重要。绝大多数都是 cmd 使用的专属的一类特殊指令，你不可能会用上这些指令，我从来没见过谁能完全利用 15000 条 intel 指令。这些指令中绝大多数的诞生都是为了满足向后兼容性的需求以及 cmd 的需求。

让我们回到这些手册。这个基整数指令集包含了所有正常的像 add，multiply 之类的指令。

![image5.3-04.png](../assets/lec05/image5.3-04.png)

然后处理器可以选择性地实现一些其他模块，你可以在这边看到这些模块，比如如果你想要一个支持单精度浮点数的标准扩展的处理器你可以导入 f 模块。。

![image5.3-05.png](../assets/lec05/image5.3-05.png)

这使得 RISC-V 更容易支持向后兼容性，因为你知道你导入并支持了哪些模块，然后编译器可以做出选择，编译器会说：“好的，这个处理器告诉我，它支持这些模块，所以我只可以用这些模块来编译这些代码。”

有学生说看起来用 x86 处理器代替 RISC-V 处理器的唯一优势就是你可以获得性能提升，然而这些性能提升带来了大量的代价与复杂性以及潜在安全问题。那么为什么我们仍然在用 x86 而非迁移到其他处理器架构（比如 RISC-V），主要原因是整个世界一直在使用 x86，如果突然地开始把所有处理器都换成 RISC-V，这会带来很大的风险，这会使得很多重要的设备失去支持。
