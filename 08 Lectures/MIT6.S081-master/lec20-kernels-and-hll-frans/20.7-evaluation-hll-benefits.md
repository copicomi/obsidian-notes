# 20.7 Evaluation: HLL benefits

![](<../assets/image (115).png>)

Biscuit 的实现与其他内核，例如 XV6，非常相似，除了 Biscuit 比 XV6 性能要高的多。Biscuit 采用了很多 Linux 内核的优化和聪明的设计：

- 我们对于内核文本采用了大页，以避免 TLB 的代价。
- 我们有针对每个 CPU 的网卡队列，这样可以避免 CPU 核之间同步。
- 我们有 RCU 实现了不需要读锁的 Directory Cache。
- ……

通常为了高性能而做的优化，编程语言并不会成为阻碍。Golang 并没有成为阻碍这些优化实现的因素。这些优化之前是在 C 和 Linux 中实现，我们现在只是在 Golang 中又实现它们。在实现这些优化时有很多的工作，但是这些工作与编程语言本身无关。

![](<../assets/image (7).png>)

今天[论文](https://pdos.csail.mit.edu/6.828/2020/readings/biscuit.pdf)的出发点就是了解用高级编程语言实现操作系统的收益和代价。所以我们将分两部分来评估，首先是收益，其次是代价。

![](<../assets/image (109).png>)

有关高级编程语言，我们要回答三个问题：

- 首先，我们有没有作弊？或许我们避免使用了所有 Golang 提供的高级编程语言中代价较高的功能。
- 其次，高级编程语言是否有简化 Biscuit 代码？
- 最后，高级编程语言是否能阻止前面提到的内核漏洞？

![](<../assets/image (105).png>)

首先，我们有没有使用高级编程语言的特性？我们会对比一下 Biscuit 与其他两个大的 Golang 项目在使用语言特性上是否类似，这样我们才可以说我们的内核以类似的方式利用了相同的语言特性。这里我们使用了相同的静态分析工具来分析两个大的 Golang 项目，它们都有超过 100 万行代码，其中一个项目是 Go runtime 以及包含的所有包，另一个是一个叫做 Moby 的系统。

![](<../assets/image (46).png>)

之后我们画出了一些高级语言特性在每 1000 行代码中的使用量。图中 X 轴是语言特性：

- allocation 对应于 new
- maps 就是 hashtable
- slice 是动态数组
- channel 是同步的工具，如你所见我们用的很少，Go runtine 和 Moby 也用的很少
- 很明显我们最喜欢的特性就是函数返回多个值
- 我们使用了 Closure（闭包）
- 我们稍微使用了 defer
- 我们使用了 Interface
- 使用了 Type assertion 来以一种类型安全的方式将一个类型转换成另一个类型
- 同时我们也 import 了很多包，Biscuit 内核是由很多个包构建出来的，而不是一个大的单一的程序

如你所见，有些特性 Biscuit 用的比 Go runtime 和 moby 更少，有些特性 Biscuit 用的更多，这里没有很明显的区别。所以从这张图中可以得出的主要结论是：Biscuit 使用了 Golang 提供的高级编程语言特性，而不是为了得到好的性能而避开使用它们。

> 学生提问：你这里是怎么统计的？是不是使用了静态分析工具？
>
> Frans 教授：是的，这里使用的就是静态分析工具。通过写一个小程序利用静态分析工具来查看这些项目的每一行代码，并记录对应的特性是什么，这样就能统计这些特性的使用数量。

![](<../assets/image (22).png>)

第二个问题有点主观，高级编程语言有没有简化 Biscuit 代码？笼统的说我认为有的，我这里会讨论一两个例子。

使用 Garbage allocation 是极好的，你可以回想 XV6，当你调用 exit 时，有大量的结构化数据需要被释放回给内核，这样后面的进程才能使用。如果使用 Garbage Collector 这里的工作着实容易，Garbage Collector 会完成这里的所有工作，你基本不用做任何事情。如果你从地址空间申请了一段内存，对应这段内存的 VMA 会自动被 GC 释放，所以这里可以简化代码。

如之前所说的，函数返回多个值对于代码风格很好。闭包很好，map 也很好。XV6 中很多地方通过线性扫描查找数据，但是如果你有 map 和 hashtable 作为可以直接使用的对象，那么你就不用线性扫描了。你可以直接使用 map，runtime 会高效地为你实现相应的功能。所以直观上的感受是，你可以得到更简单的代码。

![](<../assets/image (88).png>)

但是前面只是定性的评估，下面会介绍一些更具体的例子。当有大量的并发线程，且线程有共享的数据时，GC 如何起作用的。

![](<../assets/image (160).png>)

这里有个最简单的例子。假设你申请了一些动态的对象，比如说 buffer，你 fork 一个线程来处理这个 buffer，原线程也会处理同一个 buffer。当两个线程都完成了工作，buffer 需要被释放，这样内存才可以被后面的内核代码使用。这在 C 语言里面有点难协调，因为你需要有某种方式来决定 buffer 不再被使用。如果你使用 GC，那么就没什么好决定的，因为当两个线程都处理完 buffer 之后，没有线程会指向那个 buffer。GC 会从线程栈开始追踪，并且在任何线程栈中都找不到 buffer，因此 GC 会在稍后某个时间释放内存。所以在一个带 GC 的编程语言中，你完全不必考虑这个问题。

在 C 中你可以这样解决这个问题，为对象增加引用计数，引用计数需要被锁或者一些原子性操作保护，当引用计数到达 0 时，你可以释放内存。

![](<../assets/image (18).png>)

实际中锁加上引用计数代价稍微有点高。如果你想要高性能，并且并发可以扩展到 CPU 核数，这可能会是个瓶颈，我们在后面介绍 RCU 的时候会看这部分。所以，如果你想要高性能，好的并发能力，人们倾向于不给读数据加锁。

![](<../assets/image (122).png>)

在实际中，我们会使得读数据至少是不需要锁的，这样你就不需要付出额外的代价。上面是我们在 Golang 中的实现，我们有个 get 函数，它会读取并返回链表的头结点。这里就没有使用锁，而是使用了 atomic_load，它会读取头结点，但是又不需要锁。后面的 pop 函数使用了锁。这种风格在 Linux 内核中非常常见，写数据需要加锁，读数据不用加锁。这里 pop 函数会从链表中弹出头结点，这样你就可以重用头结点对应的内存。在 C 中实现这种风格会有点困难，因为有可能当你释放头结点内存时，其他并发的线程正好读取到了头结点的指针。这样当你做完 atomic_store，你不能释放指针内容，因为有可能有另一个线程的指针指向了这部分内容。如果你在这里释放了指针内容，你有可能会有 use-after-free Bug。

![](<../assets/image (92).png>)

我们在这门课程的最后一节课会看到，Linux 内核对这个问题有一种非常聪明的解决办法，被称为 Read-Copy-Update 或者是 RCU。它的工作就是推迟释放内存，直到确定指针不再被使用，并且它有一种非常聪明的方案来决定什么时候可以安全释放内存。但是这个方案有各种各样的限制，程序员需要在 RCU 关键区域内遵守各种规则。比如说你不能在 RCU 关键区域 sleep，也不能切换线程。

所以尽管实际中 Linux 内核非常成功的使用了 RCU，但是 RCU 还是有点容易出错，并且需要小心编程来使得它能正确工作。在带有 GC 的编程语言，例如 Golang，这就不是问题了，因为 GC 会决定某个对象不再被使用，只有这时才释放它。所以现在对于编程人员来说没有限制了，所有的限制都被 GC 考虑了。这是一种带有 GC 的编程语言的明显优势。

![](<../assets/image (158).png>)

接下来看看 CVEs Bugs，这在前面提到过（注，20.1）。

![](<../assets/image (69).png>)

我们手动的检查了所有的 CVEs Bug，并尝试确定 Golang 是否修复了问题。

- 第一行代表我们不能弄清楚这些 Bug 的结果是什么，它会怎么展现，我们知道如何修复这些问题，但是我们不能确定 Golang 是否能避免这些问题。
- 有很多逻辑 Bug，可以认为 Golang 会有与 C 相同的 Bug，所以结果是相同的
- 接下来是 40 个 memory-safety Bugs，包括了 use-after-free，double-free，out-of-bound。其中 8 个直接消失了，因为 GC 考虑了内存释放，32 个会产生 panic，比如说数组越界。当然 panic 并不好，因为内核会崩溃，但是或许要比直接的安全漏洞更好。所以在这 40 个 Bug 中，高级编程语言有帮到我们。

以上就是使用高级编程语言实现内核的优势，接下来讨论一些代价，也就是 High Level Language Tax。
