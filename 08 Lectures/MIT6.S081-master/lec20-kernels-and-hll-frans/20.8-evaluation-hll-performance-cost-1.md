# 20.8 Evaluation: HLL performance cost(1)

![](<../assets/image (58).png>)

以上是 6 个问题，我应该不会全部介绍，因为我想在课程的最后留些时间来回顾我们在本节课开始时提出的问题。

![](<../assets/image (162).png>)

以上就是测试环境，Biscuit 运行在裸机之上，所以我们的测试是在物理服务器而不是 QEMU 之上。我们使用了三个应用程序来做性能测试，它们分别是，Webserver，K/V store，Mail server benchmark。

![](<../assets/image (6).png>)

这三个应用程序都会给内核一定的压力，它们会执行系统调用，内核会做大量的工作。你可以看到，大部分 CPU 时间都在内核中。

![](<../assets/image (157).png>)

首先的问题是，Biscuit 是否是一个工业质量的内核？我们将前面的三个应用程序分别运行在 Linux 和 Biscuit 上，并进行对比。

![](<../assets/image (73).png>)

在 Linux 中，我们会关闭所有 Biscuit 不提供的功能，比如 Page Table 隔离，repoline 等等很多功能，这样的对比才会尽可能的公平。有些特性会比较难关闭，但是我们会尽量将它们关闭。

![](<../assets/image (43).png>)

之后我们会测试吞吐量，如你所见 Biscuit 总是会比 Linux 更慢，mailbench 可能差 10%，nginx 和 redis 差 10%到 15%。这里的数字并不是绝对的，因为两个系统并不完全一样。但是可以看出两个系统基本在同一个范围内，而不是差个 2 倍或者 10 倍。

![](<../assets/image (29).png>)

接下来我们会分析代码，并找到高级编程语言额外的 CPU cycle 消耗。我们会找到：

- 哪些 CPU cycle 是 GC 使用的，
- 哪些是函数调用的 Prologue 使用的。Golang 会为函数调用做一些额外的工作来确保 Stack 足够大，这样就不会遇到 Out-of-Stack 的问题
- Write barrier 是 GC 用来跟踪不同空间的指针的方法
- Safety cycles 是用在数组边界检查，空指针检查上的 CPU cycles

![](<../assets/image (141).png>)

通过测试上面的应用程序，可以得到测量结果。

- 3%的执行时间用在了 GC cycles 中，这里我稍后会介绍为什么这很少。同时这也可以说明 GC 是在运行的，我们并不是用了一大块内存而没有使用 GC
- 令人奇怪的是，Prologue 占有的 CPU 时间最多，这基本上跟我们用来检查 kernel Stack 或者 goroutine Stack 是否需要增加的方案有关，这里或许更容易降低一些
- Write barrier 使用的时间很少
- 2%-3%的 CPU 时间用在了 Safety cycles 中

这些数据都很好，High Level Language Tax 并不是那么的大。

![](<../assets/image (94).png>)

当然 GC 的占比可能会更高，因为它完全取决于 heap 大小和存活对象的数量，GC 会跟踪所有的存活对象，并决定哪些对象已经不被使用。如果有大量的存活对象，GC 也需要跟踪更多的对象。所以这里的 CPU 时间完全与存活对象的数量相关。

![](<../assets/image (25).png>)

所以我们做了一些其他的实验。我们创建了大量的存活对象，大概有 200 万个 vnode，可以认为这是 200 万个 inode。然后修改 heap 的 headroom，也就是 GC 可以使用的空闲内存数量，最后再测量 GC 的代价。

![](<../assets/image (111).png>)

上图就是测量结果，存活对象占了 640MB 内存，我们在不同内存大小下运行测试。第一次测试时，有 320MB 空闲内存，是存活对象内存的一半，这时 Golang 有非常严重的 overhead，大概是 34%，GC 因为没有足够的 headroom 需要运行很多额外的程序。如果空闲内存是存活对象的 2 倍，那么 GC 的 overhead 就没有那么疯狂，只有 9%。所以，为了保持 GC 的 overhead 在 10%以内，物理内存大小需要是 heap 大小的三倍。

> 学生提问：什么是 write barrier？是设置权限吗？
>
> Frans 教授：你还记得 Lec17 的内容吗？当 GC 在运行的时候，需要检查指针是否在 from 空间，如果在 from 空间你需要拷贝它到 to 空间。write barrier 是非常类似的功能，它的想法是一样的，你需要检查指针看它是否在你需要运行 GC 的区域内。
>
> 学生提问：当存活对象的内存大于空闲内存的时候，GC 该怎么工作呢？
>
> Frans 教授：你买一些内存，vnode 会使用一些内存，然后还剩下 320MB 空闲内存。当应用程序申请更多内存时，首先会从空闲内存中申请，直到空闲内存也用光了。与此同时，GC 也在运行。所以我们刚刚的测试中是在 3 个不同配置下运行，在最后一个配置中，空闲内存是存活对象占用内存的两倍。这意味着 GC 有大量的 headroom 来与应用程序并行的运行，如果有大量的 headroom，GC 的 overhead 就没那么高了，只有 10%左右，而不是 34%。在第一个配置中，总共是 640+320MB 内存，而不是只有 320MB 内存。

![](<../assets/image (20).png>)

这一页跳过。
