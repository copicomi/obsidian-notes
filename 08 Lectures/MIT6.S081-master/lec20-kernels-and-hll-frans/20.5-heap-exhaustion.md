# 20.5 Heap exhaustion

让我们讨论一下 Heap 耗尽问题，我不会像[论文](https://pdos.csail.mit.edu/6.828/2020/readings/biscuit.pdf)一样深入讨论，但是至少会演示问题是什么。

![](<../assets/image (63).png>)

假设蓝色的矩形是内核，内核会有一个 heap，它会从其中申请动态内存。在 XV6 中，我们并没有这样一个 heap，我们在内核中没有内存分配器，所有内存都是静态分配的。但是任何其他的内核中，都会有 heap，所以你在内核中可以调用 malloc 和 free。可能通过 heap 分配的对象有 socket 对象，文件描述符对象和进程对象。所以，我们在 XV6 中静态分配的所有结构体，例如 struct proc，struct fd，在正常的内核中都是动态分配的。所以当你打开一个新的文件描述符时，内核会通过 heap 分配一个文件描述符对象。

这里的问题是，你可以运行很多个应用程序，它们会打开很多个文件描述符，拥有很多个 socket，它们会逐渐填满 heap。

![](<../assets/image (54).png>)

在某个时间点，heap 会被填满，这时没有额外的空间可以用来分配一个新的对象。如果这时应用程序需要打开一个新的文件描述符，或者调用了 fork 使得内核想要在 heap 中分配一个新的 proc 结构体，heap 中没有了空间。这时你该怎么办呢？这是一个不太常见的常见问题，但是如果你使劲用你的电脑，你或许会遇到所有内存都被使用了的情况，你的 heap 满了，并且没有进程调用 free，因为它们都还在运行且想分配到更多的内存。所有的内核都会遇到这个问题，不管是 C 内核也好，Biscuit 也好，任何内核都需要解决这个问题。

之所以这个问题对于我们来说是个严重的问题，是因为在很多内核中，你可以对 malloc 返回错误，实际上，XV6 就是这么做的。但是在 Go runtime 中，当你调用 new 来分配一个 Go 对象，并没有 error condition，new 总是可以成功。让我们来讨论一些可以解决这里问题的方法。

![](<../assets/image (811) (1).png>)

- 第一种方法我们在 XV6 中见过。如果 XV6 不能找到一个空闲的 block cache 来保存 disk block，它会直接 panic。这明显不是一个理想的解决方案。这并不是一个实际的解决方案，所以我们称之为 strawman。
- 另一个 strawman 方法是，当你在申请一块新的内存时，你会调用 alloc 或者 new 来分配内存，你实际上可以在内存分配器中进行等待。这实际上也不是一个好的方案，原因是你可能会有死锁。假设内核有把大锁，当你调用 malloc，因为没有空闲内存你会在内存分配器中等待，那么这时其他进程都不能运行了。因为当下一个进程想要释放一些内存时，但是因为死锁也不能释放。对于内核中有大锁的情况，这里明显有问题，但是即使你的锁很小，也很容易陷入到这种情况：在内存分配器中等待的进程持有了其他进程需要释放内存的锁，这就会导致死锁的问题。
- 下一个 strawman 方法是，如果没有内存了就返回空指针，你检查如果是空指针就直接失败，这被称为 bail out。但是 bail out 并不是那么直观，进程或许已经申请了一些内存，那么你需要删除它们，你或许做了一部分磁盘操作，比如说你在一个多步的文件系统操作中间，你只做了其中的一部分，你需要回退。所以实际中非常难做对。

当研究这部分，并尝试解决这个问题，Linux 使用了前面两种方法，但是两种方法都有问题。实际中，内核开发人员很难将这里弄清楚。如果你对这个问题和相关的讨论感兴趣，可以 Google 搜索“[too small to fail](https://lwn.net/Articles/627419/)”，会有一篇小的文章讨论释放内存，在内存分配器中等待的复杂性。

对于 Biscuit 来说，strawman 2 解决方案不可能实施，因为 new 不会 fail，它总是能成功。除此之外，这里的方案都不理想，所以我们需要有一种更好的方法。
