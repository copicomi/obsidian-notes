# 20.9 Evaluation: HLL performance cost(2)

![](<../assets/image (148).png>)

接下来稍微介绍 GC pause。Go 的 GC 是一个带有短暂 pause 的并发 GC，它在一段非常短的时间内停止程序运行来执行 write barrier，之后再恢复应用程序的运行，同时 GC 也会完成自己的工作。Go 的 GC 也是递增的，就像我们在 Lec17 中介绍过的一样，每次调用 new 都会做一些 GC 的工作。所以每次 GC 做一些工作的时候，应用程序都会有一些延时，这就是代价。

![](<../assets/image (11).png>)

所以我们做了一些测试，我们找了个应用程序并测试了最大的 pause 时间。也就是由于 GC 可能导致应用程序最大的停止时间。

![](<../assets/image (17).png>)

最大的单个 pause 时间是 115 微秒，也就是在 web server 中，因为使用了 TCP stack，TCP Connection table 中很大一部分需要被标记（注，GC 的一部分工作是标记对象），这花费了 115 微秒。一个 HTTP 请求最大的 pause 时间是 582 微秒，所以当一个请求走到一个机器，最多会有总共 582 微秒延时来执行这个请求。而超过 100 微秒的 pause 发生的非常非常少，只有少于 0.3%。

![](<../assets/image (143).png>)

如果你尝试达成某种 SLA，其中要求的最长请求处理时间很短，那么 582 微秒就很严重。但是如果你查看 Google 论文，[The Tail at Scale](https://research.google/pubs/pub40801/)，其中介绍有关一个请求最长可以有多长处理时间，他们讨论的都是几毫秒或者几十毫秒这个量级。所以 Biscuit 拥有最大 pause 时间是 582 微秒还在预算之内，虽然不理想，但是也不会很夸张。这表明了，Golang 的设计人员把 GC 实现的太好了。并且我们在做 Biscuit 项目的时候发现，每次我们升级 Go runtime，新的 runtime 都会带一个更好的 GC，相应的 GC pause 时间也会变得更小。

![](<../assets/image (1).png>)

之前在 Linux 和 Biscuit 之间的对比并不真正的公平，因为 Biscuit 和 Linux 实现的是不同的功能。所以我们做了一个额外的测试，我们写了两个完全相同的内核，一个用 C 实现，另一个用 Golang 实现。这两个内核实现了完全相同的东西，并且我们会查看汇编代码以检查区别在哪。可能会有一些区别，因为 Golang 会做一些安全检查，但是对于基本功能来说，汇编代码是一样的。

![](<../assets/image (77).png>)

以上是有关测试的一部分，通过 pipe 来回传输一个字节。我们查看内核中有关将一个字节从 pipe 的一端传到另一端的代码。Go 里面是 1.2K 行代码，C 里面是 1.8K 行代码。这里没有内存分配和 GC，所以这里只有语言上的差异。我们还查看了两种实现语言中花费最多时间的 10 个地方，这样我们才能确保两种语言实现的代码尽可能的接近。

![](<../assets/image (96).png>)

之后我们查看了每秒可以完成的操作数，如你可见 Golang 要慢 15%。如果你查看 Golang 的 Prologue 和 safety-check，这些指令是 C 代码所没有的，这些指令占了 16%，这与更慢的处理速度匹配的上。所以这里的主要结论是 Golang 是更慢，但并不是非常夸张的慢，Golang 还是非常有竞争力的。并且这与我们早些时候做的 Biscuit 和 Linux 对比结果一致。

第 6 个问题跳过。
