# 10.2 锁如何避免 race condition？

首先你们在脑海里应该有多个 CPU 核在运行，比如说 CPU0 在运行指令，CPU1 也在运行指令，这两个 CPU 核都连接到同一个内存上。在前面的代码中，数据 freelist 位于内存中，它里面记录了 2 个内存 page。假设两个 CPU 核在相同的时间调用 kfree。

![](<../assets/image (852).png>)

kfree 函数接收一个物理地址 pa 作为参数，freelist 是个单链表，kfree 中将 pa 作为单链表的新的 head 节点，并更新 freelist 指向 pa（注，也就是将空闲的内存 page 加在单链表的头部）。当两个 CPU 都调用 kfree 时，CPU0 想要释放一个 page，CPU1 也想要释放一个 page，现在这两个 page 都需要加到 freelist 中。

![](<../assets/image (726).png>)

kfree 中首先将对应内存 page 的变量 r 指向了当前的 freelist（也就是单链表当前的 head 节点）。我们假设 CPU0 先运行，那么 CPU0 会将它的变量 r 的 next 指向当前的 freelist。如果 CPU1 在同一时间运行，它可能在 CPU0 运行第二条指令（kmem.freelist = r）之前运行代码。所以它也会完成相同的事情，它会将自己的变量 r 的 next 指向当前的 freelist。现在两个物理 page 对应的变量 r 都指向了同一个 freelist（注，也就是原来单链表的 head 节点）。

![](<../assets/image (568) (2) (2) (2) (2).png>)

接下来，剩下的代码也会并行的执行（kmem.freelist = r），这行代码会更新 freelist 为 r。因为我们这里只有一个内存，所以总是有一个 CPU 会先执行，另一个后执行。我们假设 CPU0 先执行，那么 freelist 会等于 CPU0 的变量 r。之后 CPU1 再执行，它又会将 freelist 更新为 CPU1 的变量 r。这样的结果是，我们丢失了 CPU0 对应的 page。CPU0 想要释放的内存 page 最终没有出现在 freelist 数据中。

这是一种具体的坏的结果，当然可能会有更多坏的结果，因为可能会有更多的 CPU。例如第三个 CPU 可能会短暂的发现 freelist 等于 CPU0 对应的变量 r，并且使用这个 page，但是之后很快 freelist 又被 CPU1 更新了。所以，拥有越多的 CPU，我们就可能看到比丢失 page 更奇怪的现象。

在代码中，用来解决这里的问题的最常见方法就是使用锁。

接下来让我具体的介绍一下锁。锁就是一个对象，就像其他在内核中的对象一样。有一个结构体叫做 lock，它包含了一些字段，这些字段中维护了锁的状态。锁有非常直观的 API：

- acquire，接收指向 lock 的指针作为参数。acquire 确保了在任何时间，只会有一个进程能够成功的获取锁。
- release，也接收指向 lock 的指针作为参数。在同一时间尝试获取锁的其他进程需要等待，直到持有锁的进程对锁调用 release。

![](<../assets/image (694).png>)

锁的 acquire 和 release 之间的代码，通常被称为 critical section。

![](<../assets/image (770).png>)

之所以被称为 critical section，是因为通常会在这里以原子的方式执行共享数据的更新。所以基本上来说，如果在 acquire 和 release 之间有多条指令，它们要么会一起执行，要么一条也不会执行。所以永远也不可能看到位于 critical section 中的代码，如同在 race condition 中一样在多个 CPU 上交织的执行，所以这样就能避免 race condition。

现在的程序通常会有许多锁。实际上，XV6 中就有很多的锁。为什么会有这么多锁呢？因为锁序列化了代码的执行。如果两个处理器想要进入到同一个 critical section 中，只会有一个能成功进入，另一个处理器会在第一个处理器从 critical section 中退出之后再进入。所以这里完全没有并行执行。

如果内核中只有一把大锁，我们暂时将之称为 big kernel lock。基本上所有的系统调用都会被这把大锁保护而被序列化。系统调用会按照这样的流程处理：一个系统调用获取到了 big kernel lock，完成自己的操作，之后释放这个 big kernel lock，再返回到用户空间，之后下一个系统调用才能执行。这样的话，如果我们有一个应用程序并行的调用多个系统调用，这些系统调用会串行的执行，因为我们只有一把锁。所以通常来说，例如 XV6 的操作系统会有多把锁，这样就能获得某种程度的并发执行。如果两个系统调用使用了两把不同的锁，那么它们就能完全的并行运行。

![](<../assets/image (685).png>)

这里有几点很重要，首先，并没有强制说一定要使用锁，锁的使用完全是由程序员决定的。如果你想要一段代码具备原子性，那么其实是由程序员决定是否增加锁的 acquire 和 release。其次，代码不会自动加锁，程序员自己要确定好是否将锁与数据结构关联，并在适当的位置增加锁的 acquire 和 release。
