# 10.7 自旋锁（Spin lock）的实现（一）

接下来我们看一下如何实现自旋锁。锁的特性就是只有一个进程可以获取锁，在任何时间点都不能有超过一个锁的持有者。我们接下来看一下锁是如何确保这里的特性。

我们先来看一个有问题的锁的实现，这样我们才能更好的理解这里的挑战是什么。实现锁的主要难点在于锁的 acquire 接口，在 acquire 里面有一个死循环，循环中判断锁对象的 locked 字段是否为 0，如果为 0 那表明当前锁没有持有者，当前对于 acquire 的调用可以获取锁。之后我们通过设置锁对象的 locked 字段为 1 来获取锁。最后返回。

![](<../assets/image (593).png>)

如果锁的 locked 字段不为 0，那么当前对于 acquire 的调用就不能获取锁，程序会一直 spin。也就是说，程序在循环中不停的重复执行，直到锁的持有者调用了 release 并将锁对象的 locked 设置为 0。

在这个实现里面会有什么样的问题？

> 学生回答：两个进程可能同时读到锁的 locked 字段为 0。

是的，所以这里会有 race condition，在下面的位置会有 race。

![](<../assets/image (440).png>)

如果 CPU0 和 CPU1 同时到达 A 语句，它们会同时看到锁的 locked 字段为 0，之后它们会同时走到 B 语句，这样它们都 acquire 了锁。这样我们就违背了锁的特性。

为了解决这里的问题并得到一个正确的锁的实现方式，其实有多种方法，但是最常见的方法是依赖于一个特殊的硬件指令。这个特殊的硬件指令会保证一次 test-and-set 操作的原子性。在 RISC-V 上，这个特殊的指令就是 amoswap（atomic memory swap）。这个指令接收 3 个参数，分别是 address，寄存器 r1，寄存器 r2。这条指令会先锁定住 address，将 address 中的数据保存在一个临时变量中（tmp），之后将 r1 中的数据写入到地址中，之后再将保存在临时变量中的数据写入到 r2 中，最后再对于地址解锁。

![](<../assets/image (445).png>)

通过这里的加锁，可以确保 address 中的数据存放于 r2，而 r1 中的数据存放于 address 中，并且这一系列的指令打包具备原子性。大多数的处理器都有这样的硬件指令，因为这是一个实现锁的方便的方式。这里我们通过将一个软件锁转变为硬件锁最终实现了原子性。不同处理器的具体实现可能会非常不一样，处理器的指令集通常像是一个说明文档，它不会有具体实现的细节，具体的实现依赖于内存系统是如何工作的，比如说：

- 多个处理器共用一个内存控制器，内存控制器可以支持这里的操作，比如给一个特定的地址加锁，然后让一个处理器执行 2-3 个指令，然后再解锁。因为所有的处理器都需要通过这里的内存控制器完成读写，所以内存控制器可以对操作进行排序和加锁。
- 如果内存位于一个共享的总线上，那么需要总线控制器（bus arbiter）来支持。总线控制器需要以原子的方式执行多个内存操作。
- 如果处理器有缓存，那么缓存一致性协议会确保对于持有了我们想要更新的数据的 cache line 只有一个写入者，相应的处理器会对 cache line 加锁，完成两个操作。

硬件原子操作的实现可以有很多种方法。但是基本上都是对于地址加锁，读出数据，写入新数据，然后再返回旧数据（注，也就是实现了 atomic swap）。

接下来我们看一下如何使用这条指令来实现自旋锁。让我们来看一下 XV6 中的 acquire 和 release 的实现。首先我们看一下 spinlock.h

![](<../assets/image (424).png>)

如你所见，里面有 spinlock 结构体的定义。内容也比较简单，包含了 locked 字段表明当前是否上锁，其他两个字段主要是用来输出调试信息，一个是锁的名字，另一个是持有锁的 CPU。

接下来我们看一下 spinlock.c 文件，先来看一下 acquire 函数，

![](<../assets/image (640).png>)

在函数中有一个 while 循环，这就是我刚刚提到的 test-and-set 循环。实际上 C 的标准库已经定义了这些原子操作，所以 C 标准库中已经有一个函数\_\_sync_lock_test_and_set，它里面的具体行为与我刚刚描述的是一样的。因为大部分处理器都有的 test-and-set 硬件指令，所以这个函数的实现比较直观。我们可以通过查看 kernel.asm 来了解 RISC-V 具体是如何实现的。下图就是 atomic swap 操作。

![](<../assets/image (483).png>)

这里比较复杂，总的来说，一种情况下我们跳出循环，另一种情况我们继续执行循环。C 代码就要简单的多。如果锁没有被持有，那么锁对象的 locked 字段会是 0，如果 locked 字段等于 0，我们调用 test-and-set 将 1 写入 locked 字段，并且返回 locked 字段之前的数值 0。如果返回 0，那么意味着没有人持有锁，循环结束。如果 locked 字段之前是 1，那么这里的流程是，先将之前的 1 读出，然后写入一个新的 1，但是这不会改变任何数据，因为 locked 之前已经是 1 了。之后\_\_sync_lock_test_and_set 会返回 1，表明锁之前已经被人持有了，这样的话，判断语句不成立，程序会持续循环（spin），直到锁的 locked 字段被设置回 0。

接下来我们看一下 release 的实现，首先看一下 kernel.asm 中的指令

![](<../assets/image (519).png>)

可以看出 release 也使用了 atomic swap 操作，将 0 写入到了 s1。下面是对应的 C 代码，它基本确保了将 lk->locked 中写入 0 是一个原子操作。

![](<../assets/image (452) (1) (1) (1) (1).png>)
