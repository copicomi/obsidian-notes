# 1.6 open 系统调用

前面，copy 代码假设文件描述符已经设置好了。但是一般情况下，我们需要能创建文件描述符，最直接的创建文件描述符的方法是 open 系统调用。下面是一个叫做 open 的源代码，它使用了 open 系统调用。

![](<../assets/image (194).png>)

> 学生提问：字节流是什么意思？
>
> Robert 教授：我。。。我的意思是，如果一个文件包含了一些字节，假设包含了数百万个字节，你触发了多个 read，每个 read 读取 100 个字节，第一次 read 会读取前 100 个字节，第二次读取 101-200 个字节，第三次读取 201-300 个字节，这就是我的意思。（字节流就是一段连续的数据按照字节的长度读取）

这个叫做 open 的程序，会创建一个叫做 output.txt 的新文件，并向它写入一些数据，最后退出。我们看不到任何输出，因为它只是向打开的文件中写入数据。

![](<../assets/image (228).png>)

但是我们可以查看 output.txt 的内容。

![](<../assets/image (322).png>)

并看到 open 程序写入的“ooo”。所以，代码中的第 11 行，执行了 open 系统调用，将文件名 output.txt 作为参数传入，第二个参数是一些标志位，用来告诉 open 系统调用在内核中的实现：我们将要创建并写入一个文件。open 系统调用会返回一个新分配的文件描述符，这里的文件描述符是一个小的数字，可能是 2，3，4 或者其他的数字。

之后，这个文件描述符作为第一个参数被传到了 write，write 的第二个参数是数据的指针，第三个参数是要写入的字节数。数据被写入到了文件描述符对应的文件中。

文件描述符本质上对应了内核中的一个表单数据。内核维护了每个运行进程的状态，内核会为每一个运行进程保存一个表单，表单的 key 是文件描述符。这个表单让内核知道，每个文件描述符对应的实际内容是什么。这里比较关键的点是，每个进程都有自己独立的文件描述符空间，所以如果运行了两个不同的程序，对应两个不同的进程，如果它们都打开一个文件，它们或许可以得到相同数字的文件描述符，但是因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。

对于 open 系统调用和这里的小程序，大家有什么问题吗？

> 学生提问：我不太熟悉 C 语言，这里的文件描述符与非 C 语言中有什么区别？如果使用 Python 的话，语法上会不会简单点？
>
> Robert 教授：Python 肯定提供了对于 open 的较好的封装。通常来说，Python 提供的是更高级的函数，比如说 Python 不会使用指向内存的指针，并且 Python 会为你做更多的错误检查。当我们在 Python 中打开文件或者写入文件时，你在 Python 中的调用最终会走到跟我们例子中一样的系统调用来，这是个好的回答吗？
