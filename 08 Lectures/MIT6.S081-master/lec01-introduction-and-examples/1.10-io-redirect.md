# 1.10 I/O Redirect

最后一个例子，我想展示一下将所有这些工具结合在一起，来实现 I/O 重定向。

![](<../assets/image (362).png>)

我们之前讲过，Shell 提供了方便的 I/O 重定向工具。如果我运行下面的指令，

![](<../assets/image (387).png>)

Shell 会将 echo 的输出送到文件 out。之后我们可以运行 cat 指令，并将 out 文件作为输入，

![](<../assets/image (397).png>)

我们可以看到保存在 out 文件中的内容就是 echo 指令的输出。

Shell 之所以有这样的能力，是因为 Shell 首先会像第 13 行一样 fork，然后在子进程中，Shell 改变了文件描述符。文件描述符 1 通常是进程用来作为输出的（也就是 console 的输出文件符），Shell 会将文件描述符 1 改为 output 文件，之后再运行你的指令。同时，父进程的文件描述符 1 并没有改变。所以这里先 fork，再更改子进程的文件描述符，是 Unix 中的常见的用来重定向指令的输入输出的方法，这种方法同时又不会影响父进程的输入输出。因为我们不会想要重定向 Shell 的输出，我们只想重定向子进程的输出。

这里之所以能工作的原因是，代码的第 15 行只会在子进程中执行。代码的第 15 行的意义是重定向 echo 命令的输出，如果我运行整个程序 redirect 程序。

![](<../assets/image (294).png>)

可以看到没有任何的输出。但是实际上 redirect 程序里面运行了 echo，只是 echo 的输出重定向到了 output.txt。如果我们查看 output.txt，

![](<../assets/image (337).png>)

我们可以看到预期的输出。代码第 15 行的 close(1)的意义是，我们希望文件描述符 1 指向一个其他的位置。也就是说，在子进程中，我们不想使用原本指向 console 输出的文件描述符 1。

代码第 16 行的 open 一定会返回 1，因为 open 会返回当前进程未使用的最小文件描述符序号。因为我们刚刚关闭了文件描述符 1，而文件描述符 0 还对应着 console 的输入，所以 open 一定可以返回 1。在代码第 16 行之后，文件描述符 1 与文件 output.txt 关联。

之后我们执行 exec(echo)，echo 会输出到文件描述符 1，也就是文件 output.txt。这里有意思的地方是，echo 根本不知道发生了什么，echo 也没有必要知道 I/O 重定向了，它只是将自己的输出写到了文件描述符 1。只有 Shell 知道 I/O 重定向了。

这个例子同时也演示了分离 fork 和 exec 的好处。fork 和 exec 是分开的系统调用，意味着在子进程中有一段时间，fork 返回了，但是 exec 还没有执行，子进程仍然在运行父进程的指令。所以这段时间，尽管指令是运行在子进程中，但是这些指令仍然是父进程的指令，所以父进程仍然可以改变东西，直到代码执行到了第 19 行。这里 fork 和 exec 之间的间隔，提供了 Shell 修改文件描述符的可能。

对于这里的 redirect 例子，有什么问题吗？

（沉默了一会）

好吧，我们时间快到了，我来总结一下。我们这节课：

- 看了一些 Unix I/O 和进程的接口和抽象。这里需要记住的是，接口是相对的简单，你只需要传入表示文件描述符的整数，和进程 ID 作为参数给相应的系统调用。而接口内部的实现逻辑相对来说是复杂的，比如创建一个新的进程，拷贝当前进程。
- 除此之外，我还展示了一些例子。通过这些例子你可以看到，尽管接口本身是简单的，但是可以将多个接口结合起来形成复杂的用例。比如说创建 I/O 重定向。

在下周结束之前，需要完成一个实验，这个实验中涉及更多类似于我们课堂上讲的简单小工具。好好做实验，我们下周再见。
