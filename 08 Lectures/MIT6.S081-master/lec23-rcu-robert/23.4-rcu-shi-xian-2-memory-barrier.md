# 23.4 RCU 实现(2) - Memory barrier

在前一部分介绍的方法中，存在一个问题。在前一部分中，如果要更新 E2 的内容，需要先创建一个 E2‘ 并设置好它的内容，然后将 E2’ 的 next 指针指向 E3，最后才会将 E1 的 next 指针指向 E2’。

![](<../assets/image (452).png>)

你们或许还记得在 XV6 中曾经介绍过（注，详见 10.8），许多计算机中都不存在“之后”或者“然后”这回事，通常来说所有的编译器和许多微处理器都会重排内存操作。如果我们用 C 代码表示刚才的过程：

![](<../assets/image (426).png>)

如果你测试这里的代码，它可能可以较好的运行，但是在实际中就会时不时的出错。这里的原因是编译器或者计算机可能会重排这里的写操作，也有可能编译器或者计算机会重排数据读取者的读操作顺序。如果我们在初始化 E2’的内容之前，就将 E1 的 next 指针设置成 E2‘，那么某些数据读取者可能就会读到垃圾数据并出错。

所以实现 RCU 的第二个部分就是数据读取者和数据写入者都需要使用 memory barriers，这里背后的原因是因为我们这里没有使用锁。对于数据写入者来说，memory barrier 应该放置在 committing write 之前，

![](<../assets/image (419).png>)

这样可以告知编译器和硬件，先完成所有在 barrier 之前的写操作，再完成 barrier 之后的写操作。所以在 E1 设置 next 指针指向 E2‘的时候，E2’必然已经完全初始化完了。

对于数据读取者，需要先将 E1 的 next 指针加载到某个临时寄存器中，我们假设 r1 保存了 E1 的 next 指针，之后数据读取者也需要一个 memory barrier，然后数据读取者才能查看 r1 中保存的指针。

![](<../assets/image (429).png>)

这里的 barrier 表明的意思是，在完成 E1 的 next 指针读取之前，不要执行其他的数据读取，这样数据读取者从 E1 的 next 指针要么可以读到旧的 E2，要么可以读到新的 E2‘。通过 barrier 的保障，我们可以确保成功在 r1 中加载了 E1 的 next 指针之后，再读取 r1 中指针对应的内容。

因为数据写入者中包含的 barrier 确保了在 committing write 时，E2’已经初始化完成。如果数据读取者读到的是 E2‘，数据读取者中包含的 barrier 确保了可以看到初始化之后 E2’的内容。

> 学生提问：什么情况下才可能在将 E1 的 next 指针加载到 r1 之前，就先读取 r1 中指针指向的内容？
>
> Robert 教授：我觉得你难住我了。一种可能是，不论 r1 指向的是什么，它或许已经在 CPU 核上有了缓存，或许一分钟之前这段内存被用作其他用途了，我们在 CPU 的缓存上有了 E1->next 对应地址的一个旧版本。我不确定这是不是会真的发生，这里都是我编的，如果 r1->x 可以使用旧的缓存的数据，那么我们将会有大麻烦。
>
> 说实话我不知道这个问题的答案，呵呵。我课下会想一个具体的例子。

以上是实现 RCU 的第二个部分。
