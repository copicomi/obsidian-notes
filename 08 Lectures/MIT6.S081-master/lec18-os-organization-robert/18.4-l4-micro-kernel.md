# 18.4 L4 micro kernel

今天要讨论的[论文](https://pdos.csail.mit.edu/6.828/2020/readings/microkernel.pdf)，有许多有关 L4 微内核的内容。这是今天论文作者开发和使用的一种微内核。L4 必然不是最早的微内核，但是从 1980 年代开始，它是最早一批可以工作的微内核之一，并且它非常能展现微内核是如何工作的。在许多年里面它一直都有活跃的开发和演进。如果你查看 Wikipedia，L4 有 15-20 个变种，有一些从 1980 年代开始开发的项目现在还存在。接下来我将从我的理解向你们解释 L4 在今天的论文发表的时候是如何工作的。

首先，L4 是微内核，它只有 7 个系统调用，虽然其中有一些稍微有点复杂，但是它还是只有 7 个系统调用。然而现在的 Linux，我上次数了下有大概 350 个系统调用。甚至 XV6 这个极其简单的内核，也有 21 个系统调用。从这个指标来看，L4 更加简单。

其次，L4 并不大，论文发表的时候，它只有 13000 行代码，这并不多。XV6 的代码更少，我认为 XV6 内核只有 6000-7000 行代码，所以作为内核 XV6 非常的简单。L4 也没有复杂太多，它只有 Linux 代码的几十分之一，所以它非常的小。

![](<../assets/image (106).png>)

第三，它只包含几个非常基础的抽象。

它在内部有一个叫做 Task 或者地址空间的概念，这或多或少的对应了 Uinx 内的进程概念。Task 包含了一些内存，地址从 0 开始，并且可以像进程一样执行指令。区别于 XV6 的是，每个 Task 可以有多个线程，L4 会调度每个 Task 内的多个线程的执行。这样设计的原因是，可以非常方便地用线程来作为组织程序结构的工具。我不知道在论文发表的时候，L4 是否支持了多处理器，或许它包含了在多个处理器上运行同一个程序的能力。所以 L4 内核知道 Task，知道线程，也知道地址空间，这样你就可以告诉 L4 如何映射地址空间内的内存 Page。

另一个 L4 知道的事情是 IPC。每一个线程都有一个标识符，其中一个线程可以说，我想要向拥有这个标识符的另一个线程发送几个字节。

这里的 Task，线程，地址空间，IPC 是 L4 唯一有的抽象。

![](<../assets/image (126).png>)

我不确定是否能列出所有的系统调用，这里涉及到的系统调用有：

- Threadcreate 系统调用，你提供一个地址空间 ID 并要求创建一个新的线程。如果地址空间或者 Task 不存在，系统调用会创建一个新的 Task。所以这个系统调用即可以创建线程，又可以创建 Task。
- Send/Recv IPC 系统调用。
- Mapping 系统调动可以映射内存 Page 到当前 Task 或者其他 Task 的地址空间中。你可以要求 L4 来改变当前 Task 的地址空间和 Page Table，如果你有足够的权限，你也可以要求 L4 改变其他 Task 的地址空间。这实际上是通过 IPC 完成的，你会发送一个特殊的 IPC 消息到目标线程，内核可以识别这个 IPC 消息，并会修改目标线程的地址空间。如果你创建一个先的线程，新线程最开始没有任何内存。所以如果你想创建一个线程，你先调用 Threadcreate 系统调用来创建新的线程，新的 Task 和地址空间。然后你创建一个特殊 IPC，将你自己内存中的一部分，其中包含了指令和数据，映射到新的 Task 的地址空间中。之后你再发送一个特殊的 Start IPC 消息到这个新的 Task，其中包含了你期望新的 Task 开始执行程序的程序计数器和 Stack Pointer。之后新的 Task 会在你设置好的内存中，从你要求的程序计数器位置开始执行。
- 虽然我不知道具体是怎么实现的，但是 Privileged Task 可以将硬件控制寄存器映射到自己的地址空间中。所以 L4 并不知道例如磁盘或者网卡的设备信息，但是实现了设备驱动的用户空间软件可以直接访问设备硬件。
- 你可以设置 L4 将任何一个设备的中断转换成 IPC 消息。这样，运行设备驱动的 Task 不仅可以读写了设备，并且也可以设置 L4 将特定设备的中断通过 IPC 消息发送给自己。
- 最后，一个 Task 可以设置 L4 内核通知自己有关另一个 Task 的 Page Fault。所以如果一个 Task 发生了 Page Fault，L4 会将 Page Fault 转换成一个 IPC 消息，并发送给另一个指定的 Pager Task。每一个 Task 都有个与之关联的 Pager Task 用来处理自己相关的 Page Fault。这就是关联到 Page Fault 的方法，通过它可以实现类似 copy-on-write fork 或者 lazy allocation。

![](<../assets/image (57).png>)

以上就是内核的内容，L4 里面不包含其他的功能，没有文件系统，没有 fork/exec 系统调用，除了这里非常简单的 IPC 之外，没有其他例如 pipe 的通信机制，没有设备驱动，没有网络的支持等等。任何其他你想要的功能，你需要以用户空间进程的方式提供。

L4 能提供的一件事情是完成线程间切换。L4 会完成线程调度和 context switch，来让多个线程共用一个 CPU。它实现的方式你会觉得非常熟悉，L4 会为每个 Task 保存寄存器，当它执行一个线程时，它会跳到用户空间，切换到那个线程对应 Task 的 Page Table，之后那个线程会在用户空间执行一会。之后或许会有一个定时器中断，定时器是 L4 知道的一个设备，定时器中断会使代码执行返回到 L4 内核，L4 会保存线程的用户寄存器，然后在一个类似于 XV6 的线程调度循环中，选择一个 Task 来运行。通过将这个 Task 之前保存的寄存器恢复出来，切换 Page Table，就可以跳转到 Task 中再运行一会，直到再发生另一个定时中断，或者当前 Task 出让了 CPU。所以我认为 L4 或许还有一个 yield 系统调用。在这种情况下 Task 可以等待接收一个 IPC 消息，这时代码会跳转回 L4 内核，L4 内核会保存寄存器，并切换到一个新的 Task。所以 L4 中有关线程切换的部分你们会非常熟悉。

我之前提到过这个概念，Pager。如果一个进程触发了 Page Fault，通过 trap 走到了内核，内核会将 Page Fault 转换成 IPC 消息并发送到指定的 Pager Task，并告诉 Pager Task 是哪个线程的哪个地址触发了 Page Fault。在 Pager Task 中，如果它实现了 lazy allocation，那么它会负责从 L4 分配一些内存，向触发 Page Fault 的 Task 发送一个特殊的 IPC，来恢复程序的运行。所以 Pager Task 实现了 XV6 或者 Linux 在 Page Fault Handler 中实现的所有功能。如果你想的话，你可以在 Pager Task 中实现 copy-on-write fork 或者 memory mapped files，Pager Task 可以实现基于 Page Fault 的各种技巧。

这是类似 L4 的微内核相比传统的内核，对于用户程序要灵活的多的众多例子之一。如果 Linux 并没有 copy-on-write fork，并且你想要有这个功能，你不可能在不修改内核的前提下完成这个功能。Linux 中没有办法写一些可移植的用户空间代码来实现 copy-on-write fork。这样描述可能并不完全正确，但是一定要这么做的话会很复杂。然而，在 L4 里面，这就相对简单了。L4 就好像是完全设计成让你去写用户空间代码来获取 Page Fault，并实现 copy-on-write fork。所有这些都可以在用户空间完成，而不用弄乱内核。

> 学生提问：能说明一下 Task 和线程之间的区别吗？
>
> Robert 教授：可以。一个 Task 就像 XV6 的一个进程一样，它有一些内存，一个地址空间，你可以在其中运行用户代码。如果你在 XV6 中有一个进程，它只能包含一个线程。但是在现代的操作系统和 L4 中，在一个进程，一个地址空间中，可以有多个线程。如果你有多个 CPU 核，那么多个 CPU 核可以同时运行一个 Task。每个线程在 Task 的地址空间中都有一个设置好的 Stack，这意味着你可以写一个程序，并通过并行运行在多个 CPU 核上得到性能的提升，其中的每个线程都运行在不同的 CPU 核上。

所以你们可以看到，这里的设计非常依赖 IPC，因为如果你想与你的文件系统交互，文件系统想要与设备驱动交互，你都需要来回发送 IPC 消息。对于每个系统调用，每个 Page Fault，每个设备中断，都会有反复的 IPC 消息。所以 IPC 系统需要非常快。
