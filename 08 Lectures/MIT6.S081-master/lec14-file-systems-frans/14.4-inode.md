# 14.4 inode

接下来我们看一下磁盘上存储的 inode 究竟是什么？首先我们前面已经看过了，这是一个 64 字节的数据结构。

- 通常来说它有一个 type 字段，表明 inode 是文件还是目录。
- nlink 字段，也就是 link 计数器，用来跟踪究竟有多少文件名指向了当前的 inode。
- size 字段，表明了文件数据有多少个字节。
- 不同文件系统中的表达方式可能不一样，不过在 XV6 中接下来是一些 block 的编号，例如编号 0，编号 1，等等。XV6 的 inode 中总共有 12 个 block 编号。这些被称为 direct block number。这 12 个 block 编号指向了构成文件的前 12 个 block。举个例子，如果文件只有 2 个字节，那么只会有一个 block 编号 0，它包含的数字是磁盘上文件前 2 个字节的 block 的位置。
- 之后还有一个 indirect block number，它对应了磁盘上一个 block，这个 block 包含了 256 个 block number，这 256 个 block number 包含了文件的数据。所以 inode 中 block number 0 到 block number 11 都是 direct block number，而 block number 12 保存的 indirect block number 指向了另一个 block。

![](<../assets/image (558).png>)

以上基本就是 XV6 中 inode 的组成部分。

基于上面的内容，XV6 中文件最大的长度是多少呢？

> 学生回答：会是 268\*1024 字节

是的，最大文件尺寸对应的是下面的公式。

![](<../assets/image (597).png>)

可以算出这里就是 268KB，这么点大小能存个什么呢？所以这是个很小的文件长度，实际的文件系统，文件最大的长度会大的多得多。那可以做一些什么来让文件系统支持大得多的文件呢？

> 学生回答：可以扩展 inode 中 indirect 部分吗？

是的，可以用类似 page table 的方式，构建一个双重 indirect block number 指向一个 block，这个 block 中再包含了 256 个 indirect block number，每一个又指向了包含 256 个 block number 的 block。这样的话，最大的文件长度会大得多（注，是 256\*256\*1K）。这里修改了 inode 的数据结构，你可以使用类似 page table 的树状结构，也可以按照 B 树或者其他更复杂的树结构实现。XV6 这里极其简单，基本是按照最早的 Uinx 实现方式来的，不过你可以实现更复杂的结构。实际上，在接下来的 File system lab 中，你将会实现双重 indirect block number 来支持更大的文件。

> 学生提问：为什么每个 block 存储 256 个 block 编号？
>
> Frans 教授：因为每个编号是 4 个字节。1024/4 = 256。这又带出了一个问题，如果 block 编号只是 4 个字节，磁盘最大能有多大？是的，2 的 32 次方（注，4TB）。有些磁盘比这个数字要大，所以通常人们会使用比 32bit 更长的数字来表示 block 编号。

在下一个 File system lab，你们需要将 inode 中的一个 block number 变成双重 indirect block number，这个双重 indirect block number 将会指向一个包含了 256 个 indirect block number 的 block，其中的每一个 indirect block number 再指向一个包含了 256 个 block number 的 block，这样文件就可以大得多。

![](<../assets/image (634).png>)

接下来，我们想要实现 read 系统调用。假设我们需要读取文件的第 8000 个字节，那么你该读取哪个 block 呢？从 inode 的数据结构中该如何计算呢？

> 学生回答：首先应该减去 12 个 direct block 的大小，然后再看在 indirect block 中的偏移量是多少。

对于 8000，我们首先除以 1024，也就是 block 的大小，得到大概是 7。这意味着第 7 个 block 就包含了第 8000 个字节。所以直接在 inode 的 direct block number 中，就包含了第 8000 个字节的 block。为了找到这个字节在第 7 个 block 的哪个位置，我们需要用 8000 对 1024 求余数，我猜结果是是 832。所以为了读取文件的第 8000 个字节，文件系统查看 inode，先用 8000 除以 1024 得到 block number，然后再用 8000 对 1024 求余读取 block 中对应的字节。

总结一下，inode 中的信息完全足够用来实现 read/write 系统调用，至少可以找到哪个 disk block 需要用来执行 read/write 系统调用。

接下来我们讨论一下目录（directory）。文件系统的酷炫特性就是层次化的命名空间（hierarchical namespace），你可以在文件系统中保存对用户友好的文件名。大部分 Unix 文件系统有趣的点在于，一个目录本质上是一个文件加上一些文件系统能够理解的结构。在 XV6 中，这里的结构极其简单。每一个目录包含了 directory entries，每一条 entry 都有固定的格式：

- 前 2 个字节包含了目录中文件或者子目录的 inode 编号，
- 接下来的 14 个字节包含了文件或者子目录名。

所以每个 entry 总共是 16 个字节。

![](<../assets/image (555).png>)

对于实现路径名查找，这里的信息就足够了。假设我们要查找路径名“/y/x”，我们该怎么做呢？

从路径名我们知道，应该从 root inode 开始查找。通常 root inode 会有固定的 inode 编号，在 XV6 中，这个编号是 1。我们该如何根据编号找到 root inode 呢？从前一节我们可以知道，inode 从 block 32 开始，如果是 inode1，那么必然在 block 32 中的 64 到 128 字节的位置。所以文件系统可以直接读到 root inode 的内容。

对于路径名查找程序，接下来就是扫描 root inode 包含的所有 block，以找到“y”。该怎么找到 root inode 所有对应的 block 呢？根据前一节的内容就是读取所有的 direct block number 和 indirect block number。

![](<../assets/image (594).png>)

结果可能是找到了，也可能是没有找到。如果找到了，那么目录 y 也会有一个 inode 编号，假设是 251，

![](<../assets/image (507).png>)

我们可以继续从 inode 251 查找，先读取 inode 251 的内容，之后再扫描 inode 所有对应的 block，找到“x”并得到文件 x 对应的 inode 编号，最后将其作为路径名查找的结果返回。

> 学生提问：有没有一些元数据表明当前的 inode 是目录而不是一个文件？
>
> Frans 教授：有的，实际上是在 inode 中。inode 中的 type 字段表明这是一个目录还是一个文件。如果你对一个类型是文件的 inode 进行查找，文件系统会返回错误。

很明现，这里的结构不是很有效。为了找到一个目录名，你需要线性扫描。实际的文件系统会使用更复杂的数据结构来使得查找更快，当然这又是设计数据结构的问题，而不是设计操作系统的问题。你可以使用你喜欢的数据结构并提升性能。出于简单和更容易解释的目的，XV6 使用了这里这种非常简单的数据结构。
