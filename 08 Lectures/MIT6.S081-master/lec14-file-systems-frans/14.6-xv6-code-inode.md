# 14.6 XV6 创建 inode 代码展示

接下来我们通过查看 XV6 中的代码，更进一步的了解文件系统。因为我们前面已经分配了 inode，我们先来看一下这是如何发生的。sysfile.c 中包含了所有与文件系统相关的函数，分配 inode 发生在 sys_open 函数中，这个函数会负责创建文件。

![](<../assets/image (494).png>)

在 sys_open 函数中，会调用 create 函数。

![](<../assets/image (565).png>)

create 函数中首先会解析路径名并找到最后一个目录，之后会查看文件是否存在，如果存在的话会返回错误。之后就会调用 ialloc（inode allocate），这个函数会为文件 x 分配 inode。ialloc 函数位于 fs.c 文件中。

![](<../assets/image (553).png>)

以上就是 ialloc 函数，与 XV6 中的大部分函数一样，它很简单，但是又不是很高效。它会遍历所有可能的 inode 编号，找到 inode 所在的 block，再看位于 block 中的 inode 数据的 type 字段。如果这是一个空闲的 inode，那么将其 type 字段设置为文件，这会将 inode 标记为已被分配。函数中的 log_write 就是我们之前看到在 console 中有关写 block 的输出。这里的 log_write 是我们看到的整个输出的第一个。

以上就是第一次写磁盘涉及到的函数调用。这里有个有趣的问题，如果有多个进程同时调用 create 函数会发生什么？对于一个多核的计算机，进程可能并行运行，两个进程可能同时会调用到 ialloc 函数，然后进而调用 bread（block read）函数。所以必须要有一些机制确保这两个进程不会互相影响。

让我们看一下位于 bio.c 的 buffer cache 代码。首先看一下 bread 函数

![](<../assets/image (433).png>)

bread 函数首先会调用 bget 函数，bget 会为我们从 buffer cache 中找到 block 的缓存。让我们看一下 bget 函数

![](<../assets/image (592).png>)

这里的代码还有点复杂。我猜你们之前已经看过这里的代码，那么这里的代码在干嘛？

> 学生回答：这里遍历了 linked-list，来看看现有的 cache 是否符合要找的 block。

是的，我们这里看一下 block 33 的 cache 是否存在，如果存在的话，将 block 对象的引用计数（refcnt）加 1，之后再释放 bcache 锁，因为现在我们已经完成了对于 cache 的检查并找到了 block cache。之后，代码会尝试获取 block cache 的锁。

所以，如果有多个进程同时调用 bget 的话，其中一个可以获取 bcache 的锁并扫描 buffer cache。此时，其他进程是没有办法修改 buffer cache 的（注，因为 bacche 的锁被占住了）。之后，进程会查找 block number 是否在 cache 中，如果在的话将 block cache 的引用计数加 1，表明当前进程对 block cache 有引用，之后再释放 bcache 的锁。如果有第二个进程也想扫描 buffer cache，那么这时它就可以获取 bcache 的锁。假设第二个进程也要获取 block 33 的 cache，那么它也会对相应的 block cache 的引用计数加 1。最后这两个进程都会尝试对 block 33 的 block cache 调用 acquiresleep 函数。

acquiresleep 是另一种锁，我们称之为 sleep lock，本质上来说它获取 block 33 cache 的锁。其中一个进程获取锁之后函数返回。在 ialloc 函数中会扫描 block 33 中是否有一个空闲的 inode。而另一个进程会在 acquiresleep 中等待第一个进程释放锁。

> 学生提问：当一个 block cache 的 refcnt 不为 0 时，可以更新 block cache 吗？因为释放锁之后，可能会修改 block cache。
>
> Frans 教授：这里我想说几点；首先 XV6 中对 bcache 做任何修改的话，都必须持有 bcache 的锁；其次对 block 33 的 cache 做任何修改你需要持有 block 33 的 sleep lock。所以在任何时候，release(\&bcache.lock)之后，b->refcnt 都大于 0。block 的 cache 只会在 refcnt 为 0 的时候才会被驱逐，任何时候 refcnt 大于 0 都不会驱逐 block cache。所以当 b->refcnt 大于 0 的时候，block cache 本身不会被 buffer cache 修改。这里的第二个锁，也就是 block cache 的 sleep lock，是用来保护 block cache 的内容的。它确保了任何时候只有一个进程可以读写 block cache。

如果 buffer cache 中有两份 block 33 的 cache 将会出现问题。假设一个进程要更新 inode19，另一个进程要更新 inode20。如果它们都在处理 block 33 的 cache，并且 cache 有两份，那么第一个进程可能持有一份 cache 并先将 inode19 写回到磁盘中，而另一个进程持有另一份 cache 会将 inode20 写回到磁盘中，并将 inode19 的更新覆盖掉。所以一个 block 只能在 buffer cache 中出现一次。你们在完成 File system lab 时，必须要维持 buffer cache 的这个属性。

> 学生提问：如果多个进程都在使用同一个 block 的 cache，然后有一个进程在修改 block，并通过强制向磁盘写数据修改了 block 的 cache，那么其他进程会看到什么结果？
>
> Frans 教授：如果第一个进程结束了对 block 33 的读写操作，它会对 block 的 cache 调用 brelse（block cache release）函数。

![](<../assets/image (607).png>)

> 这个函数会对 refcnt 减 1，并释放 sleep lock。这意味着，如果有任何一个其他进程正在等待使用这个 block cache，现在它就能获得这个 block cache 的 sleep lock，并发现刚刚做的改动。
>
> 假设两个进程都需要分配一个新的 inode，且新的 inode 都位于 block 33。如果第一个进程分配到了 inode18 并完成了更新，那么它对于 inode18 的更新是可见的。另一个进程就只能分配到 inode19，因为 inode18 已经被标记为已使用，任何之后的进程都可以看到第一个进程对它的更新。
>
> 这正是我们想看到的结果，如果一个进程创建了一个 inode 或者创建了一个文件，之后的进程执行读就应该看到那个文件。
