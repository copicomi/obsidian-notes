# 14.5 File system 工作示例

接下来我们看一下实际中，XV6 的文件系统是如何工作的，这部分内容对于下一个 lab 是有帮助的。

首先我会启动 XV6，这里有件事情我想指出。启动 XV6 的过程中，调用了 makefs 指令，来创建一个文件系统。

![](<../assets/image (615).png>)

所以 makefs 创建了一个全新的磁盘镜像，在这个磁盘镜像中包含了我们在指令中传入的一些文件。makefs 为你创建了一个包含这些文件的新的文件系统。

XV6 总是会打印文件系统的一些信息，所以从指令的下方可以看出有 46 个 meta block，其中包括了：

- boot block
- super block
- 30 个 log block
- 13 个 inode block
- 1 个 bitmap block

之后是 954 个 data block。所以这是一个袖珍级的文件系统，总共就包含了 1000 个 block。在 File system lab 中，你们会去支持更大的文件系统。

我还稍微修改了一下 XV6，使得任何时候写入 block 都会打印出 block 的编号。我们从 console 的输出可以看出，在 XV6 启动过程中，会有一些对于文件系统的调用，并写入了 block 33，45，32。

接下来我们运行一些命令，来看一下特定的命令对哪些 block 做了写操作，并理解为什么要对这些 block 写入数据。我们通过 echo “hi” > x，来创建一个文件 x，并写入字符“hi”。我会将输出拷贝出来，并做分隔以方便我们更好的理解。

![](<../assets/image (627).png>)

这里会有几个阶段

1. 第一阶段是创建文件
2. 第二阶段将“hi”写入文件
3. 第三阶段将“\n”换行符写入到文件

如果你去看 echo 的代码实现，基本就是这 3 个阶段。

![](<../assets/image (408).png>)

上面就是 echo 的代码，它先检查参数，并将参数写入到文件描述符 1，在最后写入一个换行符。

让我们一个阶段一个阶段的看 echo 的执行过程，并理解对于文件系统发生了什么。相比看代码，这里直接看磁盘的分布图更方便：

![](https://gblobscdn.gitbook.com/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MRhzbAZwhuzp63wWdRE%2F-MRielGcbrHOzPCrxHcO%2Fimage.png?alt=media&token=f685aafe-7c22-4965-9936-d811b090023d)

你们觉得的 write 33 代表了什么？我们正在创建文件，所以我们期望文件系统干什么呢？

> 学生回答：这是在写 inode。

是的，看起来给我们分配的 inode 位于 block 33。之所以有两个 write 33，第一个是为了标记 inode 将要被使用。在 XV6 中，我记得是使用 inode 中的 type 字段来标识 inode 是否空闲，这个字段同时也会用来表示 inode 是一个文件还是一个目录。所以这里将 inode 的 type 从空闲改成了文件，并写入磁盘表示这个 inode 已经被使用了。第二个 write 33 就是实际的写入 inode 的内容。inode 的内容会包含 linkcount 为 1 以及其他内容。

write 46 是向第一个 data block 写数据，那么这个 data block 属于谁呢？

> 学生回答：属于根目录。

是的，block 46 是根目录的第一个 block。为什么它需要被写入数据呢？

> 学生回答：因为我们正在向根目录创建一个新文件。

是的，这里我们向根目录增加了一个新的 entry，其中包含了文件名 x，以及我们刚刚分配的 inode 编号。

接下来的 write 32 又是什么意思呢？block 32 保存的仍然是 inode，那么 inode 中的什么发生了变化使得需要将更新后的 inode 写入磁盘？是的，根目录的大小变了，因为我们刚刚添加了 16 个字节的 entry 来代表文件 x 的信息。

最后又有一次 write 33，我在稍后会介绍这次写入的内容，这里我们再次更新了文件 x 的 inode， 尽管我们又还没有写入任何数据。

以上就是第一阶段创建文件的过程。第二阶段是向文件写入“hi”。

首先是 write 45，这是更新 bitmap。文件系统首先会扫描 bitmap 来找到一个还没有使用的 data block，未被使用的 data block 对应 bit 0。找到之后，文件系统需要将该 bit 设置为 1，表示对应的 data block 已经被使用了。所以更新 block 45 是为了更新 bitmap。

接下来的两次 write 595 表明，文件系统挑选了 data block 595。所以在文件 x 的 inode 中，第一个 direct block number 是 595。因为写入了两个字符，所以 write 595 被调用了两次。

第二阶段最后的 write 33 是更新文件 x 对应的 inode 中的 size 字段，因为现在文件 x 中有了两个字符。

> 学生提问：block 595 看起来在磁盘中很靠后了，是因为前面的 block 已经被系统内核占用了吗？
>
> Frans 教授：我们可以看前面 makefs 指令，makefs 存了很多文件在磁盘镜像中，这些都发生在创建文件 x 之前，所以磁盘中很大一部分已经被这些文件填满了。
>
> 学生提问：第二阶段最后的 write 33 是否会将 block 595 与文件 x 的 inode 关联起来？
>
> Frans 教授：会的。这里的 write 33 会发生几件事情：首先 inode 的 size 字段会更新；第一个 direct block number 会更新。这两个信息都会通过 write 33 一次更新到磁盘上的 inode 中。

以上就是磁盘中文件系统的组织结构的核心，希望你们都能理解背后的原理。
