# 14.3 How file system uses disk

接下来，我将简单的介绍最底层，也即是存储设备。实际中有非常非常多不同类型的存储设备，这些设备的区别在于性能，容量，数据保存的期限等。其中两种最常见，并且你们应该也挺熟悉的是 SSD 和 HDD。这两类存储虽然有着不同的性能，但是都在合理的成本上提供了大量的存储空间。SSD 通常是 0.1 到 1 毫秒的访问时间，而 HDD 通常是在 10 毫秒量级完成读写一个 disk block。

![](<../assets/image (421).png>)

这里有些术语有点让人困惑，它们是 sectors 和 blocks。

- sector 通常是磁盘驱动可以读写的最小单元，它过去通常是 512 字节。
- block 通常是操作系统或者文件系统视角的数据。它由文件系统定义，在 XV6 中它是 1024 字节。所以 XV6 中一个 block 对应两个 sector。通常来说一个 block 对应了一个或者多个 sector。

有的时候，人们也将磁盘上的 sector 称为 block。所以这里的术语也不是很精确。

这些存储设备连接到了电脑总线之上，总线也连接了 CPU 和内存。一个文件系统运行在 CPU 上，将内部的数据存储在内存，同时也会以读写 block 的形式存储在 SSD 或者 HDD。这里的接口还是挺简单的，包括了 read/write，然后以 block 编号作为参数。虽然我们这里描述的过于简单了，但是实际的接口大概就是这样。

![](<../assets/image (602).png>)

在内部，SSD 和 HDD 工作方式完全不一样，但是对于硬件的抽象屏蔽了这些差异。磁盘驱动通常会使用一些标准的协议，例如 PCIE，与磁盘交互。从上向下看磁盘驱动的接口，大部分的磁盘看起来都一样，你可以提供 block 编号，在驱动中通过写设备的控制寄存器，然后设备就会完成相应的工作。这是从一个文件系统的角度的描述。尽管不同的存储设备有着非常不一样的属性，从驱动的角度来看，你可以以大致相同的方式对它们进行编程。

有关存储设备我们就说这么多。

> 学生提问：对于 read/write 的接口，是不是提供了同步/异步的选项？
>
> Frans 教授：你可以认为一个磁盘的驱动与 console 的驱动是基本一样的。驱动向设备发送一个命令表明开始读或者写，过了一会当设备完成了操作，会产生一个中断表明完成了相应的命令。但是因为磁盘本身比 console 复杂的多，所以磁盘的驱动也会比我们之前看过的 console 的驱动复杂的多。不过驱动中的代码结构还是类似的，也有 bottom 部分和 top 部分，中断和读写控制寄存器（注，详见 lec09）。

从文件系统的角度来看磁盘还是很直观的。因为对于磁盘就是读写 block 或者 sector，我们可以将磁盘看作是一个巨大的 block 的数组，数组从 0 开始，一直增长到磁盘的最后。

![](<../assets/image (556).png>)

而文件系统的工作就是将所有的数据结构以一种能够在重启之后重新构建文件系统的方式，存放在磁盘上。虽然有不同的方式，但是 XV6 使用了一种非常简单，但是还挺常见的布局结构。

通常来说：

- block0 要么没有用，要么被用作 boot sector 来启动操作系统。
- block1 通常被称为 super block，它描述了文件系统。它可能包含磁盘上有多少个 block 共同构成了文件系统这样的信息。我们之后会看到 XV6 在里面会存更多的信息，你可以通过 block1 构造出大部分的文件系统信息。
- 在 XV6 中，log 从 block2 开始，到 block32 结束。实际上 log 的大小可能不同，这里在 super block 中会定义 log 就是 30 个 block。
- 接下来在 block32 到 block45 之间，XV6 存储了 inode。我之前说过多个 inode 会打包存在一个 block 中，一个 inode 是 64 字节。
- 之后是 bitmap block，这是我们构建文件系统的默认方法，它只占据一个 block。它记录了数据 block 是否空闲。
- 之后就全是数据 block 了，数据 block 存储了文件的内容和目录的内容。

![](<../assets/image (469).png>)

通常来说，bitmap block，inode blocks 和 log blocks 被统称为 metadata block。它们虽然不存储实际的数据，但是它们存储了能帮助文件系统完成工作的元数据。

> 学生提问：boot block 是不是包含了操作系统启动的代码？
>
> Frans 教授：完全正确，它里面通常包含了足够启动操作系统的代码。之后再从文件系统中加载操作系统的更多内容。
>
> 学生提问：所以 XV6 是存储在虚拟磁盘上？
>
> Frans 教授：在 QEMU 中，我们实际上走了捷径。QEMU 中有个标志位-kernel，它指向了内核的镜像文件，QEMU 会将这个镜像的内容加载到了物理内存的 0x80000000。所以当我们使用 QEMU 时，我们不需要考虑 boot sector。
>
> 学生提问：所以当你运行 QEMU 时，你就是将程序通过命令行传入，然后直接就运行传入的程序，然后就不需要从虚拟磁盘上读取数据了？
>
> Frans 教授：完全正确。

假设 inode 是 64 字节，如果你想要读取 inode10，那么你应该按照下面的公式去对应的 block 读取 inode。

![](<../assets/image (475).png>)

所以 inode0 在 block32，inode17 会在 block33。只要有 inode 的编号，我们总是可以找到 inode 在磁盘上存储的位置。
