# 14.7 Sleep Lock

block cache 使用的是 sleep lock。sleep lock 区别于一个常规的 spinlock。我们先看来一下 sleep lock。

![](<../assets/image (535).png>)

首先是 acquiresleep 函数，它用来获取 sleep lock。函数里首先获取了一个普通的 spinlock，这是与 sleep lock 关联在一起的一个锁。之后，如果 sleep lock 被持有，那么就进入 sleep 状态，并将自己从当前 CPU 调度开。

既然 sleep lock 是基于 spinlock 实现的，为什么对于 block cache，我们使用的是 sleep lock 而不是 spinlock？

> 学生回答：因为磁盘的操作需要很长的时间。

是的，这里其实有多种原因。对于 spinlock 有很多限制，其中之一是加锁时中断必须要关闭。所以如果使用 spinlock 的话，当我们对 block cache 做操作的时候需要持有锁，那么我们就永远也不能从磁盘收到数据。或许另一个 CPU 核可以收到中断并读到磁盘数据，但是如果我们只有一个 CPU 核的话，我们就永远也读不到数据了。出于同样的原因，也不能在持有 spinlock 的时候进入 sleep 状态（注，详见 13.1）。所以这里我们使用 sleep lock。sleep lock 的优势就是，我们可以在持有锁的时候不关闭中断。我们可以在磁盘操作的过程中持有锁，我们也可以长时间持有锁。当我们在等待 sleep lock 的时候，我们并没有让 CPU 一直空转，我们通过 sleep 将 CPU 出让出去了。

接下来让我们看一下 brelease 函数。

![](<../assets/image (613).png>)

brelease 函数中首先释放了 sleep lock；之后获取了 bcache 的锁；之后减少了 block cache 的引用计数，表明一个进程不再对 block cache 感兴趣；最后如果引用计数为 0，那么它会修改 buffer cache 的 linked-list，将 block cache 移到 linked-list 的头部，这样表示这个 block cache 是最近使用过的 block cache。这一点很重要，当我们在 bget 函数中不能找到 block cache 时，我们需要在 buffer cache 中腾出空间来存放新的 block cache，这时会使用 LRU（Least Recent Used）算法找出最不常使用的 block cache，并撤回它（注，而将刚刚使用过的 block cache 放在 linked-list 的头部就可以直接更新 linked-list 的 tail 来完成 LRU 操作）。为什么这是一个好的策略呢？因为通常系统都遵循 temporal locality 策略，也就是说如果一个 block cache 最近被使用过，那么很有可能它很快会再被使用，所以最好不要撤回这样的 block cache。

以上就是对于 block cache 代码的介绍。这里有几件事情需要注意：

- 首先在内存中，对于一个 block 只能有一份缓存。这是 block cache 必须维护的特性。
- 其次，这里使用了与之前的 spinlock 略微不同的 sleep lock。与 spinlock 不同的是，可以在 I/O 操作的过程中持有 sleep lock。
- 第三，它采用了 LRU 作为 cache 替换策略。
- 第四，它有两层锁。第一层锁用来保护 buffer cache 的内部数据；第二层锁也就是 sleep lock 用来保护单个 block 的 cache。

![](<../assets/image (530).png>)

最后让我们来总结一下，并把剩下的内容留到下节课。

- 首先，文件系统是一个位于磁盘的数据结构。我们今天的主要时间都用来介绍这个位于磁盘的数据结构的内容。XV6 的这个数据结构实现的很简单，但是你可以实现一个更加复杂的数据结构。
- 其次，我们花了一些时间来看 block cache 的实现，这对于性能来说是至关重要的，因为读写磁盘是代价较高的操作，可能要消耗数百毫秒，而 block cache 确保了如果我们最近从磁盘读取了一个 block，那么我们将不会再从磁盘读取相同的 block。

![](<../assets/image (513).png>)

下节课我将会介绍 crash safety，这是文件系统设计中非常棒的一部分。我们将会在 crash safety 讲两节课。下节课我们会看到基于 log 实现的 crash safety 机制，下下节课我们会看到 Linux 的 ext3 是如何实现的 logging，这种方式要快得多。

> 学生提问：我有个关于 brelease 函数的问题，看起来它先释放了 block cache 的锁，然后再对引用计数 refcnt 减一，为什么可以这样呢？
>
> Frans 教授：这是个好问题。如果我们释放了 sleep lock，这时另一个进程正在等待锁，那么 refcnt 必然大于 1，而 b->refcnt --只是表明当前执行 brelease 的进程不再关心 block cache。如果还有其他进程正在等待锁，那么 refcnt 必然不等于 0，我们也必然不会执行 if(b->refcnt == 0)中的代码。
