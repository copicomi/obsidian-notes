# Virtual Memory Primitives for User Programs
[[appel-li.pdf]]

## Abstract
OS 通常采用地址管理单元 MMU 来管理分页内存和读写权限，以提供对用户进程的隔离性，但是性能有时不尽人意，本文探讨虚拟内存原语的设计，与现代 OS 对该功能的实现方式

## 1 Introduction
为用户提供远超物理大小的虚拟空间假象，这是该机制的一个目的，但不仅限于此，通过虚拟内存引发的页错误机制，我们可以实现诸如 Copy-on-write 这样的 Trick，也可以实现进程间内存的共享

page fault 不只是异常，它可以作为开发者实现系统机制的一种工具

本文以现存系统为例，描述了几种利用该技术的算法，并分析了性能代价

## 2 Virtual memory primitives
为描述算法，我们提供以下操作：
1. `Trap`：处理 page-fault
2. `Port1`：减少 1 个页
3. `PortN`：减少 N 个页
4. `Unport`：增加页
5. `Dirty`：返回脏页序列
6. `Map`：将一个物理页映射到同一空间下的多个虚拟地址（保护等级不同）

对于多线程程序，存在临界区问题，可以通过*将一个页映射到多个虚拟地址，并保持页访问的互斥性*来实现

## 3 Virtual memory applications
这一部分将讨论 vm（virtual memory） 原语，在软件测试、特殊硬件和宏方面 的应用

### Concurrent garbage collection
Page-fault 可用于实现垃圾收集算法，处理 collecter 与用户线程之间的中粒度同步，下面介绍 *Baker 收集算法*

> [Baker算法介绍](http://zhuanlan.zhihu.com/p/483720899)

将空间分为 from-space 和 to-space，前者存放历史快照，一旦某个对象被重用，表示仍存在引用，就 copy 到 to-space

申请内存时，就从旧版本的 garbage 块分配，同样存到 to-space 

这样 to-space 中的所有*有效*指针就代表当前已分配的空间

当 from-space 空间不足时，将其与 to-space 交换地位，to-space 作为新的快照

交换后扫描所有块的可达性，仍旧有效的，放到新的 to-space，无效的作为 garbage 分配块

每次交换 space，都需要从头扫描整个空间，*集中*计算，这会长时间阻塞用户进程

Baker 算法在此基础上*均摊*了扫描的时间，当用户申请内存时，不仅仅只是分配 garbage，同时还会对现存指针进行部分 scan，提前舍弃失效空间

采用线性指针，当分配指针与 scan 指针重合时，表示原空间既没有能分配的空间，也没有需要扫描的指针了，此时直接交换两个空间即可

这样，collector在用户申请空间时，偷偷干私活，稍微增加了用户的实时延迟，但是却避免了集中处理导致的大段阻塞

---
Baker 算法下，collector 和 mutator 对于同一块空间的视图是不同的，相比之下 collector 有更高的操作权限，这一点通过将一个物理地址映射到两个不同进程的虚拟进程实现

在 mutator 中，只能使用 scanned 页，访问 unscanned 页会导致 *page fault*，此时引入 collector 进行处理，将失效或有效的指针进行处理，标记为 scanned 页，然后再让 mutator 合法访问

引入 VM 将这种机制的处理隐藏起来，并且由于映射到的地址是同一块，天然满足内容*一致性*

### Shared virtual memory
在分布式系统中，VM 技术被用来实现共享内存，解决 *读者-写者同步* 问题

一个 page 可以同时被多人 read，但不能同时 write，因此写入行为发生时，将通知全系统的节点 *该页为 dirty*

当进程读入 *dirty页* 时，会引发 page-fault，从其他节点获取最新版本（*up-to-date*) 后，才可进行操作

### Concurrent checkpointing
做系统时有版本持久化的需求，这时候引入 checkpoint，但复制快照的进程集中处理的话，与 GC 的问题一样，导致阻塞

因此设计使 copy 进程与用户进程并发执行

复制时，将全部页置为只读权限，然后重启用户进程，在后台执行 copy 进程

当用户想 write 一个只读页时，引发 page-fault，copy 进程优先复制该页到新空间，并允许写入权限，用户进程正常运行

这就实现了进程并发

### Generational garbage collection
对于垃圾收集的情景，有两点经验；
1. 旧 record 存活的时间往往更久，释放概率不大
2. 新 record 大多会沿用旧 record 的指针

依照这点，将内存按块分为不同的 generation，优先检查新 gengration

然而，可能有 old G 指向 new G，就不能释放后者了，这种情况是少数，采用 page-fault 机制探查

在划分 newG 时，将 oldG 标记为只读，如果要修改 oldG，就触发 page-fault，将其加入 探测 list，每次 collector 进程工作时都会检查该 list

### Persistent store
处理数据严格的业务时，需要定期 commit，以保证数据的可靠性，但又不能每次都直接写入 disk

因此采用 *memory-map* ，将磁盘映射到内存，每次 commit 时，对 dirty page 引发 page-fault，写回到 disk

这种设计，避免了每次都要强制写入的成本，也不需要调用函数的时间，同时又在底层提供了一定的同步性，与 database 的需求相当吻合

### Extending addressability
面临大量数据对象的场景，现有的 32 位 pointer 不足以索引对象，此时需要扩展 64 位 pointer

磁盘存 64 位的，内存用 32 位的，读入时，维护一个 64 到 32 位地址的映射表

空间占满时，就替换现有的映射对，此时触发 page-fault，从磁盘中读入正确页，并更新映射

### Data-compression paging
压缩内存，替换 page 时，将内容压缩，就不用写回磁盘了，当访问其内存时，引发 page-fault，解压后再访问

### Heap overflow detection
采用 guard page 引发page-fault 来探测溢出，同理对 GC 进程也可以判断 scan end

具体性能受 Trap 频率影响

## 4 VM primitive performance
(性能分析部分，略读)
## 5 System design issues

### TLB Consistency
TLB 缓存，加速地址翻译
### Optional page size
可选页大小，对大文件使用 super page
### Access to protected pages
采用 page-fault 机制，实现一些功能，能够避免上下文切换和复杂逻辑
### Is this too much to ask?
### Other primitives

## 6 Conclusions
VM 机制的应用很广泛，并且本文描述的多个算法都具有不少的机制共同点，随着硬件发展，VM的潜力会显示出来