可靠数据传输
reliable date transfer

---

[[rdt]]: reliable date transfer

TCP 为上层提供可靠的信道抽象，以下层的不可靠信道为接口，开发协议，实现可靠数据传输

本节仅考虑*单向数据传输*，假设信息不会乱序到达

### 构造可靠数据传输协议

现在我们从理想情况出发，一步步放宽假设，逐步构建协议

#### 1. 最理想：信道完全可靠【rdt1.0】

我们以有限状态机（FSM，Finite-State Machine）来描述协议

记发送端为 sh（send host），接收端为 rh（recieve host）

sh 和 rh 的 FSM 只有一个状态，永远循环

由于信道完全可靠，所以机械地处理信息就可以

#### 2. 处理比特差错【rdt2.0】

可能发送 0，收到 1

这种情况下，需要 sh 进行数据重传

- sh 如何得知何时重传？
	- rh 收到分组后，应给予确认回复
		- 若 sh 收到肯定确认，不再重传
		- sh 收到否定确认，重传

基于这种重传机制的 RDT 称为 *自动重传请求协议（ARQ，Automatic Repeat reQuest)*

ARQ 应实现的服务：
1. 差错检测
2. 接收方反馈
	-  **ACK** 标记 肯定确认 acknowledge
	-  **NAK** 标记 否定确认
3. 发送方重传

sh 的 FSM 有两个状态：
1. 等待上层的指示
	- 发送信息，变为状态 `2`
2. 已发送信息，等待 rh 的确认反馈
	- `ACK` ：结束等待，回到状态 `1`
	- `NAK` ：重传分组，等待 rh 的新反馈，留在状态 `2`

sh 这种一直等待 rh 反馈的行为，被称为*停等协议*

rh FSM 状态：
1. 等待下层的信息
	- 接收信息
	- 差错检测
		- 无误，发送 `ACK` 信号
		- 有误，发送 `NAK` 信号，要求重传
	- 留在状态 `1`

rdt2.0 存在一个致命的缺陷：发回的**确认信号**也可能出错

考虑如何处理 受损的 ACK 与 NAK：
1. sh 无法识别 rh 的回复，因此询问 rh ，要求重传她的回复，但 sh 的要求回复又可能出错，导致 rh 开始迷惑，这种情况陷入一种纠缠不清的境地，**不可行**
2. rh 在回复时，增加**足够多的校验**信息，使得 sh 不仅能检测差错，而且能够自助地修正差错，对于不丢包的信道可以解决问题
3. sh 不再费心思考虑 rh 的真实想法，直接从头来过，**重传**整个数据分组
	- 产生冗余分组：rh 不明白，明明已经给出了 ACK，却收到了与上次一模一样的包，这个包，到底是 rh 自己想要的新分组，还是 sh 没有听到 ACK，自作主张发送的重传分组，双方缺乏交流，导致歧义
	- 解决歧义问题的方式很简单：
		- 在首段添加 segment 的**序号**即可
		- 有了双方的共同约定，包的语义不会被混淆

要分辨是重传包还是新包，只需要一个 bit 位即可

如果 sh 发送了一个 0 包，rh 却表示收到了一个 1 包，给出 ACK 确认，那么就能判断发生了反馈失传

rdt2.1 和 rdt2.2 就采用这种设计，FSM 的状态数也相应地翻倍，FSM 状态增加了一维，表示当前期望得到 0 包还是 1 包

不再给出 FSM 的详细描述

记期望包号为 sn（segment number）

假设 rh 的回复要么是 ACK 或 NAK，要么是含糊不清的

对 rdt2.1
- 该协议收到失序分组时发送 `ACK`，错误分组发送 `NAK`
- *发送有误分组的 `ACK`，与发送 `NAK` 等效*
- sh 收到的 rh 回答 A 含糊不清，选择重传 0 包，下次回答有这些情况
	1. sh 收到 rh 回答 `ACK 0` 、`NAK 0`
		- 说明 rh 之前的回答 A 是要求重传 0 包 `NAK 0`
		- 正常运行
	2. sh 收到 rh 回答 `ACK 1`
		- 说明 rh 之前的回答 A 是成功收到 0 包 `ACK 0`
		- sh 明白自己传了一个冗余包，补救错误
		- rh 也知道 sh 传错了包，对失序包回答 `ACK`，但知道自己下一个还是想要一个 1 包
	3. sh 收到 rh 回答 `NAK 1`
		- sh 多传了一个错包
		- 同上，sh 和 rh 都知道该怎么做


rdt2.2 与 rdt2.1 的设计大致相同，只不过舍弃了 `NAK` 信号，用等效的 `ACK bit` 信号替代 `NAK`

FSM rdt2.2 的特性可以概括为：
1. rh 发了 `ACK 0`，下一个就要传 1 包
2. rh 发了 `ACK 1`，下一个就要传 0 包
3. rh 收不到 1 包，就一直发 `ACK 0`
4. rh 收不到 0 包，就一直发 `ACK 1`
5. sh 和 rh 一旦收到错包，就一直在原状态循环等待

如果 rh 想要 1 包，sh 却一直发 0 包呢？
- 必须证明这种情况不可能存在：
	- *如果 rh 想要 1 包，那么它一定会回答 `ACK 0`*
	- sh 收到 `ACK 0` **认为 rh 收到 0 包**了，于是准备发 1 包
	- 而 rh 只是**欺骗 sh 收到 0 包**
	- 实际 sh 发送的 0 包早就被 rh **丢弃**
	- 因此不存在冗余分组的问题
- 所以 sh 不可能一直发 0 包，证毕

至此完成 rdt2.2 的设计与检验

#### 3. 处理丢包信道【rdt3.0】

如何检测丢包
- 让发送方检测：
	- 如果一段时间后，始终收不到对应分组的 ACK 回应，认为丢包
- 然后发送方采用它的万能灵药：重传
- 实现基于时间的重传机制，发送方需要做到：
	1. 每次发送分组后，启动一个计时器
	2. 响应计时器中断
	3. 终止计时器

rdt3.0 的 FSM 设计：
- 状态同 rdt2.2
- 当且仅当发生超时 `timeout` 时才重传包
- sh 收到想要的 `ACK` 回复时，就终止计时器，转移状态
- sh 收到不想要的 `ACK` 时，什么也不做，把重传任务交给 `timeout`

分组序号在 0/1 间交替，rdt3.0 被称为 *比特交替协议*

---
