

---

[[rdt]]: reliable date transfer

TCP 为上层提供可靠的信道抽象，以下层的不可靠信道为接口，开发协议，实现可靠数据传输

本节仅考虑*单向数据传输*，假设信息不会乱序到达

### 构造可靠数据传输协议

现在我们从理想情况出发，一步步放宽假设，逐步构建协议

#### 1. 最理想：信道完全可靠【rdt1.0】

我们以有限状态机（FSM，Finite-State Machine）来描述协议

记发送端为 sh（send host），接收端为 rh（recieve host）

sh 和 rh 的 FSM 只有一个状态，永远循环

由于信道完全可靠，所以机械地处理信息就可以

#### 2. 处理比特差错【rdt2.0】

可能发送 0，收到 1

这种情况下，需要 sh 进行数据重传

- sh 如何得知何时重传？
	- rh 收到分组后，应给予确认回复
		- 若 sh 收到肯定确认，不再重传
		- sh 收到否定确认，重传

基于这种重传机制的 RDT 称为 *自动重传请求协议（ARQ，Automatic Repeat reQuest)*

ARQ 应实现的服务：
1. 差错检测
2. 接收方反馈
	-  **ACK** 标记 肯定确认 acknowledge
	-  **NAK** 标记 否定确认
3. 发送方重传

sh 的 FSM 有两个状态：
1. 等待上层的指示
	- 发送信息，变为状态 `2`
2. 已发送信息，等待 rh 的确认反馈
	- `ACK` ：结束等待，回到状态 `1`
	- `NAK` ：重传分组，等待 rh 的新反馈，留在状态 `2`

sh 这种一直等待 rh 反馈的行为，被称为*停等协议*

rh FSM 状态：
1. 等待下层的信息
	- 接收信息
	- 差错检测
		- 无误，发送 `ACK` 信号
		- 有误，发送 `NAK` 信号，要求重传
	- 留在状态 `1`

rdt2.0 存在一个致命的缺陷：发回的**确认信号**也可能出错

考虑如何处理 受损的 ACK 与 NAK：
1. sh 无法识别 rh 的回复，因此询问 rh ，要求重传她的回复，但 sh 的要求回复又可能出错，导致 rh 开始迷惑，这种情况陷入一种纠缠不清的境地，**不可行**
2. rh 在回复时，增加**足够多的校验**信息，使得 sh 不仅能检测差错，而且能够自助地修正差错，对于不丢包的信道可以解决问题
3. sh 不再费心思考虑 rh 的真实想法，直接从头来过，**重传**整个数据分组
	- 产生冗余分组：rh 不明白，明明已经给出了 ACK，却收到了与上次一模一样的包，这个包，到底是 rh 自己想要的新分组，还是 sh 没有听到 ACK，自作主张发送的重传分组，双方缺乏交流，导致歧义
	- 解决歧义问题的方式很简单：
		- 在首段添加 segment 的**序号**即可
		- 有了双方的共同约定，包的语义不会被混淆

要分辨是重传包还是新包，只需要一个 bit 位即可

如果 sh 发送了一个 0 包，rh 却表示收到了一个 1 包，给出 ACK 确认，那么就能判断发生了反馈失传

rdt2.1 和 rdt2.2 就采用这种设计，FSM 的状态数也相应地翻倍，FSM 状态增加了一维，表示当前期望得到 0 包还是 1 包

不再给出 FSM 的详细描述

记期望包号为 sn（segment number）

假设 rh 的回复要么是 ACK 或 NAK，要么是含糊不清的

对 rdt2.1
- 该协议收到失序分组时发送 `ACK`，错误分组发送 `NAK`
- *发送有误分组的 `ACK`，与发送 `NAK` 等效*
- sh 收到的 rh 回答 A 含糊不清，选择重传 0 包，下次回答有这些情况
	1. sh 收到 rh 回答 `ACK 0` 、`NAK 0`
		- 说明 rh 之前的回答 A 是要求重传 0 包 `NAK 0`
		- 正常运行
	2. sh 收到 rh 回答 `ACK 1`
		- 说明 rh 之前的回答 A 是成功收到 0 包 `ACK 0`
		- sh 明白自己传了一个冗余包，补救错误
		- rh 也知道 sh 传错了包，对失序包回答 `ACK`，但知道自己下一个还是想要一个 1 包
	3. sh 收到 rh 回答 `NAK 1`
		- sh 多传了一个错包
		- 同上，sh 和 rh 都知道该怎么做


rdt2.2 与 rdt2.1 的设计大致相同，只不过舍弃了 `NAK` 信号，用等效的 `ACK bit` 信号替代 `NAK`

FSM rdt2.2 的特性可以概括为：
1. rh 发了 `ACK 0`，下一个就要传 1 包
2. rh 发了 `ACK 1`，下一个就要传 0 包
3. rh 收不到 1 包，就一直发 `ACK 0`
4. rh 收不到 0 包，就一直发 `ACK 1`
5. sh 和 rh 一旦收到错包，就一直在原状态循环等待

如果 rh 想要 1 包，sh 却一直发 0 包呢？
- 必须证明这种情况不可能存在：
	- *如果 rh 想要 1 包，那么它一定会回答 `ACK 0`*
	- sh 收到 `ACK 0` **认为 rh 收到 0 包**了，于是准备发 1 包
	- 而 rh 只是**欺骗 sh 收到 0 包**
	- 实际 sh 发送的 0 包早就被 rh **丢弃**
	- 因此不存在冗余分组的问题
- 所以 sh 不可能一直发 0 包，证毕

至此完成 rdt2.2 的设计与检验

#### 3. 处理丢包信道【rdt3.0】

如何检测丢包
- 让发送方检测：
	- 如果一段时间后，始终收不到对应分组的 ACK 回应，认为丢包
- 然后发送方采用它的万能灵药：重传
- 实现基于时间的重传机制，发送方需要做到：
	1. 每次发送分组后，启动一个计时器
	2. 响应计时器中断
	3. 终止计时器

rdt3.0 的 FSM 设计：
- 状态同 rdt2.2
- 当且仅当发生超时 `timeout` 时才重传包
- sh 收到想要的 `ACK` 回复时，就终止计时器，转移状态
- sh 收到不想要的 `ACK` 时，什么也不做，把重传任务交给 `timeout`

分组序号在 0/1 间交替，rdt3.0 被称为 *比特交替协议*

---

---

### 回退 N 步

GBN 协议，限制流水线中未确认的分组不能超过 N 个，因此 GBN 也被称为 *滑动窗口协议*

GBN 也可用 FSM 描述

下面给出 GBN sh 对事件的响应策略：
1. 上层的调用
	- 首先检查窗口是否已满
		- 若满，返回，指示上层稍后再试
		- 不满，发送分组并更新变量
	- 也可限制上层仅在窗口不满时，才可发送信息
2. 收到一个`ACK`
	- 对序号为 `n` 的分组采取*累计确认*
3. 超时
	- 回退 N 步，重传所有仍未确认的分组

GBN rh：
- 收到序号 `n`，如果有序到达（前一个收到`n-1`），则正常接收
- 否则丢弃该包，回答最后一个按序到达的包的 `ACK`
- 只要失序，就丢弃
	- 这种策略浪费了正确发送的包，是有理由的
	- 数据必须按序交付，保留失序包的代价可能更大
	- 优点是
		- 缓存简单，维护信息少

GBN 的工作过程中，每收到一个连续的`ACK`便向前滑动窗口，发送新分组

GBN 的这种实现方式被叫做*基于事件编程*

---
### 选择重传

尽管 GBN 协议充分利用了空余信道，但由于会丢弃失序分组，可能会造成大量的不必要重传

*选择重传协议（SR）* 让发送方仅重传那些它怀疑再接收方出错的分组，避免不必要的重传

SR sh 会缓存收到的 `ACK` 信号 *（不论是否有序）*
SR rh 会缓存收到的无序分组，直到有序分组到达才交付给上层

SR 的事件与 GBN 相似，但具备了缓存数据和 ACK 信号的功能
- 最大的区别是：
	- SR rh 在收到窗口内的无序分组后，不会选择丢弃，而是发送对应的 `ACK` 信号，并缓存到本地，等待有序分组到达再交付

当 多个 `ACK` 回答丢包时，sh 会尝试重传所有分组，
但是 rh 已经在缓存里收到这些分组，并且**已经移动了窗口**

此时产生 sh 与 rh 间的窗口**不同步**，这是致命的

为解决同步问题，在 rh 端应当处理这种情况：
- 当 sh 发送了一个早已滑过的上一窗口的分组时，**rh 仍要回答 `ACK` 信号**，以使得 sh 滑动本地的窗口，完成同步

此外还有一个限制：**窗口长度必须不大于序号空间大小的一半**

由于序号是模运算，当 sh 窗口 和 rh 窗口 中均包含同一个序号时，若窗口过大，很可能出现歧义：
- sh 中 包含 `x + N` 包，rh 中 包含 `x + N` 包，sh 发送新包 `x + N`，序号为 `x`
- sh 中 包含 `x` 包，rh 中 包含 `x + N` 包，`x` 包已经收到，但是 `ACK x` 信号丢包，此时 sh 认为 rh 没有收到 `x` 包，发送重传包 `x`，序号也为 `x`
- 此时 rh 无法分布 sh 是重传包还是新包

因此 sh 和 rh 的窗口大小之和，绝对不能超过序号空间大小，否则对于模`N`运算会有歧义

---

最后，我们放松对于分组到达顺序的假设，认为分组可能以乱序到达

这种情况下，可能一个无用的重传包可能会最后到达，导致和新包的混淆，此时它并不在滑动窗口中，我们怎么消灭它是一个旧包的可能性呢？

实际采用的方法是，假定一个 `x` 包，在网络中的存活时间有一个上限，在全部旧包死亡前，不冒任何使用 `x` 序号的风险

即如果不能确保旧包全部死亡，就不接受任何新包的操作

在 TCP 中认为存活寿命为 3 分钟

用到的机制：
1. 检验和
2. 定时器
3. 序号
4. 确认
5. 否定确认
6. 窗口、流水线

---

