传输控制协议 Transmission Control Protocol

---
### TCP 连接

TCP 是面向连接的，但不是物理意义上的，而是逻辑连接
TCP 协议只在端系统中运行，中间的网络元素不会位置 TCP 连接状态

点对点、双向、三次握手、数据缓存

TCP 的组成包括：
1. 发送缓存 和 接收缓存
2. 变量
	- MSS ：最大报文段长度，典型值为 1460 Byte
3. 与进程连接的套接字
---
### TCP 报文段结构

1. 源端口号、目的端口号、校验和
2. 序号字段、确认号字段
	- 用于可靠数据传输
3. 接收窗口字段
	- 用于流量控制
4. 首部长度字段
5. 选项字段
6. 标志字段
	- ACK
	- RST、SYN、FIN
	- CWR、ECE
	- PSH
	- URG

#### 序号和确认号

TCP 给每个字节编号，并认为某个报文段的序号就是其首字节的编号
*TCP 把数据看作 无结构的、有序的 字节流*

确认号字段，填写 rh 希望从 sh 得到的下一个包的序号

对于失序包的处理方式，由 TCP 的编程人员自行决定

---
### 往返时间的估计与超时

TCP 采用超时重传机制处理丢包，带来以下问题：
1. 超时间隔应设置为多大？
2. 起初如何估计往返时间 RTT ？
3. 是否要为所有报文设定计时器？

#### 估计往返时间

每隔一段时间，测量一次样本 RTT（SampleRTT），用样本估计 RTT

由于 SampleRTT 具有波动性，因此采用**指数加权移动平均（EWMA）**

TCP 维护一个 RTT 均值（EstimatedRTT）

每次测量，用
$$
	EstimatedRTT = (1 - \alpha) \times Estimated RTT + \alpha \times SampleRTT
$$
更新 RTT，推荐 $\alpha = 0.125$


RTT 偏差 DevRTT 用下式计算：

$$
DevRTT = (1 - \beta) \times DevRTT + \beta \times \lvert SampleRTT - EstimatedRTT \rvert
$$

推荐 $\beta = 0.25$

#### 设置和管理重传超时间隔

超时间隔设为：
$$
TimeoutInterval = EstimatedRTT + 4 \times DevRTT
$$
推荐初始超时间隔为 $1s$
超时后 TI 将翻倍，在 ERTT更新时重置

###  [[可靠数据传输]]

TCP 仅使用单一计时器，以节省开销

与重传有关的三个事件：
1. 上层调用接口
	- 生成 TCP segment
	- 启动定时器
	- 发送 segment
2. 计时器超时
	- 重传最小序号但未应答的segment
	- 启动定时器
3. 收到 rh 的 ACK 信号
	- 累积确认 segment
	- 若仍有未确认的 segment，启动计时器

#### 一些有趣的情况

1. 确认丢失，可能会导致超时重传
2. 连续发送两个报文
	- 确认 1 和 2 都超时到达，导致 1 包重传，重置计时器
	- 第二个超时间隔内，确认 2 到达，sh 不会重传 2 包
3. 连续发送两个报文
	- 确认 1 丢失，但确认 2 在超时前到达
	- 由于累积确认，sh 收到确认 2，了解 rh 成功接收 1 包和 2 包
	- sh 不会重传任何包

#### 超时间隔加倍

每次重传，sh 将 TimeoutInterval 翻倍，成指数型增长

理由是：超时可能是由网络拥塞造成，过多的重传反而会加重拥塞，需要限制重传次数

#### 快速重传

当超时间隔过长时，一个 1ms 前早就丢失的包，却要继续等待 1000ms 的超时周期结束时才能重传

针对这种情况，采用**冗余 ACK** 检测丢包

当 rh 收到一个失序包时，推测 sh 有丢包，此时 rh 发送一个冗余 ACK

失序 ACK 也可能是数据在网络中自然更改了顺序，所有一个冗余 ACK 不足以让 sh 确信有丢包

故 sh 在收到 3 个相同的 冗余 ACK 后，才断言出现丢包，执行**快速重传**，此时不需要等待计时器超时

#### 是回退 N 步还是选择重传

TCP 是一个 GBN 协议，还是一个 SR 协议？

一方面，TCP 采用累计确认，只维护 rh 接受的边界序号与下一个要发送的序号，具有 GBN 风格

另一方面，有许多 TCP 采用 rh 缓存失序分组

当数据全部正确按序到达，仅仅丢失了 rh 对第一个包 0 包的 `ACK` 信号时
- GBN sh 采用累积确认，会忽略其余所有成功发送的 `ACK` 信号，一次超时就重传所有 N 包
- 而 TCP sh **一次只重传一个包**，在重传完 0 包后，rh 会反馈已经收到了所有 N 个包，因此 sh 只会重传 0 包
- 对于 TCP sh，若超时前，其余 `ACK` 信号先一步到达，sh 甚至不会重传 0 包，而 GBN 的滑动窗口策略，导致其只会忽略这些信号

一种对 TCP 的建议是，采用**选择确认**
选择性地 ACK 一部分失序包的序号，在重传时可以跳过这些包，这样就具备了一些 SR 协议的属性

因此 TCP 协议可以被认为是二者的混合体 

---
### 流量控制

由于 sh 与 rh 中缓存的存在，我们需要考虑缓存溢出的问题，进而设计**流量控制服务**

*流量控制实际是一个速度匹配服务*

当 网络层 出现拥塞时，sh 会一直延长超时间隔，这种情况下的控制被称为**拥塞控制**

这两种控制是针对不同原因采取的控制

我们在 sh 和 rh 两端维护一个接收窗口相关的变量即可，记录
1. 缓存总量
2. rh 收到的字节
3. rh 交给上层的字节数
4. 剩余缓存大小
并封装在 segment 首部进行传递

sh 在运行过程中始终保持剩余缓存非负，借此实现流量控制

当 rh 缓存已满后，sh 不会再向 rh 主动发送信息，这导致即使 rh 清出了缓存空间，sh 也无从得知！

为处理这种情况，我们强制 sh 在缓存已满时，不间断地向 rh 发送只有一个字节的 segment

这样 rh 就可以在对 sh ”骚扰报文“ 的回复报文中，夹带关于接收窗口的信息，使得 sh 得知何时可以重新传送数据

UDP 不提供流量控制

---
### TCP 连接管理

方便叙述，下面 client、server 依旧沿用 sh、rh 的表述

TCP 连接建立过程：
1. sh 向 rh 发送 TCP `SYN` 报文，并随机化 sh 初始序号（防攻击）
2. rh 收到 `SYN` 报文，为该 TCP 连接分配缓存和变量，随机化 rh 初始信号，回复一条 TCP `SYNACK` 报文
	- 此时双方完成空间分配与序号交换
3. sh 收到 `SYNACK` 报文，为连接分配缓存与变量，向 rh 发送确认报文，该报文中 SYN bit 置为 0
	- 三次握手结束，第三次可以携带正常数据

三次握手：
1. 请求
2. 确认请求
3. 确认 请求得到确认

连接关闭：
1. sh 发送 `FIN` 报文，表示 sh 将关闭，等待 rh 的 `FIN`
2. rh 回复 `ACK` 报文
3. rh 发送 `FIN` 报文，表示 rh 将关闭
4. sh 回复 `ACK` 报文，定时等待 rh 的响应
	- 若 rh 没收到 `ACK`，则会进行 `FIN` 重传
	- 一段时间后，sh 没收到 rh 的重传，认为 `ACK` 已被接收
5. sh 关闭，rh 收到 `ACK` 后关闭

*SYN洪泛攻击*
- 大量的 sh 发送 SYN 信息，却不进行第三次握手，使得 rh 端分配大量无用连接资源
- 第二次 SYNACK 握手时，rh 保有 sh 的 SYN 信息，因此可以分配资源，而第三次握手是一次 ACK 信息，怎么分配资源呢？
- 我们采用 *SYN cookie* 技术，将第三次 ACK 与 第一次 SYN 建立映射，从而具备**只为给出了第三次握手的合法用户**分配资源的能力

上面假设 sh 与 rh 都准备好通信，监听端口正常

如果 sh 请求的 socket，rh 并不提供，此时 rh 会回复 `RST` 特殊重置 segment，告知 sh 该 socket 并不合法，不要再发送了

---

nmap 端口扫描工具：
- 向目的端口发送 `SYN` 报文
1. 若收到 `SYNACK` ，意味着目的端口对外开放
2. 若收到 `RST`，意味着不开放，并且我们的报文可以直接抵达主机
3. 若什么都没收到，我们的报文可能被防火墙所阻挡

---
---

### 经典的 TCP 拥塞控制

TCP 根据感知到的拥塞程度，来控制发送流量的速率
1. 如何控制流量？
	- 跟踪一个额外变量：*拥塞窗口* cwnd
	- 修改 cwnd，与 *接收窗口* rwnd 共同作用即可
2. 如何感知拥塞？
	- 指示丢包：超时、或连续三个冗余 ACK
3. 如何确定怎么改变流量速率？
	- 没有拥塞时，通过测量 ACK 的时间，来猜测带宽占用情况，缓慢或迅速地改变速率
	- 确认丢包时，减速
	- 收到 ACK 时，增速
	- 不定期地探测带宽：
		- 先增大速率，试探带宽拥塞的底线
		- 随后逐渐减小速率，直至满意

**TCP 拥塞控制算法**
1. 慢启动
2. 拥塞避免
3. 快速恢复
---

#### 慢启动
以 1 个 MSS 作为 cwnd 的初始值，该初始值较低

下面省略单位 MSS

每收到一个成功的 ACK，cwnd 就增长 1 
此后 cwnd 成指数增长

何时结束这种增长？
- 当检测到超时，就重置 cwnd 至 1 ，同时设置 ssthresh（慢启动阈值）为 cwnd/2
- 当 cwnd 达到 ssthresh 时，结束慢启动，并转移到到拥塞避免模式
- 检测到 3 个冗余 ACK 时，将 cwnd 重置为 ssthresh + 3 执行快速重传并进入快速恢复状态

*大步增长*

---
#### 拥塞避免

此时每个 RTT 增长 1

超时就重置回慢启动
三个冗余 ACK 就快速恢复

*小步增长*

---

#### 快速恢复（非必须但推荐）

每收到一个冗余 ACK，就增长 1

超时就重置进入慢启动
收到新 ACK 就返回拥塞避免模式

*抵消丢包带来的后续大量冗余 ACK 的影响*

---
#### TCP拥塞控制：回顾

拥塞控制：每个 RTT 内增加 1，三连冗余时减半
因此 TCP 拥塞控制被称为**加性增、乘性减（AIMD）** 方式

---
#### TCP CUBIC

TCP Reno 每次都把 cwnd 减半再线性试探，速度慢

认为 AIMD 方式过于谨慎，我们完全可以先快速逼近拥塞上限，再开始线性探测

TCP CUBIC 就以此想法为核心，仍保留慢启动和快速恢复
- 预测达到上界的时间点 K
- 以 ${\lvert t - K\rvert}^3$ 为函数来增加 cwnd
	- 当接近界限时，增长速度开始放慢
	- 但当越过界限时，增长速度则会迅速变大，有利于找到新的临界点，避免在低水平缓慢线性加试探

*Linux 使用 TCP CUBIC*
#### 对 TCP 吞吐量的宏观描述

由于 AIMD 方式的运行，cwnd 总是在 W/2 和 W 之间反复横跳，易知平均吞吐量为 $\frac{0.75 \times W}{RTT}$

---
---

