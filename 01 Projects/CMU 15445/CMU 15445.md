# CMU 15445
## Lab 1
### LRU-K

`evict()` 返回 LRU-K 取出页的指针，并将其标记为删除
`accessRecord()` 更新时间戳
`remove()` 移除指定页的所有访问记录
`setEvictable()` 设置是否可被替换

时间戳在 `LRUKNODE` 内部维护

---
- `evict()` 遍历缓存区，取出块
- `setEvictable()` 直接修改 `lruknode` 即可
- `remove()` 清空 `node` 的时间戳记录
- `accessRecord()` 更新对应的 `node` 

### Buffer Pool Manager
本部分实现对缓存池的管理
#### PageGuard
使用 RAII 对象管理 page 内容
使用 is_valid_  表示有效性
只允许右值构造和赋值
析构时调用Drop()，释放 guard 管理的资源


##### RAII 原则
[RAII介绍](https://csguide.cn/cpp/memory/raii_in_cpp.html#%E7%94%A8-raii-%E6%80%9D%E6%83%B3%E5%8C%85%E8%A3%85-mutex)
[[RAII]]
因此，PageGuard在对page临时读写时被创建，其生命周期是**临时**的
该 RAII 对象负责控制 lock 与 pin_count

参数构造函数获取资源并**初始化**，拷贝和赋值**转移**资源所有权

##### 管理的资源
1. frame 的读写锁
2. bpm 的大锁
3. replacer 的引用情况
4. frame 的引用次数（pin）

#### FrameHeader
通过 *FrameHeader* 类管理 page，frame 可以被复用，通过限制 frame 数量来限制缓存池大小

- `GetData()` 返回 page 指针，提供给 DiskManager 作为地址参数
- 记录 pin_count, dirty 标记，并发锁

#### BufferPoolManager
管理缓存池

行为：
1. 新建/删除 page
2. 读写 page
3. 获取 pageGuard 对象
4. Flush page

页表：提供 `frame_id` 到 `page_id` 映射

成员：
- frame 池
- LRU 调度器
- DISK 调度器
- 页表
- 锁
- next_page_id

##### NewPage()
申请新 page
- 首先检查 frame 池是否有空
- 没空就调用 LRU 替换，取出 frame
	- 如果替换掉的是 dirty page，就写回
- 成功后维护 next_page_id_ 原子量
- 随后将 page 与 frame 绑定
	-  将 page 更新到 LRU 调度器记录
	- 更新*页表*

##### DeletePage()
删除 page
- 检查是否*存在*于页表
- 检查 frame 的 *pin_count_*
- 检查 dirty 标志，写回
- 删除 page，解绑并标记 frame 失效

##### CheckedWritePage()

### 难点
1. 构造 CheckedPageGuard 时，不能两次获取又释放 bpm 锁，一旦获取 frame 就应该立刻修改 pin_count 并分配，否则会产生并发问题
2. 理解 RAII 对象的用处，析构时自动释放持有的资源，这才是重点

## Lab 2
![[Pasted image 20250711232308.png|700]]
	![[Pasted image 20250711232450.png|700]]
![[Pasted image 20250711232534.png||700]]

![[Pasted image 20250711232555.png|700]]
![[Pasted image 20250711232626.png|700]]